<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CodeStack</title>
    <link>https://constructor-md.github.io/codestack/</link>
    <description>Recent content on CodeStack</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <atom:link href="https://constructor-md.github.io/codestack/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>InnoDB 索引</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/mysql/innodb_index/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/mysql/innodb_index/</guid>
      <description>&lt;h1 id=&#34;innodb-索引&#34;&gt;&#xD;&#xA;  InnoDB 索引&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#innodb-%e7%b4%a2%e5%bc%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;表数据结构&#34;&gt;&#xD;&#xA;  表数据结构&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a1%a8%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;索引组织表&#34;&gt;&#xD;&#xA;  索引组织表&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b4%a2%e5%bc%95%e7%bb%84%e7%bb%87%e8%a1%a8&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;每张表必然有主键&lt;/li&gt;&#xA;&lt;li&gt;没有显示建立主键，使用第一个非空唯一索引作为主键&lt;/li&gt;&#xA;&lt;li&gt;没有非空唯一索引，存储引擎自动创建一个6字节大小的指针row_id作为主键&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;逻辑存储架构&#34;&gt;&#xD;&#xA;  逻辑存储架构&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%80%bb%e8%be%91%e5%ad%98%e5%82%a8%e6%9e%b6%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;所有数据存放在表空间中，表空间由段、区、页组成&lt;/li&gt;&#xA;&lt;li&gt;段有数据段、索引段、回滚段等。概念上数据就是索引，数据段就是B+树的叶子节点，索引段是B+树的非叶子节点&lt;/li&gt;&#xA;&lt;li&gt;区是连续页组成的空间，每个区大小固定1MB。页大小16KB，每区固定64个连续页&lt;/li&gt;&#xA;&lt;li&gt;页是存储引擎数据管理最小单位，每次读写磁盘最小一页，即16KB&lt;/li&gt;&#xA;&lt;li&gt;行：Innodb是面向列的存储引擎，数据按行存放，每页最多存放7992行记录&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;b树&#34;&gt;&#xD;&#xA;  B+树&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#b%e6%a0%91&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;B+树由二叉查找树和二叉平衡树发展而来，但B+树是多叉树，减小树高度&lt;/li&gt;&#xA;&lt;li&gt;B+树的记录数据都在叶子节点上，非叶子节点存放的数据是索引值&lt;/li&gt;&#xA;&lt;li&gt;叶子节点之间以指针双向连接，形成链表，方便范围查找&lt;/li&gt;&#xA;&lt;li&gt;B+树索引分成聚簇索引和二级索引，区别在于叶子节点是否存放所有行信息&lt;/li&gt;&#xA;&lt;li&gt;B+树是平衡树，所有叶子节点在同一层，查询稳定性高&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;优势&#34;&gt;&#xD;&#xA;  优势&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bc%98%e5%8a%bf&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;树高度低，减少磁盘IO&#xA;&lt;ol&gt;&#xA;&lt;li&gt;每个非叶子节点存放多个范围的下一级节点的指针，而不只是普通二叉查找树的两个，靠这一点减少树高度&lt;/li&gt;&#xA;&lt;li&gt;在索引树上查找时，先从磁盘读取根节点，每找到下一级索引就要从磁盘读取索引页得到数据继续判断，索引树高度低，使得读取一次磁盘筛选数据效率高，大幅减少磁盘IO次数&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;叶子链表范围查询高效&#xA;叶子节点形成索引值的顺序链表，支持顺序遍历，便于范围查询&lt;/li&gt;&#xA;&lt;li&gt;查询稳定性&#xA;&lt;ol&gt;&#xA;&lt;li&gt;B+树使用分裂+合并技术保持结构稳定性。因为插入数据导致一个节点达到容量上限，就会分裂成两个节点；因为删除数据导致两个节点太小，空间利用率低，就会合并成一个节点。这也是它的自平衡策略的一部分，同层横向扩展&lt;/li&gt;&#xA;&lt;li&gt;B+树高度变化少，一般最高四层就能存储千万以上数据&lt;/li&gt;&#xA;&lt;li&gt;只有叶子节点才有具体数据，插入和删除对树结构影响小&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;对比b树&#34;&gt;&#xD;&#xA;  对比B树&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%b9%e6%af%94b%e6%a0%91&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;B树非叶子节点存放数据，使得一次读取磁盘筛选数据效率低，且树高度变高，磁盘IO负担大&lt;/p&gt;&#xA;&lt;h3 id=&#34;聚簇索引聚集索引主键索引&#34;&gt;&#xD;&#xA;  聚簇索引/聚集索引/主键索引&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%81%9a%e7%b0%87%e7%b4%a2%e5%bc%95%e8%81%9a%e9%9b%86%e7%b4%a2%e5%bc%95%e4%b8%bb%e9%94%ae%e7%b4%a2%e5%bc%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;按主键构造B+树&lt;/li&gt;&#xA;&lt;li&gt;叶子节点存放的行记录信息包含所有列&lt;/li&gt;&#xA;&lt;li&gt;通过聚集索引查找数据，可以直接在叶子节点得到全部数据&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;二级索引&#34;&gt;&#xD;&#xA;  二级索引&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8c%e7%ba%a7%e7%b4%a2%e5%bc%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;根据索引列值构造B+树&lt;/li&gt;&#xA;&lt;li&gt;叶子节点有索引值、该索引值对应的主键&lt;/li&gt;&#xA;&lt;li&gt;通过二级索引查找数据时，会根据索引找到对应的叶子节点，再根据叶子节点上的主键值，回表到主键索引获取更多列数据&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;索引失效情况枚举&#34;&gt;&#xD;&#xA;  索引失效情况枚举&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b4%a2%e5%bc%95%e5%a4%b1%e6%95%88%e6%83%85%e5%86%b5%e6%9e%9a%e4%b8%be&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;隐式类型转换导致索引失效&#34;&gt;&#xD;&#xA;  隐式类型转换导致索引失效&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%9a%90%e5%bc%8f%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2%e5%af%bc%e8%87%b4%e7%b4%a2%e5%bc%95%e5%a4%b1%e6%95%88&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;原因：查询条件和主键类型不一致，转换失败时无法使用索引，导致全表扫描&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;-- 索引`id`为INT类型&#xD;&#xA;SELECT * FROM t WHERE id = &amp;#39;100&amp;#39;; -- 字符串转INT，索引有效（依赖优化器）&#xD;&#xA;SELECT * FROM t WHERE id = &amp;#39;100ABC&amp;#39;; -- 转换失败，全表扫描&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;使用函数或计算索引列&#34;&gt;&#xD;&#xA;  使用函数或计算索引列&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8%e5%87%bd%e6%95%b0%e6%88%96%e8%ae%a1%e7%ae%97%e7%b4%a2%e5%bc%95%e5%88%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;原因：索引树结构逻辑为大小排列，函数计算后无法找到对应的节点&lt;/p&gt;</description>
    </item>
    <item>
      <title>Ubuntu</title>
      <link>https://constructor-md.github.io/codestack/docs/deploy/ubuntu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/deploy/ubuntu/</guid>
      <description>&lt;h1 id=&#34;ubuntu&#34;&gt;&#xD;&#xA;  Ubuntu&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#ubuntu&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;采用版本：24.01&lt;/p&gt;&#xA;&lt;p&gt;安装过程：全部 Done&lt;/p&gt;&#xA;&lt;h2 id=&#34;非root用户上传文件&#34;&gt;&#xD;&#xA;  非Root用户上传文件&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%9d%9eroot%e7%94%a8%e6%88%b7%e4%b8%8a%e4%bc%a0%e6%96%87%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 赋予指定用户组用户在某个文件夹及其子文件夹上传文件的权限&#xD;&#xA; sudo chown -R quanta:quanta /DATA&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;时区设置&#34;&gt;&#xD;&#xA;  时区设置&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%97%b6%e5%8c%ba%e8%ae%be%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 查看当前时区&#xD;&#xA;timedatectl&#xD;&#xA;# 查看东八区全称&#xD;&#xA;timedatectl list-timezones | grep Shanghai&#xD;&#xA;# 设置时区&#xD;&#xA;sudo timedatectl set-timezone Asia/Shanghai&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;host设置&#34;&gt;&#xD;&#xA;  host设置&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#host%e8%ae%be%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;便于多主机内网互相访问&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo vim /etc/hosts&#xD;&#xA;&#xD;&#xA;# 补充相关机器的ip 主机名&#xD;&#xA;192.168.1.11 dataserver1&#xD;&#xA;192.168.1.12 dataserver2&#xD;&#xA;192.168.1.13 dataserver3&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;openssh安装&#34;&gt;&#xD;&#xA;  OpenSSH安装&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#openssh%e5%ae%89%e8%a3%85&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo apt update &amp;amp;&amp;amp; sudo apt upgrade&#xD;&#xA;sudo apt install openssh-server&#xD;&#xA;service ssh status&#xD;&#xA;# 随后可以本机SSH使用安装过程设置的账户密码登录服务器&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;修改监听端口&#34;&gt;&#xD;&#xA;  修改监听端口&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bf%ae%e6%94%b9%e7%9b%91%e5%90%ac%e7%ab%af%e5%8f%a3&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo vi /etc/ssh/sshd_config&#xD;&#xA;# 内容&#xD;&#xA;Port 2222&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修改后要重启&lt;/p&gt;</description>
    </item>
    <item>
      <title>依赖注入|控制反转|自动装配</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/spring/ioc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/spring/ioc/</guid>
      <description>&lt;h1 id=&#34;依赖注入控制反转自动装配&#34;&gt;&#xD;&#xA;  依赖注入|控制反转|自动装配&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5%e6%8e%a7%e5%88%b6%e5%8f%8d%e8%bd%ac%e8%87%aa%e5%8a%a8%e8%a3%85%e9%85%8d&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;控制反转ioc与依赖注入di&#34;&gt;&#xD;&#xA;  控制反转(IOC)与依赖注入(DI)&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8e%a7%e5%88%b6%e5%8f%8d%e8%bd%acioc%e4%b8%8e%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5di&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;控制反转基本概念：  &lt;br&gt;&#xA;将对象的创建和管理的控制权，从某个实体类，转交给 Spring 容器&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;在传统模式中，对象需要哪些资源就要在类代码中写明自己去 new 出来&lt;br&gt;&#xA;现在则统一由 Spring 提供，从主动变成了被动。称为控制反转&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;依赖注入基本概念：&lt;br&gt;&#xA;对象间的依赖关系，被 Spring 容器自动注入到需要他们的对象中去&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;也就是由 Spring 容器来管理对象间的依赖关系&#xA;依赖注入是控制反转的一种实现形式&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;指的是组件自身提供普通的 Java 方法声明依赖关系。容器全权负责组件依赖关系的装配，将根据这些声明主动将符合依赖关系的对象设置给需要的对象，实现原理是反射&lt;/li&gt;&#xA;&lt;li&gt;为了实现控制反转的概念，Spring 实现了依赖注入的机制&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;依赖注入机制的使用方式：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;属性注入形式&#xA;xml方式：使类有 Set 方法，并设置 bean 和 property 。Spring 读取 xml 文件时，认为需要向 bean a 注入 bean b。这实质上是通过，使类有 set 方法，从而可实现用xml文件声明属性依赖关系，从而声明依赖关系，寻求注入的方式。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;img src=&#34;./images/DI-param.png&#34; alt=&#34;属性注入&#34; title=&#34;属性注入&#34;/&gt;&lt;/p&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;构造器注入形式&#xA;xml方式：使类具备有参构造函数，并设置 bean 和 property。实质上与上述是相似的，只是多支持了一种声明的方式。&#xA;&lt;img src=&#34;./images/DI-struct.png&#34; alt=&#34;构造器注入&#34; title=&#34;构造器注入&#34;/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Java显式配置&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过注解，描述某个类应该作为 Bean 被容器管理，且内部包含一些如何在上下文中创建 Bean 的细节。如 @Configuration。&lt;/li&gt;&#xA;&lt;li&gt;通过注解，描述某个方法的返回结果应该作为 Bean 被容器管理，如 @Bean。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;自动装配&#34;&gt;&#xD;&#xA;  自动装配&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%87%aa%e5%8a%a8%e8%a3%85%e9%85%8d&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;上述的依赖注入的使用方式，实际上都是在告诉 Spring 容器如何装配对象间的依赖关系&#xA;Spring 对于描述 Bean 如何进行装配时，提供了三种主要的装配机制：&lt;/p&gt;</description>
    </item>
    <item>
      <title>AOP</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/spring/aop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/spring/aop/</guid>
      <description>&lt;h1 id=&#34;aop&#34;&gt;&#xD;&#xA;  AOP&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aop&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;基本概念：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;编程时将所需逻辑写在切面中&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这么做的好处是，让一些公共的逻辑，重复的代码，能够出现在统一的位置，即切面中，方便维护，减少重复代码的开发量。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;思路上，是通过为某些切面，为某些方法提供行为增强。这种增强可能出现在方法执行前，方法执行后，方法返回前，方法异常时等。&lt;/li&gt;&#xA;&lt;li&gt;实现方法上，出于对某个方法进行前置或后置逻辑的编写的角度，想要通过代理模式来实现功能。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Spring的切面实现，支持了两种代理模式：JDK动态代理（默认）、CGLIB动态代理&lt;/p&gt;&#xA;&lt;h2 id=&#34;spring的动态代理实现&#34;&gt;&#xD;&#xA;  Spring的动态代理实现&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring%e7%9a%84%e5%8a%a8%e6%80%81%e4%bb%a3%e7%90%86%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;众所周知，代理模式的实现方法就是为当前类或者方法创建代理类&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;实际调用时调用代理类&lt;/li&gt;&#xA;&lt;li&gt;代理类再调用原本方法逻辑，代理类本身可以在调用原本方法前后&amp;quot;编织&amp;quot;入一些定义好的代码，在调用原本方法前后执行&amp;quot;编织&amp;quot;入的方法，实现&amp;quot;方法增强&amp;quot;&lt;/li&gt;&#xA;&lt;li&gt;探讨Spring如何实现动态代理，其实是探讨Spring如何动态创建代理类&#xA;&lt;ul&gt;&#xA;&lt;li&gt;静态代理是直接硬编码编写代理类，并替换调用方方法调用代理类&lt;/li&gt;&#xA;&lt;li&gt;但是动态代理就需要有一套代码，能根据不同内容的原本类，动态构建一个代理类，并在调用原本方法前后调用切面类内编写的增强方法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;静态代理示例&#34;&gt;&#xD;&#xA;  静态代理示例&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%9d%99%e6%80%81%e4%bb%a3%e7%90%86%e7%a4%ba%e4%be%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class ProxySubject implements Subject {&#xD;&#xA;    private RealSubject realSubject;&#xD;&#xA;&#xD;&#xA;    public ProxySubject(RealSubject realSubject) {&#xD;&#xA;        this.realSubject = realSubject;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    @Override&#xD;&#xA;    public void request() {&#xD;&#xA;        // 方法调用前的增强代码&#xD;&#xA;        System.out.println(&amp;#34;ProxySubject: Before calling the real subject.&amp;#34;);&#xD;&#xA;&#xD;&#xA;        // 调用被代理对象的方法&#xD;&#xA;        realSubject.request();&#xD;&#xA;&#xD;&#xA;        // 方法调用后的增强代码&#xD;&#xA;        System.out.println(&amp;#34;ProxySubject: After calling the real subject.&amp;#34;);&#xD;&#xA;    }&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;spring-aop-动态代理源码解析&#34;&gt;&#xD;&#xA;  Spring AOP 动态代理源码解析&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-aop-%e5%8a%a8%e6%80%81%e4%bb%a3%e7%90%86%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;接下来从源码层面逐一剖析Spring是如何实现AOP&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用项目：&lt;a href=&#34;https://github.com/constructor-md/kuibu-service&#34;&gt;跬步后端项目仓库&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;Branch: main&lt;/li&gt;&#xA;&lt;li&gt;commit: f2763b5c8308f59a399ad32ae2cdffef8aee1ee0&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;我的项目采用 SpringBoot:2.7.6 版本，直接引入 spring-boot-starter-aop 包&#xA;&lt;img src=&#34;./images/pom-springboot.png&#34; alt=&#34;pom-springboot&#34; title=&#34;pom-springboot&#34;/&gt;&#xA;&lt;img src=&#34;./images/pom-aop.png&#34; alt=&#34;pom-aop&#34; title=&#34;pom-aop&#34;/&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>InnoDB 事务</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/mysql/innodb_transaction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/mysql/innodb_transaction/</guid>
      <description>&lt;h1 id=&#34;innodb-事务&#34;&gt;&#xD;&#xA;  InnoDB 事务&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#innodb-%e4%ba%8b%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;MySQL中，事务功能主要是由 InnoDB 存储引擎来实现的&lt;/p&gt;&#xA;&lt;h2 id=&#34;innodb-事务特性acid及实现&#34;&gt;&#xD;&#xA;  InnoDB 事务特性（ACID）及实现&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#innodb-%e4%ba%8b%e5%8a%a1%e7%89%b9%e6%80%a7acid%e5%8f%8a%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;原子性atomicity&#34;&gt;&#xD;&#xA;  原子性（Atomicity）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8e%9f%e5%ad%90%e6%80%a7atomicity&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;事务内的操作要么全部成功，要么全部失败&lt;/p&gt;&#xA;&lt;p&gt;通过Undo Log实现原子性&lt;br&gt;&#xA;Undo Log 记录事务操作的反操作，或者说记录了每个操作前的数据，当事务需要回滚时，可以根据Undo Log恢复数据。&lt;br&gt;&#xA;从而实现事务内的操作要么全部执行，要么都不执行&lt;/p&gt;&#xA;&lt;h3 id=&#34;一致性consistency&#34;&gt;&#xD;&#xA;  一致性（Consistency）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%80%e8%87%b4%e6%80%a7consistency&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;事务必须使数据库从一个一致性状态变换到另一个一致性状态&lt;br&gt;&#xA;依赖于原子性和隔离性的实现，还依赖于数据库自身的完整性约束(如外键、CHECK 约束等)和应用程序的正确逻辑&lt;/p&gt;&#xA;&lt;h3 id=&#34;持久性durability&#34;&gt;&#xD;&#xA;  持久性（Durability）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8c%81%e4%b9%85%e6%80%a7durability&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作&lt;br&gt;&#xA;通过数据写入磁盘，以及Redo Log记录写入内存未写入磁盘的操作，在系统崩溃恢复时写入磁盘。保证持久性&lt;br&gt;&#xA;Redo Log本身在磁盘顺序写入，速度很快&lt;/p&gt;&#xA;&lt;h3 id=&#34;隔离性isolation&#34;&gt;&#xD;&#xA;  隔离性（Isolation）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%9a%94%e7%a6%bb%e6%80%a7isolation&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;多个并发事务之间要相互隔离。对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始&lt;/p&gt;&#xA;&lt;p&gt;通过MVCC和锁机制实现隔离性&lt;/p&gt;&#xA;&lt;p&gt;先说明MVCC隔离性实现原理，锁机制放在锁的篇章中&lt;/p&gt;&#xA;&lt;h3 id=&#34;mvcc&#34;&gt;&#xD;&#xA;  MVCC&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mvcc&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;innodb通过ReadView快照和版本链实现MVCC&lt;/p&gt;&#xA;&lt;h4 id=&#34;readview-快照&#34;&gt;&#xD;&#xA;  ReadView 快照&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#readview-%e5%bf%ab%e7%85%a7&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;Readview是代码中的对象，主要有如下属性：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;m_ids: 生成ReadView时当前系统中活跃的读写事务的事务id列表（未提交的事务）&lt;/li&gt;&#xA;&lt;li&gt;min_trx_id: 生成ReadView时当前系统中活跃的读写事务的最小事务id m_ids的最小值（最早的未提交事务）&lt;/li&gt;&#xA;&lt;li&gt;max_trx_id: 生成ReadView时系统应该分配给下一个事务的id值（下一个事务）&lt;/li&gt;&#xA;&lt;li&gt;creator_trx_id: 生成该ReadView的事务的id（所属事务）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;版本链&#34;&gt;&#xD;&#xA;  版本链&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%89%88%e6%9c%ac%e9%93%be&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;在Innodb中，以最新记录和 undo log 中的历史记录形成了版本链&lt;br&gt;&#xA;Innodb的每行数据，都有两个隐藏字段：事务ID和回滚指针&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;事务ID代表这行数据由哪个事务最后更新，回滚指针指向Undo Log中这行数据的上一个版本&lt;/li&gt;&#xA;&lt;li&gt;Undo Log中记录了数据的每个版本，同样也携带着修改成该版本的事务ID和指向上一个版本的回滚指针&lt;/li&gt;&#xA;&lt;li&gt;每行最新的数据，以及Undo Log中的历史版本中的数据，的回滚指针们形成了一条链表，即版本链&lt;/li&gt;&#xA;&lt;li&gt;事务的每个修改，不论是否已经提交，都会被记录在版本链上&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;MySQL 中有专门的 Purge 线程，会定期检查 Undo Log，删除那些已经不再需要的记录&lt;br&gt;&#xA;Purge 操作会遍历 Undo Log 链表，找到那些没有被任何活动事务引用的节点，并将其从磁盘上删除，释放空间&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL</title>
      <link>https://constructor-md.github.io/codestack/docs/deploy/mysql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/deploy/mysql/</guid>
      <description>&lt;h1 id=&#34;mysql&#34;&gt;&#xD;&#xA;  MySQL&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mysql&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;安装版本：MySQL 8.0.20&lt;/p&gt;&#xA;&lt;p&gt;部署方式：一主二从&lt;/p&gt;&#xA;&lt;p&gt;运行方式：docker-compose&lt;/p&gt;&#xA;&lt;h2 id=&#34;各节点安装&#34;&gt;&#xD;&#xA;  各节点安装&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%90%84%e8%8a%82%e7%82%b9%e5%ae%89%e8%a3%85&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;创建mysql目录&#34;&gt;&#xD;&#xA;  创建MySQL目录&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9b%e5%bb%bamysql%e7%9b%ae%e5%bd%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 放置所有mysql相关文件 比如my.cnf&#xD;&#xA;sudo mkdir /DATA/mysql&#xD;&#xA;# 放置mysql数据文件 也作为mysql&#xD;&#xA;sudo mkdir /DATA/mysql/mysql&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;创建mysql用户并设置权限&#34;&gt;&#xD;&#xA;  创建MySQL用户并设置权限&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9b%e5%bb%bamysql%e7%94%a8%e6%88%b7%e5%b9%b6%e8%ae%be%e7%bd%ae%e6%9d%83%e9%99%90&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 创建mysql用户 设置为不可登陆系统 并设置用户的主目录为/DATA/mysql/mysql&#xD;&#xA;sudo useradd -r -s /sbin/nologin -d /DATA/mysql/mysql mysql&#xD;&#xA;# 指定mysql用户的主目录为/DATA/mysql/mysql&#xD;&#xA;sudo usermod -d /DATA/mysql/mysql mysql&#xD;&#xA;# 递归地将/DATA/mysql/mysql目录及其所有子目录和文件的所有者和所属组设置为mysql用户和mysql组&#xD;&#xA;sudo chown -R mysql:mysql /DATA/mysql/mysql&#xD;&#xA;# 递归地将/DATA/mysql/mysql目录及其子目录设和文件的权限设置为755&#xD;&#xA;# 755：所有者有读写和执行权限，组用户和其他用户有读和执行权限&#xD;&#xA;sudo chmod -R 755 /DATA/mysql/mysql&#xD;&#xA;# 查找/etc/passwd文件中包含mysql的行 /etc/passwd是系统用户信息文件，包含所有用户的基本信息&#xD;&#xA;grep mysql /etc/passwd&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;操作失误时的可选操作&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 删除用户及其主目录 没有r不删除主目录&#xD;&#xA;sudo userdel -r mysql&#xD;&#xA;# 手动删除主目录&#xD;&#xA;sudo rm -rf /DATA/mysql&#xD;&#xA;# 检查 &#xD;&#xA;grep mysql /etc/passwd&#xD;&#xA;# 删除用户组&#xD;&#xA;sudo groupdel mysql&#xD;&#xA;# 检查用户组是否删除&#xD;&#xA;grep mysql /etc/group&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;docker-compose文件&#34;&gt;&#xD;&#xA;  docker-compose文件&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#docker-compose%e6%96%87%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 创建docker-compose文件在/DATA下，或者追加在已有文件中&#xD;&#xA;vim docker-compose.yml&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;docker-compose.yml&lt;/p&gt;</description>
    </item>
    <item>
      <title>InnoDB 锁机制</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/mysql/innodb_lock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/mysql/innodb_lock/</guid>
      <description>&lt;h1 id=&#34;innodb-锁机制&#34;&gt;&#xD;&#xA;  InnoDB 锁机制&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#innodb-%e9%94%81%e6%9c%ba%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;锁分类和特性&#34;&gt;&#xD;&#xA;  锁分类和特性&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%94%81%e5%88%86%e7%b1%bb%e5%92%8c%e7%89%b9%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;S锁与X锁互斥，与S锁兼容&lt;/li&gt;&#xA;&lt;li&gt;X锁与S/X锁互斥&lt;/li&gt;&#xA;&lt;li&gt;加锁是实际是锁索引或者锁表&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果用了主键就锁聚簇索引&lt;/li&gt;&#xA;&lt;li&gt;如果用了二级索引就锁定二级索引再锁定聚簇索引&lt;/li&gt;&#xA;&lt;li&gt;如果没用到索引，就锁表&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;锁的释放时机是事务提交或回滚&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;行级锁&#34;&gt;&#xD;&#xA;  行级锁&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a1%8c%e7%ba%a7%e9%94%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基本的加锁是临键锁，因为一些条件转换为间隙锁、行锁、表锁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;记录锁sx锁&#34;&gt;&#xD;&#xA;  记录锁（S/X锁）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%ae%b0%e5%bd%95%e9%94%81sx%e9%94%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;单索引值锁&lt;/p&gt;&#xA;&lt;h4 id=&#34;间隙锁s锁&#34;&gt;&#xD;&#xA;  间隙锁（S锁）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%97%b4%e9%9a%99%e9%94%81s%e9%94%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在两行/两索引之间的左开右开区间锁&lt;/li&gt;&#xA;&lt;li&gt;间隙锁S与插入意向锁X互斥，作用是防止其他事务插入数据，避免幻读&lt;/li&gt;&#xA;&lt;li&gt;间隙锁S之间是兼容的&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;临键锁sx记录锁s间隙锁&#34;&gt;&#xD;&#xA;  临键锁（S/X记录锁+s间隙锁）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%b4%e9%94%ae%e9%94%81sx%e8%ae%b0%e5%bd%95%e9%94%81s%e9%97%b4%e9%9a%99%e9%94%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对记录行，以及以记录行本身主键/索引值为右边界，往前一个主键值/索引值为左边界的，左开右闭区间锁&lt;/li&gt;&#xA;&lt;li&gt;临键锁的记录部分与其他临键锁的记录部分根据记录锁的S/X区分冲突&#xA;&lt;ul&gt;&#xA;&lt;li&gt;临键锁的记录部分与其他临键锁的间隙锁不会冲突，不如说不存在加了间隙锁还有记录在中间的情况，也不存在有记录锁居然能加间隙锁的情况&lt;/li&gt;&#xA;&lt;li&gt;临键锁的间隙锁和其他临键锁的间隙锁不冲突&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;插入意向锁x模式间隙锁&#34;&gt;&#xD;&#xA;  插入意向锁（X模式间隙锁）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8f%92%e5%85%a5%e6%84%8f%e5%90%91%e9%94%81x%e6%a8%a1%e5%bc%8f%e9%97%b4%e9%9a%99%e9%94%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;与普通S间隙锁互斥，插入意向锁之间不互斥（特殊）&lt;/li&gt;&#xA;&lt;li&gt;insert插入数据时，需要对所在间隙加插入意向锁，多个事务可以对同一间隙加插入意向锁&lt;/li&gt;&#xA;&lt;li&gt;如果该间隙存在普通间隙锁，则插入意向锁会被阻塞&lt;/li&gt;&#xA;&lt;li&gt;多个事务插入数据，只要对应主键和索引无约束冲突，就可以并发执行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;表级锁&#34;&gt;&#xD;&#xA;  表级锁&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a1%a8%e7%ba%a7%e9%94%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;h4 id=&#34;表锁sx锁&#34;&gt;&#xD;&#xA;  表锁（S/X锁）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a1%a8%e9%94%81sx%e9%94%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当进行需要加锁操作，但是未能明确指定主键/索引时，Innodb会扫描全表，对主键聚簇索引加临键锁（覆盖所有行，等效表锁）&lt;/li&gt;&#xA;&lt;li&gt;或显示使用 Lock Tables xxx write/read (Innodb不推荐，应优先行锁)&lt;/li&gt;&#xA;&lt;li&gt;是极端状态下的行锁集合（全表行锁+间隙锁），性能极差&lt;/li&gt;&#xA;&lt;li&gt;S表锁阻塞各种行X锁，不阻塞S锁。X表锁阻塞各种行X锁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;意向锁isix锁表级信号锁&#34;&gt;&#xD;&#xA;  意向锁（IS/IX锁，表级信号锁）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%84%8f%e5%90%91%e9%94%81isix%e9%94%81%e8%a1%a8%e7%ba%a7%e4%bf%a1%e5%8f%b7%e9%94%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当事务对某行加行级S锁，自动对表加意向共享锁（IS锁）&lt;/li&gt;&#xA;&lt;li&gt;当事务对某行加行级X锁，自动对表加意向排他锁（IX锁）&lt;/li&gt;&#xA;&lt;li&gt;永远与行级S/X锁共存（行锁必然带有对应意向锁）&lt;/li&gt;&#xA;&lt;li&gt;作用仅是标记“表中存在行锁”，以与全表锁互斥，不阻塞其他行锁和表意向锁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;语句加锁情况枚举可重复读级别&#34;&gt;&#xD;&#xA;  语句加锁情况枚举（可重复读级别）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%ad%e5%8f%a5%e5%8a%a0%e9%94%81%e6%83%85%e5%86%b5%e6%9e%9a%e4%b8%be%e5%8f%af%e9%87%8d%e5%a4%8d%e8%af%bb%e7%ba%a7%e5%88%ab&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;可以根据语句加锁情况和对应区域锁的S/X模式，来理论判断锁冲突情况&lt;/p&gt;&#xA;&lt;h3 id=&#34;普通查询&#34;&gt;&#xD;&#xA;  普通查询&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%99%ae%e9%80%9a%e6%9f%a5%e8%af%a2&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不加锁，快照读，不会导致并发阻塞。且因为是快照读，不会幻读&lt;/li&gt;&#xA;&lt;li&gt;基于MVCC进行快照读，查询开始时生成快照，可读取已提交事务和本快照事务修改的数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;select--for-update&#34;&gt;&#xD;&#xA;  SELECT &amp;hellip; FOR UPDATE&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#select--for-update&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;唯一索引等值查询且匹配到数据，对匹配行加行锁（X锁）&lt;/li&gt;&#xA;&lt;li&gt;唯一索引范围查询且匹配到数据，对所有匹配行加临键锁（X记录锁+S间隙锁）&lt;/li&gt;&#xA;&lt;li&gt;唯一索引查询未匹配到数据，目标值所在间隙加间隙锁（S锁）&lt;/li&gt;&#xA;&lt;li&gt;普通索引范围查询匹配到数据，范围内索引项加临键锁（X记录锁+S间隙锁），对应主键行锁（X锁）&lt;/li&gt;&#xA;&lt;li&gt;普通索引查询未匹配到数据，目标值所在间隙加间隙锁（S锁）&lt;/li&gt;&#xA;&lt;li&gt;不使用索引/索引失效，退化为全表锁（各行X锁，间隙S锁）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;select--lock-in-share-mode&#34;&gt;&#xD;&#xA;  SELECT &amp;hellip; LOCK IN SHARE MODE&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#select--lock-in-share-mode&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;唯一索引等值查询且匹配到数据，对匹配行加行锁（S锁）&lt;/li&gt;&#xA;&lt;li&gt;唯一索引范围查询且匹配到数据，对所有匹配行加临键锁（S记录锁+S间隙锁）&lt;/li&gt;&#xA;&lt;li&gt;唯一索引查询未匹配到数据，目标值所在间隙加间隙锁（S锁）&lt;/li&gt;&#xA;&lt;li&gt;普通索引范围查询匹配到数据，范围内索引项加临键锁（S记录锁+S间隙锁），对应主键行锁（S锁）&lt;/li&gt;&#xA;&lt;li&gt;普通索引查询未匹配到数据，目标值所在间隙加间隙锁（S锁）&lt;/li&gt;&#xA;&lt;li&gt;不使用索引/索引失效，退化为全表锁（各行S锁，间隙S锁）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;insert&#34;&gt;&#xD;&#xA;  insert&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#insert&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;单行插入&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;尝试对插入间隙加插入意向锁X锁，如果存在间隙锁S锁，就阻塞等待&lt;/li&gt;&#xA;&lt;li&gt;加锁成功后执行插入，对插入位置加X锁，仅自己能插入，并执行插入&lt;/li&gt;&#xA;&lt;li&gt;如果位置上有别的数据插入的数据，则阻塞等待其他事务提交释放锁&lt;/li&gt;&#xA;&lt;li&gt;多个事务可以并发插入同个间隙的不同位置，不互相阻塞&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;批量插入&#xA;逐行执行多个单行插入，重复上述过程&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;update&#34;&gt;&#xD;&#xA;  update&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#update&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对where条件匹配的行加X锁&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果用了唯一索引（索引扫描），对匹配索引值加记录X锁&lt;/li&gt;&#xA;&lt;li&gt;如果用了普通索引（索引扫描），对匹配索引值加临键X锁&lt;/li&gt;&#xA;&lt;li&gt;如果没有使用索引或者索引失效（全表扫描），对全表加X表锁(所有记录X临键锁)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;如果会更新索引字段，旧索引项加X锁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;delete&#34;&gt;&#xD;&#xA;  delete&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#delete&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对where条件匹配的行加X锁&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果用了唯一索引（索引扫描），对匹配索引值加记录X锁&lt;/li&gt;&#xA;&lt;li&gt;如果用了普通索引（索引扫描），对匹配索引值加临键X锁&lt;/li&gt;&#xA;&lt;li&gt;如果没有使用索引或者索引失效（全表扫描），对全表加X表锁(所有记录X临键锁)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;可以优化的操作方向&#34;&gt;&#xD;&#xA;  可以优化的操作方向&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%af%e4%bb%a5%e4%bc%98%e5%8c%96%e7%9a%84%e6%93%8d%e4%bd%9c%e6%96%b9%e5%90%91&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;测试机检查&#34;&gt;&#xD;&#xA;  测试机检查&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b5%8b%e8%af%95%e6%9c%ba%e6%a3%80%e6%9f%a5&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;测试SQL执行究竟是加表锁还是行锁等，修改以避免表锁&lt;/p&gt;</description>
    </item>
    <item>
      <title>Redis</title>
      <link>https://constructor-md.github.io/codestack/docs/deploy/redis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/deploy/redis/</guid>
      <description>&lt;h1 id=&#34;redis&#34;&gt;&#xD;&#xA;  Redis&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#redis&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;安装版本：7.0.4&lt;/p&gt;&#xA;&lt;p&gt;部署方式：一主二从三哨兵&lt;/p&gt;&#xA;&lt;p&gt;节点分配：每节点一个Redis-Server，一个Sentinel&lt;/p&gt;&#xA;&lt;p&gt;运行方式：docker-compose&lt;/p&gt;&#xA;&lt;h2 id=&#34;目录和用户权限&#34;&gt;&#xD;&#xA;  目录和用户权限&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%9b%ae%e5%bd%95%e5%92%8c%e7%94%a8%e6%88%b7%e6%9d%83%e9%99%90&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;创建redis和sentinel目录&#34;&gt;&#xD;&#xA;  创建Redis和Sentinel目录&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9b%e5%bb%baredis%e5%92%8csentinel%e7%9b%ae%e5%bd%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 存放所有Redis相关文件&#xD;&#xA;sudo mkdir /DATA/redis&#xD;&#xA;# 存放Redis和Sentinel配置文件&#xD;&#xA;sudo mkdir /DATA/redis/config&#xD;&#xA;# 存放Sentinel配置和文件&#xD;&#xA;sudo mkdir /DATA/redis/config/sentinel&#xD;&#xA;# 存放挂载docker内运行Redis的数据目录&#xD;&#xA;sudo mkdir /DATA/redis/data&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;创建redis用户并设置工作目录&#34;&gt;&#xD;&#xA;  创建redis用户并设置工作目录&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9b%e5%bb%baredis%e7%94%a8%e6%88%b7%e5%b9%b6%e8%ae%be%e7%bd%ae%e5%b7%a5%e4%bd%9c%e7%9b%ae%e5%bd%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 创建 redis 用户 设置为不可登陆系统 并设置用户的主目录为/DATA/redis/data&#xD;&#xA;sudo useradd -r -s /sbin/nologin -d /DATA/redis/data redis&#xD;&#xA;# 指定 redis 用户的主目录为/DATA/redis/data&#xD;&#xA;sudo usermod -d /DATA/redis/data redis&#xD;&#xA;# 递归地将/DATA/redis/data目录及其所有子目录和文件的所有者和所属组设置为redis用户和redis组&#xD;&#xA;sudo chown -R redis:redis /DATA/redis/data&#xD;&#xA;# 递归地将/DATA/redis/data目录及其子目录设和文件的权限设置为755&#xD;&#xA;# 755：所有者有读写和执行权限，组用户和其他用户有读和执行权限&#xD;&#xA;sudo chmod -R 755 /DATA/redis/data&#xD;&#xA;# 查找/etc/passwd文件中包含mysql的行 /etc/passwd是系统用户信息文件，包含所有用户的基本信息&#xD;&#xA;grep redis /etc/passwd&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;主节点配置&#34;&gt;&#xD;&#xA;  主节点配置&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%bb%e8%8a%82%e7%82%b9%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;redisconf&#34;&gt;&#xD;&#xA;  redis.conf&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#redisconf&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo vim /DATA/redis/config/redis.conf&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# 监听端口&#xD;&#xA;port 63790&#xD;&#xA;# 访问密码&#xD;&#xA;requirepass password&#xD;&#xA;# 数据库数量 使用cluster模式时只会有一个database即DB0&#xD;&#xA;databases 16&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# 绑定本机的网络接口（网卡） 绑定的是网卡的IP地址&#xD;&#xA;# 0.0.0.0 监听所有 默认127.0.0.1&#xD;&#xA;bind 0.0.0.0&#xD;&#xA;&#xD;&#xA;# 默认开启&#xD;&#xA;# 如果没有设置密码和且没有设置bind，只允许本机访问&#xD;&#xA;protected-mode yes&#xD;&#xA;&#xD;&#xA;# 单位秒，timeout时间内客户端没有数据交互，关闭连接&#xD;&#xA;timeout 60&#xD;&#xA;&#xD;&#xA;# 客户端同时连接的最大数量 默认10000&#xD;&#xA;# 达到最大值时关闭新连接并返回max number of clients reached&#xD;&#xA;maxclients 1000&#xD;&#xA;&#xD;&#xA;# 内存管理 &#xD;&#xA;# 最大内存，推荐最大设置为6GB&#xD;&#xA;# 不要设置过大内存，防止执行RDB内存快照文件或者AOF重写时因为数据太大阻塞太长时间&#xD;&#xA;maxmemory 2GB&#xD;&#xA;&#xD;&#xA;# 内存淘汰策略 默认noeviction&#xD;&#xA;# noeviction -&amp;gt; 不删除任何 key，内存满了直接返回报错&#xD;&#xA;# 默认情况下slave节点会忽略maxmemory配置，除非被提升为master&#xD;&#xA;# 只有master会执行内存淘汰策略，master删除key后会发送DEL指令给slave&#xD;&#xA;maxmemory-policy noeviction&#xD;&#xA;&#xD;&#xA;# 过期key滞留在内存的比例 默认值为1 表示10%&#xD;&#xA;# 设置的越小，一次淘汰周期需要消耗的CPU更多 需要删除更多的过期数据&#xD;&#xA;active-expire-effort 1&#xD;&#xA;&#xD;&#xA;# 持久化&#xD;&#xA;# AOF持久化开启&#xD;&#xA;appendonly yes&#xD;&#xA;&#xD;&#xA;# AOF 持久化模式，默认为 &amp;#34;always&amp;#34;。可以是 always、everysec 或 no&#xD;&#xA;# always：每个写操作都立即同步到磁盘，最费性能&#xD;&#xA;# everysec：每秒钟同步一次到磁盘，折中的选择&#xD;&#xA;# no：完全依赖操作系统的行为，可能会丢失数据，但性能最高&#xD;&#xA;appendfsync everysec&#xD;&#xA;&#xD;&#xA;# AOF-RDB混合持久化&#xD;&#xA;# 配置成yes必须先开启AOF AOF重写生成的文件将同时包含RDB和AOF格式内容&#xD;&#xA;# 推荐开启&#xD;&#xA;aof-use-rdb-preamble yes&#xD;&#xA;&#xD;&#xA;# 性能监控&#xD;&#xA;# 慢查询日志 执行时间只是命令阶段的时间，不包括建立连接发送回复等&#xD;&#xA;# slow log 仅保存在内存中，效率很高&#xD;&#xA;# 执行时间大于多少微秒的查询进行记录 1s = 1,000,000微秒 默认10000&#xD;&#xA;slowlog-log-slower-than 10000&#xD;&#xA;&#xD;&#xA;# 最多保存多少条慢查询日志 slowlog本身是FIFO 默认128&#xD;&#xA;slowlog-max-len 128&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;sentinelconf&#34;&gt;&#xD;&#xA;  sentinel.conf&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#sentinelconf&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo vim /DATA/redis/config/sentinel/sentinel.conf&#xD;&#xA;&#xD;&#xA;# 哨兵端口&#xD;&#xA;port 26379&#xD;&#xA;&#xD;&#xA;# 监控的redis主节点的ip port&#xD;&#xA;# master-name 自定义&#xD;&#xA;# quorum 多少个sentinel主观认为master失联，认为客观上master失联&#xD;&#xA;# sentinel monitor &amp;lt;master-name&amp;gt; &amp;lt;ip&amp;gt; &amp;lt;redis-port&amp;gt; &amp;lt;quorum&amp;gt;&#xD;&#xA;sentinel monitor mymaster 192.168.1.11 63790 2&#xD;&#xA;&#xD;&#xA;# redis实例的密码 主从的访问密码必须要一样&#xD;&#xA;sentinel auth-pass mymaster password&#xD;&#xA;&#xD;&#xA;# 指定多少毫秒之后主节点没有应答哨兵&#xD;&#xA;# 此时哨兵主观上认为主节点下线&#xD;&#xA;# 默认30秒&#xD;&#xA;# sentinel down-after-milliseconds &amp;lt;master-name&amp;gt; &amp;lt;milliseconds&amp;gt;&#xD;&#xA;sentinel down-after-milliseconds mymaster 30000&#xD;&#xA;&#xD;&#xA;# 设置故障转移时，从节点同步新主节点数据的并发数量&#xD;&#xA;# 值越小，对主节点的压力越小，但同步速度可能较慢&#xD;&#xA;# sentinel parallel-syncs &amp;lt;master-name&amp;gt; &amp;lt;numslaves&amp;gt;&#xD;&#xA;sentinel parallel-syncs mymaster 1&#xD;&#xA;&#xD;&#xA;# 设置故障转移的超时时间（单位：毫秒）&#xD;&#xA;# 如果故障转移在这个时间内没有完成，则认为失败&#xD;&#xA;sentinel failover-timeout mymaster 180000&#xD;&#xA;&#xD;&#xA;# 配置哨兵自身的ip 避免走自动检测给出其他哨兵访问不到的地址&#xD;&#xA;sentinel announce-ip 192.168.1.11&#xD;&#xA;sentinel announce-port 36379&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;docker-composeyml&#34;&gt;&#xD;&#xA;  docker-compose.yml&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#docker-composeyml&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo vim /DATA/docker-compose.yml&#xD;&#xA;&#xD;&#xA;version: &amp;#39;3&amp;#39;  # 使用docker-compose版本3&#xD;&#xA;services:  # 定义服务&#xD;&#xA;    redis7:&#xD;&#xA;      image: redis:7.0.4&#xD;&#xA;      container_name: redis7&#xD;&#xA;      user: &amp;#34;996:986&amp;#34;&#xD;&#xA;      restart: always&#xD;&#xA;      ports:&#xD;&#xA;        - 63790:63790&#xD;&#xA;      environment:&#xD;&#xA;        TZ: &amp;#34;Asia/Shanghai&amp;#34;&#xD;&#xA;      volumes:&#xD;&#xA;        - /DATA/redis/config/redis.conf:/etc/redis/redis.conf&#xD;&#xA;        - /DATA/redis/data:/data&#xD;&#xA;      command: [&amp;#34;redis-server&amp;#34;, &amp;#34;/etc/redis/redis.conf&amp;#34;]&#xD;&#xA;    sentinel:&#xD;&#xA;      image: redis:7.0.4&#xD;&#xA;      container_name: sentinel&#xD;&#xA;      restart: always&#xD;&#xA;      ports:&#xD;&#xA;        - 36379:26379&#xD;&#xA;      volumes:&#xD;&#xA;        - /DATA/redis/config/sentinel:/etc/redis/config/sentinel&#xD;&#xA;      environment:&#xD;&#xA;        TZ: &amp;#34;Asia/Shanghai&amp;#34;&#xD;&#xA;      command: [&amp;#34;redis-sentinel&amp;#34;, &amp;#34;/etc/redis/config/sentinel/sentinel.conf&amp;#34;]&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;docker-composeyml语法验证&#34;&gt;&#xD;&#xA;  docker-compose.yml语法验证&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#docker-composeyml%e8%af%ad%e6%b3%95%e9%aa%8c%e8%af%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker-compose config&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;子节点配置&#34;&gt;&#xD;&#xA;  子节点配置&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ad%90%e8%8a%82%e7%82%b9%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;redisconf-1&#34;&gt;&#xD;&#xA;  redis.conf&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#redisconf-1&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo vim /DATA/redis/config/redis.conf&#xD;&#xA;&#xD;&#xA;# 监听端口 sentinel不知道外面映射啥端口，只好把内外端口设置一样&#xD;&#xA;port 63790&#xD;&#xA;# 访问密码&#xD;&#xA;requirepass password&#xD;&#xA;# 数据库数量 使用cluster模式时只会有一个database即DB0&#xD;&#xA;databases 16&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# 绑定本机的网络接口（网卡） 绑定的是网卡的IP地址&#xD;&#xA;# 0.0.0.0 监听所有 默认127.0.0.1&#xD;&#xA;bind 0.0.0.0&#xD;&#xA;&#xD;&#xA;# 默认开启&#xD;&#xA;# 如果没有设置密码和且没有设置bind，只允许本机访问&#xD;&#xA;protected-mode yes&#xD;&#xA;&#xD;&#xA;# 单位秒，timeout时间内客户端没有数据交互，关闭连接&#xD;&#xA;timeout 60&#xD;&#xA;&#xD;&#xA;# 客户端同时连接的最大数量 默认10000&#xD;&#xA;# 达到最大值时关闭新连接并返回max number of clients reached&#xD;&#xA;maxclients 1000&#xD;&#xA;&#xD;&#xA;# 内存管理 &#xD;&#xA;# 最大内存，推荐最大设置为6GB&#xD;&#xA;# 不要设置过大内存，防止执行RDB内存快照文件或者AOF重写时因为数据太大阻塞太长时间&#xD;&#xA;maxmemory 2GB&#xD;&#xA;&#xD;&#xA;# 内存淘汰策略 默认noeviction&#xD;&#xA;# noeviction -&amp;gt; 不删除任何 key，内存满了直接返回报错&#xD;&#xA;# 默认情况下slave节点会忽略maxmemory配置，除非被提升为master&#xD;&#xA;# 只有master会执行内存淘汰策略，master删除key后会发送DEL指令给slave&#xD;&#xA;maxmemory-policy noeviction&#xD;&#xA;&#xD;&#xA;# 过期key滞留在内存的比例 默认值为1 表示10%&#xD;&#xA;# 设置的越小，一次淘汰周期需要消耗的CPU更多 需要删除更多的过期数据&#xD;&#xA;active-expire-effort 1&#xD;&#xA;&#xD;&#xA;# 持久化&#xD;&#xA;# AOF持久化开启&#xD;&#xA;appendonly yes&#xD;&#xA;&#xD;&#xA;# AOF 持久化模式，默认为 &amp;#34;always&amp;#34;。可以是 always、everysec 或 no&#xD;&#xA;# always：每个写操作都立即同步到磁盘，最费性能&#xD;&#xA;# everysec：每秒钟同步一次到磁盘，折中的选择&#xD;&#xA;# no：完全依赖操作系统的行为，可能会丢失数据，但性能最高&#xD;&#xA;appendfsync everysec&#xD;&#xA;&#xD;&#xA;# AOF-RDB混合持久化&#xD;&#xA;# 配置成yes必须先开启AOF AOF重写生成的文件将同时包含RDB和AOF格式内容&#xD;&#xA;# 推荐开启&#xD;&#xA;aof-use-rdb-preamble yes&#xD;&#xA;&#xD;&#xA;# 性能监控&#xD;&#xA;# 慢查询日志 执行时间只是命令阶段的时间，不包括建立连接发送回复等&#xD;&#xA;# slow log 仅保存在内存中，效率很高&#xD;&#xA;# 执行时间大于多少微秒的查询进行记录 1s = 1,000,000微秒 默认10000&#xD;&#xA;slowlog-log-slower-than 10000&#xD;&#xA;&#xD;&#xA;# 最多保存多少条慢查询日志 slowlog本身是FIFO 默认128&#xD;&#xA;slowlog-max-len 128&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# 主从复制&#xD;&#xA;# replicaof &amp;lt;masterip&amp;gt; &amp;lt;masterport&amp;gt;将当前实例成为master的从节点&#xD;&#xA;replicaof 192.168.1.11 63790&#xD;&#xA;&#xD;&#xA;# master节点的requiepass&#xD;&#xA;masterauth bucunzaide82838161&#xD;&#xA;&#xD;&#xA;# 从节点只读，默认为yes，建议保留默认配置&#xD;&#xA;replica-read-only yes&#xD;&#xA;&#xD;&#xA;# slave每10s Ping一次master&#xD;&#xA;repl-ping-replica-period 10&#xD;&#xA;&#xD;&#xA;# slave与master之间的复制超时时间，默认60s&#xD;&#xA;repl-timeout 60&#xD;&#xA;&#xD;&#xA;# slave优先级 哨兵使用 默认100&#xD;&#xA;# master节点挂掉，哨兵选择priority最小的slave节点作为新的master&#xD;&#xA;replica-priority 100&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;sentinelconf-1&#34;&gt;&#xD;&#xA;  sentinel.conf&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#sentinelconf-1&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo scp -P 2222 quanta@192.168.1.11:/DATA/redis/config/sentinel.conf /DATA/redis/config/sentinel.conf&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修改配置sentinel ip&lt;/p&gt;</description>
    </item>
    <item>
      <title>Spring事务</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/spring/transaction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/spring/transaction/</guid>
      <description>&lt;h1 id=&#34;spring事务&#34;&gt;&#xD;&#xA;  Spring事务&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring%e4%ba%8b%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;事务实现&#34;&gt;&#xD;&#xA;  事务实现&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8b%e5%8a%a1%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;基于数据库事务和AOP&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;对于使用了@Transactional注解的Bean，创建代理对象&lt;/li&gt;&#xA;&lt;li&gt;当调用代理对象的方法时，如果方法上有@Transactional注解，利用事务管理器创建一个数据库连接&lt;/li&gt;&#xA;&lt;li&gt;修改数据库连接的autocommit属性为false，禁止此连接自动提交&lt;/li&gt;&#xA;&lt;li&gt;执行当前方法，方法中会包含sql，没有异常就直接提交事务&lt;/li&gt;&#xA;&lt;li&gt;出现异常且需要回滚则回滚事务，不需要回滚就仍然提交事务&lt;/li&gt;&#xA;&lt;li&gt;Spring的事务隔离级别就是数据库的隔离级别&lt;/li&gt;&#xA;&lt;li&gt;Spring事务的传播机制时Spring事务自己实现的，有很多种。用于设置不同场景下，对嵌套方法是否该用同一个事务执行的情况进行支持&lt;/li&gt;&#xA;&lt;li&gt;传播机制是通过数据库连接来实现的，每个数据库连接一个事务，当传播机制配置为应该需要新开一个事务，实际上就是为方法新建一个数据库连接，在新连接上执行SQL。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;默认事务传播机制是：REQUIRED，如果存在事务则加入，不存在则创建&lt;/p&gt;&#xA;&lt;h2 id=&#34;事务传播机制&#34;&gt;&#xD;&#xA;  事务传播机制&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8b%e5%8a%a1%e4%bc%a0%e6%92%ad%e6%9c%ba%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;事务传播机制指的是当事务方法被调用时，事务如何传播&lt;/p&gt;&#xA;&lt;p&gt;传播机制的指定：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    @Transactional(propagation = Propagation.REQUIRED)&#xD;&#xA;    public void calledMethod() {&#xD;&#xA;&#xD;&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;propagation_required默认&#34;&gt;&#xD;&#xA;  PROPAGATION_REQUIRED（默认）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#propagation_required%e9%bb%98%e8%ae%a4&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果调用方法不存在事务，则创建一个事务&lt;br&gt;&#xA;从数据源获取一个新的数据库连接并开启新事务&lt;/li&gt;&#xA;&lt;li&gt;如果调用方法有事务，则加入该事务&lt;br&gt;&#xA;也就是不做处理，复用当前的数据库连接和事务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;效果：存在且仅存在一个事务，回滚到最开始事务创建时&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;调用方有事务，和调用方一起作为原子操作&lt;/li&gt;&#xA;&lt;li&gt;调用方没有事务，自己是原子操作&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;propagation_supports&#34;&gt;&#xD;&#xA;  PROPAGATION_SUPPORTS&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#propagation_supports&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果调用方法不存在事务，以非事务方式运行&lt;br&gt;&#xA;获取数据源连接执行SQL，但不开启事务&lt;/li&gt;&#xA;&lt;li&gt;如果调用方法有事务，则加入该事务&lt;br&gt;&#xA;复用当前的数据库连接和事务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;效果：遵从被调用方的决定，有就用，没有也不开&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;调用方有事务，和调用方一起作为原子操作&lt;/li&gt;&#xA;&lt;li&gt;调用方没有事务，都不是原子操作&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;propagation_mandatory&#34;&gt;&#xD;&#xA;  PROPAGATION_MANDATORY&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#propagation_mandatory&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果调用方法不存在事务，抛出异常&lt;br&gt;&#xA;发现当前没有事务，抛出 IllegalTransactionStateException 异常 即要求必须在事务环境下执行&lt;/li&gt;&#xA;&lt;li&gt;如果调用方法有事务，则加入该事务&lt;br&gt;&#xA;复用当前的数据库连接和事务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;效果：必须有事务才能调用该方法&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;调用方有事务，和调用方一起作为原子操作&lt;/li&gt;&#xA;&lt;li&gt;调用方没有事务，报错&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;propagation_requires_new&#34;&gt;&#xD;&#xA;  PROPAGATION_REQUIRES_NEW&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#propagation_requires_new&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果调用方法不存在事务，则创建一个新事务 &lt;br&gt;&#xA;从数据源获取一个新的数据库连接并开启新事务&lt;/li&gt;&#xA;&lt;li&gt;如果调用方法有事务，挂起当前事务，并创建新事务执行&lt;br&gt;&#xA;挂起调用者事务，获取新的链接并开启新事务，执行完毕后，回复调用者的事务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;效果：不管调用方有无事务，自己都是单独事务执行&#xA;调用方和自己是两个原子，报错不影响调用方，也不被调用方影响&lt;/p&gt;</description>
    </item>
    <item>
      <title>ElasticSearch</title>
      <link>https://constructor-md.github.io/codestack/docs/deploy/elasticsearch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/deploy/elasticsearch/</guid>
      <description>&lt;h1 id=&#34;elasticsearch&#34;&gt;&#xD;&#xA;  ElasticSearch&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#elasticsearch&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;安装版本：8.15.0&lt;/p&gt;&#xA;&lt;p&gt;部署方式：三节点&lt;/p&gt;&#xA;&lt;p&gt;运行方式：docker-compose&lt;/p&gt;&#xA;&lt;h2 id=&#34;linux系统设置&#34;&gt;&#xD;&#xA;  Linux系统设置&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#linux%e7%b3%bb%e7%bb%9f%e8%ae%be%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 修改内核参数&#xD;&#xA;# 设置每个进程最多拥有的最大内存映射区域数量 默认65536对ES来说不足&#xD;&#xA;echo &amp;#34;vm.max_map_count=262144&amp;#34; | sudo tee -a /etc/sysctl.conf&#xD;&#xA;sudo sysctl -p&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;创建目录&#34;&gt;&#xD;&#xA;  创建目录&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9b%e5%bb%ba%e7%9b%ae%e5%bd%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo mkdir /DATA/es /DATA/es/data /DATA/es/logs /DATA/es/plugins /DATA/es/config&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;权限设置&#34;&gt;&#xD;&#xA;  权限设置&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9d%83%e9%99%90%e8%ae%be%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo chmod -R 777 /DATA/es/data /DATA/es/logs /DATA/es/plugins /DATA/es/config&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;各单节点启动获取官方配置&#34;&gt;&#xD;&#xA;  各单节点启动获取官方配置&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%90%84%e5%8d%95%e8%8a%82%e7%82%b9%e5%90%af%e5%8a%a8%e8%8e%b7%e5%8f%96%e5%ae%98%e6%96%b9%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo vim /DATA/docker-compose.yml&#xD;&#xA;&#xD;&#xA;version: &amp;#39;3&amp;#39;&#xD;&#xA;services:&#xD;&#xA;  es:&#xD;&#xA;      image: docker.elastic.co/elasticsearch/elasticsearch:8.15.0&#xD;&#xA;      container_name: es&#xD;&#xA;      restart: always&#xD;&#xA;      environment:&#xD;&#xA;        - &amp;#34;ES_JAVA_OPTS=-Xms4g -Xmx4g&amp;#34; # 宿主机最大内存的一半 再留点给其他应用&#xD;&#xA;        - &amp;#34;ELASTIC_PASSWORD=bucunzaide2333&amp;#34;&#xD;&#xA;        - &amp;#34;TZ=Asia/Shanghai&amp;#34;&#xD;&#xA;      ports:&#xD;&#xA;        - &amp;#34;19200:19200&amp;#34;&#xD;&#xA;        - &amp;#34;19300:19300&amp;#34;&#xD;&#xA;      volumes:&#xD;&#xA;        - /DATA/es/data:/usr/share/elasticsearch/data&#xD;&#xA;        - /DATA/es/logs:/usr/share/elasticsearch/logs&#xD;&#xA;        - /etc/hosts:/etc/hosts&#xD;&#xA;        - es_config:/usr/share/elasticsearch/config&#xD;&#xA;        - /DATA/es/plugins:/usr/share/elasticsearch/plugins&#xD;&#xA;      ulimits:&#xD;&#xA;        # mmap 映射内存不限制&#xD;&#xA;        memlock:&#xD;&#xA;          soft: -1                  &#xD;&#xA;          hard: -1&#xD;&#xA;        # 文件描述符打开个数修改    &#xD;&#xA;        nofile:                                          &#xD;&#xA;          soft: 65535                             &#xD;&#xA;          hard: 65535&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# 末尾添加 作用是不要让宿主机空目录覆盖&#xD;&#xA;volumes:&#xD;&#xA;      es_config:&#xD;&#xA;        driver: local&#xD;&#xA;        driver_opts:&#xD;&#xA;          type: none&#xD;&#xA;          device: /DATA/es/config&#xD;&#xA;          o: bind&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;#mmap 映射内存不限制&lt;/p&gt;</description>
    </item>
    <item>
      <title>SQL执行过程</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/mysql/sql-execution/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/mysql/sql-execution/</guid>
      <description>&lt;h1 id=&#34;sql执行过程&#34;&gt;&#xD;&#xA;  SQL执行过程&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#sql%e6%89%a7%e8%a1%8c%e8%bf%87%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;查询sql执行顺序&#34;&gt;&#xD;&#xA;  查询SQL执行顺序&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9f%a5%e8%af%a2sql%e6%89%a7%e8%a1%8c%e9%a1%ba%e5%ba%8f&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;以如下SQL为例：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;select distinct table1.id as card_id &#xD;&#xA;from table1&#xD;&#xA;join table2 on table1.id = table2.id&#xD;&#xA;where table1.id &amp;lt; 2&#xD;&#xA;group by card_id&#xD;&#xA;having max(card_id) &amp;gt; 10&#xD;&#xA;order by card_id desc&#xD;&#xA;limit 1, 1;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行顺序如下&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;FROM，查询语句的开始，每个步骤为下一个步骤生成一个虚拟表，作为下一个步骤的输入&#xA;&lt;ol&gt;&#xA;&lt;li&gt;如果是表，直接操作表&lt;/li&gt;&#xA;&lt;li&gt;如果是子查询，先执行子查询&lt;/li&gt;&#xA;&lt;li&gt;如果要关联表，执行下述JOIN、ON&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;JOIN 关联表，生成笛卡尔乘积虚拟表&lt;/li&gt;&#xA;&lt;li&gt;ON，对JOIN出来的虚拟表进行按条件筛选，并生成一个新虚拟表&lt;/li&gt;&#xA;&lt;li&gt;WHERE，对虚拟表进行按条件筛选，生成一张新虚拟表&lt;/li&gt;&#xA;&lt;li&gt;GROUP BY，将按指定列的值分组，得到新的虚拟表。后续的所有步骤都只能操作被分组的列。&lt;/li&gt;&#xA;&lt;li&gt;AVG,SUM,MAX…，聚合函数 对分组的结果进行计算，不生成虚拟表&lt;/li&gt;&#xA;&lt;li&gt;HAVING，按条件筛选，主要和GROUP BY配合使用。且是唯一一个应用到已分组数据的筛选器。生成新虚拟表&lt;/li&gt;&#xA;&lt;li&gt;SELECT，选择指定列，生成新虚拟表&lt;/li&gt;&#xA;&lt;li&gt;DISTINCT，去重，对上出结果进行去重，移除相同的行。产生新虚拟表。使用GROUP BY后，DISTINCT多余。&lt;/li&gt;&#xA;&lt;li&gt;ORDER BY，按照对指定列升序或降序。返回游标，而不是虚拟表。&lt;/li&gt;&#xA;&lt;li&gt;LIMIT，取出指定行的记录，产生虚拟表并返回结果。Limit m,n表示从第m到第n数据。&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>MinIO</title>
      <link>https://constructor-md.github.io/codestack/docs/deploy/minio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/deploy/minio/</guid>
      <description>&lt;h1 id=&#34;minio&#34;&gt;&#xD;&#xA;  MinIO&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#minio&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;部署方式：单节点&lt;/p&gt;&#xA;&lt;p&gt;运行方式：docker-compose&lt;/p&gt;&#xA;&lt;h2 id=&#34;目录创建&#34;&gt;&#xD;&#xA;  目录创建&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%9b%ae%e5%bd%95%e5%88%9b%e5%bb%ba&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo mkdir /DATA/minio /DATA/minio/data /DATA/minio/config&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;docker-composeyml&#34;&gt;&#xD;&#xA;  docker-compose.yml&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#docker-composeyml&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo vim /DATA/docker-compose.yml&#xD;&#xA;&#xD;&#xA;services:&#xD;&#xA;  minio:&#xD;&#xA;    image: minio/minio&#xD;&#xA;    restart: always&#xD;&#xA;    mem_limit: 1G&#xD;&#xA;    ports:&#xD;&#xA;      - &amp;#34;9000:9000&amp;#34;&#xD;&#xA;      - &amp;#34;19001:9001&amp;#34;&#xD;&#xA;    container_name: minio&#xD;&#xA;    command: server /data --console-address &amp;#34;:9001&amp;#34;&#xD;&#xA;    environment:&#xD;&#xA;      - MINIO_ROOT_USER=admin&#xD;&#xA;      - MINIO_ROOT_PASSWORD=_admin123&#xD;&#xA;      - MINIO_BROWSER_DEFAULT_LOCALE=zh_CN&#xD;&#xA;    volumes:&#xD;&#xA;      - /DATA/minio/data:/data&#xD;&#xA;      - /DATA/minio/config:/root/.minio&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;9000 是MInIO S3 API端口&#xA;9001 是MinIO WebUI 控制台端口&#xA;需要的节点才映射出来即可&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;启动&#34;&gt;&#xD;&#xA;  启动&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%90%af%e5%8a%a8&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo docker-compose up -d minio&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;防火墙打开&#34;&gt;&#xD;&#xA;  防火墙打开&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%98%b2%e7%81%ab%e5%a2%99%e6%89%93%e5%bc%80&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo ufw allow 19001/tcp&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>日志文件及作用</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/mysql/logfile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/mysql/logfile/</guid>
      <description>&lt;h1 id=&#34;日志文件及作用&#34;&gt;&#xD;&#xA;  日志文件及作用&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%97%a5%e5%bf%97%e6%96%87%e4%bb%b6%e5%8f%8a%e4%bd%9c%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;errorlog-错误日志&#34;&gt;&#xD;&#xA;  error.log 错误日志：&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#errorlog-%e9%94%99%e8%af%af%e6%97%a5%e5%bf%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt;对MySQL的启动、运行、关闭过程进行了记录&#xD;&#xA;用于问题的排查，如例如权限问题、配置错误、磁盘空间不足&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;slowlog-慢查询日志&#34;&gt;&#xD;&#xA;  slow.log 慢查询日志：&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#slowlog-%e6%85%a2%e6%9f%a5%e8%af%a2%e6%97%a5%e5%bf%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt;可通过slow_query_log_file参数在配置文件中指定文件名，若未指定，默认在数据目录下，文件名为hostname-slow.log&#xD;&#xA;默认情况下不启动慢查询日志，需要手动设置&#xD;&#xA;用于定位执行时间超过设置值的SQL，以及没有使用索引的SQL&#xD;&#xA;可以通过mysqldupmslow查找和筛选慢查询日志的内容&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;查询日志&#34;&gt;&#xD;&#xA;  查询日志：&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9f%a5%e8%af%a2%e6%97%a5%e5%bf%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt;其文件名可通过general_log_file参数在配置文件中指定，若未指定，默认在数据目录下，文件名为hostname.log&#xD;&#xA;记录了所有对MySQL数据库请求的信息，不论是否得到了正确执行&#xD;&#xA;但由于会记录所有语句，开启该日志会对性能产生较大影响，所以通常只在调试或测试环境中开启&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;二进制日志binlog&#34;&gt;&#xD;&#xA;  二进制日志bin.log&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%97%a5%e5%bf%97binlog&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt;二进制日志由一系列文件组成，文件名格式为binlog.xxxxxx ，其中xxxxxx是一个 6 位的数字序号，从 000001 开始递增。其文件名前缀可通过log_bin参数在配置文件中指定&#xD;&#xA;记录了所有对MySQL数据库进行的更改&#xD;&#xA;作用：&#xD;&#xA;    数据恢复，数据库全备文件恢复&#xD;&#xA;    主从复制，通过复制和执行二进制日志，使从库和主库实时同步&#xD;&#xA;    审计判断是否有对数据库攻击&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;中继日志relay-log&#34;&gt;&#xD;&#xA;  中继日志（Relay Log）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ad%e7%bb%a7%e6%97%a5%e5%bf%97relay-log&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt;文件名格式为relay-log.xxxxxx ，其中xxxxxx是一个 6 位的数字序号，从 000001 开始递增。文件名前缀可通过relay_log参数在配置文件中指定。&#xD;&#xA;作用：&#xD;&#xA;    在主从复制架构中，从服务器从主服务器接收二进制日志内容后，会将其存储在中继日志中&#xD;&#xA;    从服务器的 SQL 线程会读取中继日志中的内容，并在本地执行相应的 SQL 语句，从而实现数据的同步&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;事务日志innodb&#34;&gt;&#xD;&#xA;  事务日志（Innodb）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8b%e5%8a%a1%e6%97%a5%e5%bf%97innodb&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;redo-log-重做日志&#34;&gt;&#xD;&#xA;  Redo log 重做日志:&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#redo-log-%e9%87%8d%e5%81%9a%e6%97%a5%e5%bf%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt;默认文件名为ib_logfile0、ib_logfile1等，可通过innodb_log_files_in_group参数指定日志文件的数量，通过innodb_log_file_size参数指定每个日志文件的大小。&#xD;&#xA;用于保证事务的持久性&#xD;&#xA;MySQL中有大量缓存，数据修改时首先更新缓存，但是缓存并非马上同步到磁盘，即为脏页&#xD;&#xA;但是数据库如果宕机，则内存数据丢失，重启无法恢复&#xD;&#xA;所以每次修改内存就要写redo log，redo log顺序写入，磁盘的顺序读写速度远快于随机读写，写操作对性能影响较小&#xD;&#xA;Redo log是物理日志，记录数据页的物理修改，用于恢复提交后的物理数据页&#xD;&#xA;如果数据库意外重启，会根据redo log进行数据恢复&#xD;&#xA;如果redo log有事务提交，则提交事务修改数据。也仅能恢复到数据最后提交的状态&#xD;&#xA;可以利用 Redo Log 将未写入磁盘的数据页恢复到崩溃前的状态&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;undo-log-回滚日志&#34;&gt;&#xD;&#xA;  Undo log 回滚日志:&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#undo-log-%e5%9b%9e%e6%bb%9a%e6%97%a5%e5%bf%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt;InnoDB Undo Log 没有单独的文件名，它是存储在系统表空间（ibdata1）或独立的 undo 表空间中的。可通过innodb_undo_tablespaces参数指定独立 undo 表空间的数量&#xD;&#xA;undo log是逻辑日志，每次修改数据，undolog中出现一条反操作的记录&#xD;&#xA;可以用于事务回滚，也可以根据undolog回溯到某个特定版本的数据&#xD;&#xA;用于实现事务的原子性和多版本并发控制（MVCC）&#xD;&#xA;在事务执行过程中，Undo Log 会记录数据修改前的状态，当事务需要回滚时，可以根据 Undo Log 将数据恢复到事务开始前的状态&#xD;&#xA;同时，MVCC 通过 Undo Log 提供数据的多个版本，使得不同事务可以同时访问同一数据的不同版本，提高并发性能&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Explain参数解释和查询成本分析</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/mysql/explain/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/mysql/explain/</guid>
      <description>&lt;h1 id=&#34;explain参数解释和查询成本分析&#34;&gt;&#xD;&#xA;  Explain参数解释和查询成本分析&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#explain%e5%8f%82%e6%95%b0%e8%a7%a3%e9%87%8a%e5%92%8c%e6%9f%a5%e8%af%a2%e6%88%90%e6%9c%ac%e5%88%86%e6%9e%90&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;explain&#34;&gt;&#xD;&#xA;  Explain&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#explain&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;通过执行 explain [sql] 得到执行计划&lt;/p&gt;&#xA;&lt;p&gt;如果from中包含子查询，会查并生成临时表&lt;/p&gt;&#xA;&lt;p&gt;explain执行完之后执行show warnings，有时候可以直接拷贝出来直接使用，大多时候可以用于参考执行&lt;/p&gt;&#xA;&lt;h3 id=&#34;结果列分析&#34;&gt;&#xD;&#xA;  结果列分析&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%93%e6%9e%9c%e5%88%97%e5%88%86%e6%9e%90&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;h4 id=&#34;id&#34;&gt;&#xD;&#xA;  id&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#id&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;有几个select就有几个id，id按select出现的顺序增长，id大的先执行，null最后执行，相同则从上往下执行&lt;/p&gt;&#xA;&lt;h4 id=&#34;select_type&#34;&gt;&#xD;&#xA;  select_type&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#select_type&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;simple 简单查询，没有子查询和union&lt;/li&gt;&#xA;&lt;li&gt;primary 复杂查询中最外层迭代select&lt;/li&gt;&#xA;&lt;li&gt;subquery 包含在select中的子查询，不在from中&lt;/li&gt;&#xA;&lt;li&gt;dependent subquery select语句出现的子查询，依赖外部查询&lt;/li&gt;&#xA;&lt;li&gt;derived 包含在from子句的子查询，会把结果放在临时表（派生表）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;table&#34;&gt;&#xD;&#xA;  table&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#table&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;这一行的查询在访问哪个表&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;from子句有子查询时，table列是&lt;!-- raw HTML omitted --&gt;格式，表示当前查询依赖id=N的查询，会先执行id=N的查询&lt;/li&gt;&#xA;&lt;li&gt;有union时，union result的table列的值为union 1,2，1和2表示参与union的select的id&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;type&#34;&gt;&#xD;&#xA;  type&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#type&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;表示关联类型或访问类型，表示mysql决定如何查找表中的行，查找数据行记录的大概范围, 从最优到最差依次为：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;system &amp;gt; const &amp;gt; eq_ref &amp;gt; ref &amp;gt; range &amp;gt; index &amp;gt; ALL&#xA;一般来说应该最少把查询保持在range级别，最好达到ref&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;system MyIsm出现，表为空或者记录唯一时&lt;/li&gt;&#xA;&lt;li&gt;const 主键索引或唯一索引的等值查询&lt;/li&gt;&#xA;&lt;li&gt;eq_ref join的时候有驱动表和被驱动表，被驱动表走唯一或者主键索引时&lt;/li&gt;&#xA;&lt;li&gt;ref 非主键或非唯一索引的等值查询，关联查询时被驱动表的驱动键走非唯一索引&lt;/li&gt;&#xA;&lt;li&gt;range 一般索引的范围查询&lt;/li&gt;&#xA;&lt;li&gt;index 全表扫描，非聚簇索引的叶子节点&lt;/li&gt;&#xA;&lt;li&gt;All 聚簇索引的全表扫描&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;possible-keys列&#34;&gt;&#xD;&#xA;  possible keys列&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#possible-keys%e5%88%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;显示查询可能使用哪些索引来查找&lt;/p&gt;</description>
    </item>
    <item>
      <title>索引树高度计算</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/mysql/tree-high/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/mysql/tree-high/</guid>
      <description>&lt;h1 id=&#34;索引树高度计算&#34;&gt;&#xD;&#xA;  索引树高度计算&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b4%a2%e5%bc%95%e6%a0%91%e9%ab%98%e5%ba%a6%e8%ae%a1%e7%ae%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;基本原理&#34;&gt;&#xD;&#xA;  基本原理&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;Innodb是索引组织表，每个页都包含一个PAGE_LEVEL，表示当前页在索引上的高度&lt;/p&gt;&#xA;&lt;p&gt;默认叶子节点高度为0，ROOT节点PAGE_LEVEL+1就是这棵索引高度&lt;/p&gt;&#xA;&lt;p&gt;PAGE_LEVEL在每个页的64位偏移位置，占用2字节&lt;/p&gt;&#xA;&lt;p&gt;找到ROOT页位置，知道单页大小，使用hexdump在指定表空间找到第PAGE_NO页的64位偏移量的后两个字节即可&lt;/p&gt;&#xA;&lt;h2 id=&#34;找到root页信息&#34;&gt;&#xD;&#xA;  找到ROOT页信息&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%89%be%e5%88%b0root%e9%a1%b5%e4%bf%a1%e6%81%af&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;SELECT b.name, a.name, index_id, type, a.space, a.PAGE_NO&#xD;&#xA;FROM information_schema.INNODB_SYS_INDEXES a,&#xD;&#xA;information_schema.INNODB_SYS_TABLES b&#xD;&#xA;WHERE a.table_id = b.table_id AND a.space &amp;lt;&amp;gt; 0;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结果：&#xA;&lt;img src=&#34;./images/root-info.png&#34; alt=&#34;&amp;ldquo;root页信息&amp;rdquo;&#34; title=&#34;root页信息&#34;/&gt;&#xA;其中（space、PAGE_NO）指向ROOT页&lt;/p&gt;&#xA;&lt;p&gt;space是表空间，可以是系统表空间（如ibdata1文件）或独立表空间（如每个InnoDB表的.ibd文件）。表空间由多个区（extent）组成，每个区包含连续的页（page）&lt;/p&gt;&#xA;&lt;p&gt;也就是ROOT页是space的page_no页&lt;/p&gt;&#xA;&lt;h2 id=&#34;查看innodb_page_size&#34;&gt;&#xD;&#xA;  查看innodb_page_size&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9f%a5%e7%9c%8binnodb_page_size&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;show variables like &amp;#39;innodb_page_size&amp;#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结果：&#xA;&lt;img src=&#34;./images/innodb_page_size.png&#34; alt=&#34;&amp;ldquo;innodb_page_size&amp;rdquo;&#34; title=&#34;innodb_page_size&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;也就是Innodb默认的页大小16KB&lt;/p&gt;&#xA;&lt;h2 id=&#34;找到root的page_level得到索引高度&#34;&gt;&#xD;&#xA;  找到ROOT的PAGE_LEVEL，得到索引高度&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%89%be%e5%88%b0root%e7%9a%84page_level%e5%be%97%e5%88%b0%e7%b4%a2%e5%bc%95%e9%ab%98%e5%ba%a6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;首先要找到表对应的ibd文件，也就是表空间文件&lt;/p&gt;&#xA;&lt;p&gt;所在位置是MySQL的数据目录下的数据库名文件夹下&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#查找MySQL数据目录&#xD;&#xA;show variables like &amp;#39;datadir&amp;#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;./images/dir.png&#34; alt=&#34;&amp;ldquo;dir&amp;rdquo;&#34; title=&#34;dir&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;我的MySQL是用Docker起的，docker中没有安装hexdump命令，不过这个目录被挂载出来了，考虑在宿主机上分析其中的ibd文件&lt;/p&gt;&#xA;&lt;p&gt;但所在文件夹和文件权限限制了宿主机外用户访问文件夹和文件&#xA;&lt;img src=&#34;./images/docker-dir.png&#34; alt=&#34;&amp;ldquo;docker-dir&amp;rdquo;&#34; title=&#34;docker-dir&#34;/&gt;&#xA;修改权限需要到docker容器中修改该文件和对应文件夹权限&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;chmod 755 path&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;原本权限为750，禁止其他用户读写文件夹&lt;/p&gt;&#xA;&lt;p&gt;修改后在宿主机进入文件夹中，找到所需文件，在文件夹执行命令&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;hexdump -C -s 49216 -n 10 goods_info_100M.ibd&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;./images/page-info.png&#34; alt=&#34;&amp;ldquo;page-info&amp;rdquo;&#34; title=&#34;page-info&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;前两个字节是PAGE_LEVEL，所以这个索引树高度为3+1 = 4&lt;/p&gt;</description>
    </item>
    <item>
      <title>HTTP</title>
      <link>https://constructor-md.github.io/codestack/docs/basic/net/application/http/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/basic/net/application/http/</guid>
      <description>&lt;h1 id=&#34;http&#34;&gt;&#xD;&#xA;  HTTP&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#http&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;HTTP是应用层的，基于TCP的超文本传输协议&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;无状态：协议自身不对请求和响应之间的通信状态进行保存，任何两次请求之间没有依赖关系&lt;/li&gt;&#xA;&lt;li&gt;无连接：每次连接只处理一个请求&#xA;使用80作为默认端口&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;报文结构&#34;&gt;&#xD;&#xA;  报文结构&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8a%a5%e6%96%87%e7%bb%93%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;请求报文&#34;&gt;&#xD;&#xA;  请求报文&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%b7%e6%b1%82%e6%8a%a5%e6%96%87&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;&lt;img src=&#34;./images/request.png&#34; alt=&#34;请求报文&#34; title=&#34;请求报文&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;请求报文总体四个部分&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;请求行&#xA;包括请求方法、URL、协议版本，彼此使用空格分隔&lt;/li&gt;&#xA;&lt;li&gt;请求头&#xA;KV形式的辅助信息&lt;/li&gt;&#xA;&lt;li&gt;空行&#xA;分隔报头(请求行+请求头)和请求体，由回车符和换行符组成&lt;/li&gt;&#xA;&lt;li&gt;请求体&#xA;请求发送时携带的数据&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;请求行&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;方法&lt;/th&gt;&#xA;          &lt;th&gt;说明&lt;/th&gt;&#xA;          &lt;th&gt;支持的HTTP协议版本&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GET&lt;/td&gt;&#xA;          &lt;td&gt;获取资源&lt;/td&gt;&#xA;          &lt;td&gt;1.0，1.1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;POST&lt;/td&gt;&#xA;          &lt;td&gt;传输实体主体(提交信息)&lt;/td&gt;&#xA;          &lt;td&gt;1.0，1.1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;PUT&lt;/td&gt;&#xA;          &lt;td&gt;传输文件&lt;/td&gt;&#xA;          &lt;td&gt;1.0，1.1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;HEAD&lt;/td&gt;&#xA;          &lt;td&gt;获得报文首部&lt;/td&gt;&#xA;          &lt;td&gt;1.0，1.1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;DELETE&lt;/td&gt;&#xA;          &lt;td&gt;删除文件&lt;/td&gt;&#xA;          &lt;td&gt;1.0，1.1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;OPTIONS&lt;/td&gt;&#xA;          &lt;td&gt;询问支持的方法&lt;/td&gt;&#xA;          &lt;td&gt;1.1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;TRACE&lt;/td&gt;&#xA;          &lt;td&gt;追踪路径&lt;/td&gt;&#xA;          &lt;td&gt;1.1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CONNECT&lt;/td&gt;&#xA;          &lt;td&gt;要求用隧道协议连接代理&lt;/td&gt;&#xA;          &lt;td&gt;1.1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;LINK&lt;/td&gt;&#xA;          &lt;td&gt;建立和资源之间的联系&lt;/td&gt;&#xA;          &lt;td&gt;1.0&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;UNLINE&lt;/td&gt;&#xA;          &lt;td&gt;断开连接关系&lt;/td&gt;&#xA;          &lt;td&gt;1.0&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;请求头&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;请求头&lt;/th&gt;&#xA;          &lt;th&gt;含义&lt;/th&gt;&#xA;          &lt;th&gt;示例&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Cache-Control&lt;/td&gt;&#xA;          &lt;td&gt;用于控制缓存策略，设置缓存的行为，如是否允许缓存、缓存时间、缓存验证方式等&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;Cache-Control: max-age=3600&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Connection&lt;/td&gt;&#xA;          &lt;td&gt;指示客户端和服务器之间的连接选项，常见值有 &lt;code&gt;keep-alive&lt;/code&gt; 和 &lt;code&gt;close&lt;/code&gt;，分别表示保持连接和关闭连接&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;Connection: keep-alive&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Date&lt;/td&gt;&#xA;          &lt;td&gt;表示请求发送的日期和时间，采用 HTTP 日期格式，服务器可据此进行时间相关处理&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;Date: Wed, 18 Apr 2025 12:00:00 GMT&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Accept&lt;/td&gt;&#xA;          &lt;td&gt;告知服务器客户端能够接受的响应内容类型，服务器会根据此选择合适的内容格式返回&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Accept-Encoding&lt;/td&gt;&#xA;          &lt;td&gt;指定客户端能够接受的编码方式，如 &lt;code&gt;gzip&lt;/code&gt;、&lt;code&gt;deflate&lt;/code&gt; 等，服务器会对响应数据进行相应的编码压缩&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;Accept-Encoding: gzip, deflate&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Accept-Language&lt;/td&gt;&#xA;          &lt;td&gt;表示客户端偏好的语言，服务器可根据此返回对应语言的内容&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Host&lt;/td&gt;&#xA;          &lt;td&gt;指定请求的目标主机和端口号，用于区分同一服务器上的不同虚拟主机或服务&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;Host: www.example.com:8080&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Referer&lt;/td&gt;&#xA;          &lt;td&gt;标识请求发起的来源页面的 URL，服务器可以借此了解请求的上下文和来源路径&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;Referer: https://www.example.com/page1.html&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;User-Agent&lt;/td&gt;&#xA;          &lt;td&gt;包含客户端的相关信息，如浏览器类型、版本、操作系统等，服务器可根据此进行不同的适配和处理&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.5615.137 Safari/537.36&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Content-Type&lt;/td&gt;&#xA;          &lt;td&gt;用于 POST、PUT 等请求，指示请求体中数据的类型，如 &lt;code&gt;application/json&lt;/code&gt;、&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;、&lt;code&gt;multipart/form-data&lt;/code&gt; 等&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;Content-Type: application/json&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Content-Length&lt;/td&gt;&#xA;          &lt;td&gt;表示请求体的长度，以字节为单位，服务器可据此判断是否完整接收了请求数据&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;Content-Length: 1024&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;响应报文&#34;&gt;&#xD;&#xA;  响应报文&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%93%8d%e5%ba%94%e6%8a%a5%e6%96%87&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;&lt;img src=&#34;./images/response.png&#34; alt=&#34;响应报文&#34; title=&#34;响应报文&#34;/&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>TCP</title>
      <link>https://constructor-md.github.io/codestack/docs/basic/net/transport/tcp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/basic/net/transport/tcp/</guid>
      <description>&lt;h1 id=&#34;tcp&#34;&gt;&#xD;&#xA;  TCP&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#tcp&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议&lt;/p&gt;&#xA;&lt;h2 id=&#34;报文结构&#34;&gt;&#xD;&#xA;  报文结构&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8a%a5%e6%96%87%e7%bb%93%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;&lt;img src=&#34;./images/message.png&#34; alt=&#34;报文结构&#34; title=&#34;报文结构&#34;/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;源端口：发送方使用的端口号，16位&lt;/li&gt;&#xA;&lt;li&gt;目的端口：接收方使用的端口号，16位&lt;/li&gt;&#xA;&lt;li&gt;序号：本报文段发送数据的第一个字节的编号，32位&lt;/li&gt;&#xA;&lt;li&gt;确认号：接收方期望接收到的下一个报文段的第一个字节的编号&lt;/li&gt;&#xA;&lt;li&gt;数据偏移(首部长度)：指数据段中的数据部分的起始处距离TCP报文段起始处的偏移量，也就是TCP报文的报头部分的长度，接收端根据这个知道数据（有效载荷）从何处开始 4位&lt;/li&gt;&#xA;&lt;li&gt;保留字段：TCP协议将来的发展预留的空间，目前必须全部为0，6位&lt;/li&gt;&#xA;&lt;li&gt;标志位字段：共六个标志位，每个1bit&lt;/li&gt;&#xA;&lt;li&gt;窗口大小：表示发送该TCP报文的接收窗口还可以接受多少字节的数据量，用于TCP的流量控制，16位&lt;/li&gt;&#xA;&lt;li&gt;校验和：用于确认传输的数据有无损坏。发送端基于数据内容校验生成一个数值，接收端同样生成一个数值进行对比，相同的数据有效，反之无效则丢弃数据包，16位&lt;/li&gt;&#xA;&lt;li&gt;紧急指针：仅当标志位的URG字段值位1才有意义。指出有效载荷中位紧急数据的字节数。当所有紧急数据处理完，TCP告知应用程序恢复到正常操作。即使接收方窗口大小为0，也可以发送紧急数据，因为紧急数据无需缓存，16位&lt;/li&gt;&#xA;&lt;li&gt;选项字段：长度不定，但是必须是32bit的整数倍，即4字节的整数倍。内容可变，所以使用首部长度来区分选项部分的具体长度&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;如何分离首部和载荷确认首部长度&#34;&gt;&#xD;&#xA;  如何分离首部和载荷（确认首部长度）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a6%82%e4%bd%95%e5%88%86%e7%a6%bb%e9%a6%96%e9%83%a8%e5%92%8c%e8%bd%bd%e8%8d%b7%e7%a1%ae%e8%ae%a4%e9%a6%96%e9%83%a8%e9%95%bf%e5%ba%a6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;TCP固定首部长度20字节，以及选项字段&#xA;首部长度字段为4bits，最大可表示长度为1111，即15。表示单位是4字节&#xA;所以TCP首部最长是15*4 = 60字节&#xA;固定首部为20字节，选项部分为4字节的倍数，最大为40字节&#xA;这说明了数据偏移字段标识首部长度的原理&#xA;根据首部长度，可以分离首部和载荷&lt;/p&gt;&#xA;&lt;h2 id=&#34;连接的建立和断开&#34;&gt;&#xD;&#xA;  连接的建立和断开&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%9e%e6%8e%a5%e7%9a%84%e5%bb%ba%e7%ab%8b%e5%92%8c%e6%96%ad%e5%bc%80&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;TCP连接是TCP协议在网络中建立的可靠通信链路&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;这种可靠指的是不丢包，就是网络不太好的情况下可以尽量保证数据的完整接收（发送确认和重发）&lt;/p&gt;&#xA;&lt;p&gt;由IP协议锚定双方地址，由底层协议传输数据包，由高层协议进行数据的加解密&lt;/p&gt;&#xA;&lt;p&gt;换言之，TCP的可靠通信链路中保证的是传输和接收数据包的完整性，而不是包揽了链路的实际构建、数据包防伪等过程。不要把可靠性的理解在TCP扩展太多&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;为什么要建立连接&#34;&gt;&#xD;&#xA;  为什么要建立连接&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%bb%ba%e7%ab%8b%e8%bf%9e%e6%8e%a5&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;可靠性验证：建立连接的过程实际就是通信双方验证各自的发送和接受能力是否正常，双方的信道是否通畅&lt;/li&gt;&#xA;&lt;li&gt;协商参数：如序号初始值，MSS，是否启用SACK等&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;连接的建立---三次握手&#34;&gt;&#xD;&#xA;  连接的建立 - 三次握手&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%9e%e6%8e%a5%e7%9a%84%e5%bb%ba%e7%ab%8b---%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;服务器初始化状态&#xA;服务器端进程函数顺序：socket =&amp;gt; bind =&amp;gt; listen =&amp;gt; accept&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;socket()创建套接字listenfd&lt;/li&gt;&#xA;&lt;li&gt;bind()将套接字和端口绑定&lt;/li&gt;&#xA;&lt;li&gt;listen()让listenfd成为监听套接字，后续连接通过监听套接字获取，服务器处于监听状态&lt;/li&gt;&#xA;&lt;li&gt;accept()进程阻塞，直到有客户连接请求到达才返回&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;客户端发起连接请求 - 第一次握手&#xA;客户端进程函数顺序:socket =&amp;gt; connect&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;socket()创建套接字&lt;/li&gt;&#xA;&lt;li&gt;connect()调用时操作系统自动bind()，然后客户端进程就会向服务端进行发送连接请求报文&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;连接请求报文首部的标志位SYN=1&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
