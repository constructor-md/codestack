<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CodeStack</title>
    <link>https://constructor-md.github.io/codestack/</link>
    <description>Recent content on CodeStack</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <atom:link href="https://constructor-md.github.io/codestack/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>HashMap</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/collection/hashmap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/collection/hashmap/</guid>
      <description>&lt;h1 id=&#34;hashmap&#34;&gt;&#xD;&#xA;  HashMap&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hashmap&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;数据结构&#34;&gt;&#xD;&#xA;  数据结构&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;JDK1.7之前，采用数组+链表&lt;/li&gt;&#xA;&lt;li&gt;JDK1.8之后，数组+链表+红黑树&#xA;当链表长度大于阈值或者红黑树的边界值，默认为8，且数组长度大于64时，该索引位置的数据改为红黑树存储&lt;br&gt;&#xA;如果数组长度不够64，则执行扩容。数组长度较小时换为红黑树，反而会降低效率。因为红黑树需要左旋右旋变色等操作来保持平衡&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;哈希表底层的hash算法&#34;&gt;&#xD;&#xA;  哈希表底层的hash算法&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%93%88%e5%b8%8c%e8%a1%a8%e5%ba%95%e5%b1%82%e7%9a%84hash%e7%ae%97%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;采用key的hashcode值，结合数组长度进行无符号右移，按位异或，按位与计算出索引&lt;br&gt;&#xA;还可以采用平方取中，取余数，伪随机数法。但位运算效率较高&lt;/p&gt;&#xA;&lt;h2 id=&#34;哈希表的存储和查询&#34;&gt;&#xD;&#xA;  哈希表的存储和查询&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%93%88%e5%b8%8c%e8%a1%a8%e7%9a%84%e5%ad%98%e5%82%a8%e5%92%8c%e6%9f%a5%e8%af%a2&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;存储时，根据hash算法计算出索引位置，找到指定位置存储&lt;br&gt;&#xA;以String为例，如果位置上已经有元素，则equals判断元素是否相等，相等则替换 &lt;br&gt;&#xA;不相等则在该位置形成链表，数据变为链表上的一个节点。以解决哈希碰撞问题&lt;/p&gt;&#xA;&lt;h2 id=&#34;哈希扩容&#34;&gt;&#xD;&#xA;  哈希扩容&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%93%88%e5%b8%8c%e6%89%a9%e5%ae%b9&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;当元素个数超过数组大小*负载因子（默认0.75）时进行扩容，扩大一倍&lt;br&gt;&#xA;扩容时需要rehash，但是方式比较巧妙，由于每次扩容都是翻倍，所以rehash相当于将原来的位置+旧容量就得到新的位置，没有再计算hash值&lt;br&gt;&#xA;但是新的键值进入仍进行了hash&lt;/p&gt;&#xA;&lt;h2 id=&#34;常见hash算法的原理&#34;&gt;&#xD;&#xA;  常见hash算法的原理：&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b8%b8%e8%a7%81hash%e7%ae%97%e6%b3%95%e7%9a%84%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;平方取中法：取关键字平方后中间几位作为散列地址&lt;/li&gt;&#xA;&lt;li&gt;直接寻址法：取关键字或关键字的某个线性函数值作为散列地址&lt;/li&gt;&#xA;&lt;li&gt;数字分析法：分析数据，如果是日期，发现年月日前几位数字大致相同，出现冲突几率大。你那月日的后几位月份和具体日期差别大，考虑用后面则冲突几率降低。即找规律用低碰撞的数据构造冲突几率低的散列地址&lt;/li&gt;&#xA;&lt;li&gt;折叠法：关键字分割成位数相同的几部分，最后一部分位数可以不同。取这几部分的叠加和（去除进位）作为散列地址&lt;/li&gt;&#xA;&lt;li&gt;随机数法：选择一个随机函数，取关键字的随机值作为散列地址，用于关键字长度不同的场合&lt;/li&gt;&#xA;&lt;li&gt;除留余数法：取关键字某个不大于散列表表长m的数p除后得到余数作为散列地址。p一般取素数或m，如果p选的不好容易产生随机值&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h1 id=&#34;处理冲突的方法&#34;&gt;&#xD;&#xA;  处理冲突的方法&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a4%84%e7%90%86%e5%86%b2%e7%aa%81%e7%9a%84%e6%96%b9%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;开放寻址法&lt;/li&gt;&#xA;&lt;li&gt;拉链法&lt;/li&gt;&#xA;&lt;li&gt;再散列法&lt;/li&gt;&#xA;&lt;li&gt;公共溢出区&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>HTTP</title>
      <link>https://constructor-md.github.io/codestack/docs/basic/net/application/http/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/basic/net/application/http/</guid>
      <description>&lt;h1 id=&#34;http&#34;&gt;&#xD;&#xA;  HTTP&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#http&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;HTTP是应用层的，基于TCP的超文本传输协议&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;无状态：协议自身不对请求和响应之间的通信状态进行保存，任何两次请求之间没有依赖关系&lt;/li&gt;&#xA;&lt;li&gt;无连接：每次连接只处理一个请求&#xA;使用80作为默认端口&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;报文结构&#34;&gt;&#xD;&#xA;  报文结构&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8a%a5%e6%96%87%e7%bb%93%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;请求报文&#34;&gt;&#xD;&#xA;  请求报文&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%b7%e6%b1%82%e6%8a%a5%e6%96%87&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;&lt;img src=&#34;./images/request.png&#34; alt=&#34;请求报文&#34; title=&#34;请求报文&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;请求报文总体四个部分&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;请求行&#xA;包括请求方法、URL、协议版本，彼此使用空格分隔&lt;/li&gt;&#xA;&lt;li&gt;请求头&#xA;KV形式的辅助信息&lt;/li&gt;&#xA;&lt;li&gt;空行&#xA;分隔报头(请求行+请求头)和请求体，由回车符和换行符组成&lt;/li&gt;&#xA;&lt;li&gt;请求体&#xA;请求发送时携带的数据&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;请求行&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;方法&lt;/th&gt;&#xA;          &lt;th&gt;说明&lt;/th&gt;&#xA;          &lt;th&gt;支持的HTTP协议版本&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GET&lt;/td&gt;&#xA;          &lt;td&gt;获取资源&lt;/td&gt;&#xA;          &lt;td&gt;1.0，1.1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;POST&lt;/td&gt;&#xA;          &lt;td&gt;传输实体主体(提交信息)&lt;/td&gt;&#xA;          &lt;td&gt;1.0，1.1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;PUT&lt;/td&gt;&#xA;          &lt;td&gt;传输文件&lt;/td&gt;&#xA;          &lt;td&gt;1.0，1.1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;HEAD&lt;/td&gt;&#xA;          &lt;td&gt;获得报文首部&lt;/td&gt;&#xA;          &lt;td&gt;1.0，1.1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;DELETE&lt;/td&gt;&#xA;          &lt;td&gt;删除文件&lt;/td&gt;&#xA;          &lt;td&gt;1.0，1.1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;OPTIONS&lt;/td&gt;&#xA;          &lt;td&gt;询问支持的方法&lt;/td&gt;&#xA;          &lt;td&gt;1.1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;TRACE&lt;/td&gt;&#xA;          &lt;td&gt;追踪路径&lt;/td&gt;&#xA;          &lt;td&gt;1.1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CONNECT&lt;/td&gt;&#xA;          &lt;td&gt;要求用隧道协议连接代理&lt;/td&gt;&#xA;          &lt;td&gt;1.1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;LINK&lt;/td&gt;&#xA;          &lt;td&gt;建立和资源之间的联系&lt;/td&gt;&#xA;          &lt;td&gt;1.0&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;UNLINE&lt;/td&gt;&#xA;          &lt;td&gt;断开连接关系&lt;/td&gt;&#xA;          &lt;td&gt;1.0&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;请求头&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;请求头&lt;/th&gt;&#xA;          &lt;th&gt;含义&lt;/th&gt;&#xA;          &lt;th&gt;示例&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Cache-Control&lt;/td&gt;&#xA;          &lt;td&gt;用于控制缓存策略，设置缓存的行为，如是否允许缓存、缓存时间、缓存验证方式等&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;Cache-Control: max-age=3600&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Connection&lt;/td&gt;&#xA;          &lt;td&gt;指示客户端和服务器之间的连接选项，常见值有 &lt;code&gt;keep-alive&lt;/code&gt; 和 &lt;code&gt;close&lt;/code&gt;，分别表示保持连接和关闭连接&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;Connection: keep-alive&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Date&lt;/td&gt;&#xA;          &lt;td&gt;表示请求发送的日期和时间，采用 HTTP 日期格式，服务器可据此进行时间相关处理&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;Date: Wed, 18 Apr 2025 12:00:00 GMT&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Accept&lt;/td&gt;&#xA;          &lt;td&gt;告知服务器客户端能够接受的响应内容类型，服务器会根据此选择合适的内容格式返回&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Accept-Encoding&lt;/td&gt;&#xA;          &lt;td&gt;指定客户端能够接受的编码方式，如 &lt;code&gt;gzip&lt;/code&gt;、&lt;code&gt;deflate&lt;/code&gt; 等，服务器会对响应数据进行相应的编码压缩&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;Accept-Encoding: gzip, deflate&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Accept-Language&lt;/td&gt;&#xA;          &lt;td&gt;表示客户端偏好的语言，服务器可根据此返回对应语言的内容&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Host&lt;/td&gt;&#xA;          &lt;td&gt;指定请求的目标主机和端口号，用于区分同一服务器上的不同虚拟主机或服务&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;Host: www.example.com:8080&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Referer&lt;/td&gt;&#xA;          &lt;td&gt;标识请求发起的来源页面的 URL，服务器可以借此了解请求的上下文和来源路径&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;Referer: https://www.example.com/page1.html&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;User-Agent&lt;/td&gt;&#xA;          &lt;td&gt;包含客户端的相关信息，如浏览器类型、版本、操作系统等，服务器可根据此进行不同的适配和处理&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.5615.137 Safari/537.36&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Content-Type&lt;/td&gt;&#xA;          &lt;td&gt;用于 POST、PUT 等请求，指示请求体中数据的类型，如 &lt;code&gt;application/json&lt;/code&gt;、&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;、&lt;code&gt;multipart/form-data&lt;/code&gt; 等&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;Content-Type: application/json&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Content-Length&lt;/td&gt;&#xA;          &lt;td&gt;表示请求体的长度，以字节为单位，服务器可据此判断是否完整接收了请求数据&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;Content-Length: 1024&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;响应报文&#34;&gt;&#xD;&#xA;  响应报文&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%93%8d%e5%ba%94%e6%8a%a5%e6%96%87&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;&lt;img src=&#34;./images/response.png&#34; alt=&#34;响应报文&#34; title=&#34;响应报文&#34;/&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>InnoDB 索引</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/mysql/innodb_index/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/mysql/innodb_index/</guid>
      <description>&lt;h1 id=&#34;innodb-索引&#34;&gt;&#xD;&#xA;  InnoDB 索引&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#innodb-%e7%b4%a2%e5%bc%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;表数据结构&#34;&gt;&#xD;&#xA;  表数据结构&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a1%a8%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;索引组织表&#34;&gt;&#xD;&#xA;  索引组织表&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b4%a2%e5%bc%95%e7%bb%84%e7%bb%87%e8%a1%a8&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;每张表必然有主键&lt;/li&gt;&#xA;&lt;li&gt;没有显示建立主键，使用第一个非空唯一索引作为主键&lt;/li&gt;&#xA;&lt;li&gt;没有非空唯一索引，存储引擎自动创建一个6字节大小的指针row_id作为主键&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;逻辑存储架构&#34;&gt;&#xD;&#xA;  逻辑存储架构&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%80%bb%e8%be%91%e5%ad%98%e5%82%a8%e6%9e%b6%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;所有数据存放在表空间中，表空间由段、区、页组成&lt;/li&gt;&#xA;&lt;li&gt;段有数据段、索引段、回滚段等。概念上数据就是索引，数据段就是B+树的叶子节点，索引段是B+树的非叶子节点&lt;/li&gt;&#xA;&lt;li&gt;区是连续页组成的空间，每个区大小固定1MB。页大小16KB，每区固定64个连续页&lt;/li&gt;&#xA;&lt;li&gt;页是存储引擎数据管理最小单位，每次读写磁盘最小一页，即16KB&lt;/li&gt;&#xA;&lt;li&gt;行：Innodb是面向列的存储引擎，数据按行存放，每页最多存放7992行记录&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;b树&#34;&gt;&#xD;&#xA;  B+树&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#b%e6%a0%91&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;B+树由二叉查找树和二叉平衡树发展而来，但B+树是多叉树，减小树高度&lt;/li&gt;&#xA;&lt;li&gt;B+树的记录数据都在叶子节点上，非叶子节点存放的数据是索引值&lt;/li&gt;&#xA;&lt;li&gt;叶子节点之间以指针双向连接，形成链表，方便范围查找&lt;/li&gt;&#xA;&lt;li&gt;B+树索引分成聚簇索引和二级索引，区别在于叶子节点是否存放所有行信息&lt;/li&gt;&#xA;&lt;li&gt;B+树是平衡树，所有叶子节点在同一层，查询稳定性高&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;优势&#34;&gt;&#xD;&#xA;  优势&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bc%98%e5%8a%bf&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;树高度低，减少磁盘IO&#xA;&lt;ol&gt;&#xA;&lt;li&gt;每个非叶子节点存放多个范围的下一级节点的指针，而不只是普通二叉查找树的两个，靠这一点减少树高度&lt;/li&gt;&#xA;&lt;li&gt;在索引树上查找时，先从磁盘读取根节点，每找到下一级索引就要从磁盘读取索引页得到数据继续判断，索引树高度低，使得读取一次磁盘筛选数据效率高，大幅减少磁盘IO次数&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;叶子链表范围查询高效&#xA;叶子节点形成索引值的顺序链表，支持顺序遍历，便于范围查询&lt;/li&gt;&#xA;&lt;li&gt;查询稳定性&#xA;&lt;ol&gt;&#xA;&lt;li&gt;B+树使用分裂+合并技术保持结构稳定性。因为插入数据导致一个节点达到容量上限，就会分裂成两个节点；因为删除数据导致两个节点太小，空间利用率低，就会合并成一个节点。这也是它的自平衡策略的一部分，同层横向扩展&lt;/li&gt;&#xA;&lt;li&gt;B+树高度变化少，一般最高四层就能存储千万以上数据&lt;/li&gt;&#xA;&lt;li&gt;只有叶子节点才有具体数据，插入和删除对树结构影响小&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;对比b树&#34;&gt;&#xD;&#xA;  对比B树&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%b9%e6%af%94b%e6%a0%91&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;B树非叶子节点存放数据，使得一次读取磁盘筛选数据效率低，且树高度变高，磁盘IO负担大&lt;/p&gt;&#xA;&lt;h3 id=&#34;聚簇索引聚集索引主键索引&#34;&gt;&#xD;&#xA;  聚簇索引/聚集索引/主键索引&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%81%9a%e7%b0%87%e7%b4%a2%e5%bc%95%e8%81%9a%e9%9b%86%e7%b4%a2%e5%bc%95%e4%b8%bb%e9%94%ae%e7%b4%a2%e5%bc%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;按主键构造B+树&lt;/li&gt;&#xA;&lt;li&gt;叶子节点存放的行记录信息包含所有列&lt;/li&gt;&#xA;&lt;li&gt;通过聚集索引查找数据，可以直接在叶子节点得到全部数据&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;二级索引&#34;&gt;&#xD;&#xA;  二级索引&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8c%e7%ba%a7%e7%b4%a2%e5%bc%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;根据索引列值构造B+树&lt;/li&gt;&#xA;&lt;li&gt;叶子节点有索引值、该索引值对应的主键&lt;/li&gt;&#xA;&lt;li&gt;通过二级索引查找数据时，会根据索引找到对应的叶子节点，再根据叶子节点上的主键值，回表到主键索引获取更多列数据&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;索引失效情况枚举&#34;&gt;&#xD;&#xA;  索引失效情况枚举&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b4%a2%e5%bc%95%e5%a4%b1%e6%95%88%e6%83%85%e5%86%b5%e6%9e%9a%e4%b8%be&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;隐式类型转换导致索引失效&#34;&gt;&#xD;&#xA;  隐式类型转换导致索引失效&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%9a%90%e5%bc%8f%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2%e5%af%bc%e8%87%b4%e7%b4%a2%e5%bc%95%e5%a4%b1%e6%95%88&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;原因：查询条件和主键类型不一致，转换失败时无法使用索引，导致全表扫描&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;-- 索引`id`为INT类型&#xD;&#xA;SELECT * FROM t WHERE id = &amp;#39;100&amp;#39;; -- 字符串转INT，索引有效（依赖优化器）&#xD;&#xA;SELECT * FROM t WHERE id = &amp;#39;100ABC&amp;#39;; -- 转换失败，全表扫描&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;使用函数或计算索引列&#34;&gt;&#xD;&#xA;  使用函数或计算索引列&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8%e5%87%bd%e6%95%b0%e6%88%96%e8%ae%a1%e7%ae%97%e7%b4%a2%e5%bc%95%e5%88%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;原因：索引树结构逻辑为大小排列，函数计算后无法找到对应的节点&lt;/p&gt;</description>
    </item>
    <item>
      <title>Ubuntu</title>
      <link>https://constructor-md.github.io/codestack/docs/deploy/ubuntu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/deploy/ubuntu/</guid>
      <description>&lt;h1 id=&#34;ubuntu&#34;&gt;&#xD;&#xA;  Ubuntu&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#ubuntu&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;采用版本：24.01&lt;/p&gt;&#xA;&lt;p&gt;安装过程：全部 Done&lt;/p&gt;&#xA;&lt;h2 id=&#34;非root用户上传文件&#34;&gt;&#xD;&#xA;  非Root用户上传文件&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%9d%9eroot%e7%94%a8%e6%88%b7%e4%b8%8a%e4%bc%a0%e6%96%87%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 赋予指定用户组用户在某个文件夹及其子文件夹上传文件的权限&#xD;&#xA; sudo chown -R quanta:quanta /DATA&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;时区设置&#34;&gt;&#xD;&#xA;  时区设置&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%97%b6%e5%8c%ba%e8%ae%be%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 查看当前时区&#xD;&#xA;timedatectl&#xD;&#xA;# 查看东八区全称&#xD;&#xA;timedatectl list-timezones | grep Shanghai&#xD;&#xA;# 设置时区&#xD;&#xA;sudo timedatectl set-timezone Asia/Shanghai&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;host设置&#34;&gt;&#xD;&#xA;  host设置&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#host%e8%ae%be%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;便于多主机内网互相访问&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo vim /etc/hosts&#xD;&#xA;&#xD;&#xA;# 补充相关机器的ip 主机名&#xD;&#xA;192.168.1.11 dataserver1&#xD;&#xA;192.168.1.12 dataserver2&#xD;&#xA;192.168.1.13 dataserver3&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;openssh安装&#34;&gt;&#xD;&#xA;  OpenSSH安装&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#openssh%e5%ae%89%e8%a3%85&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo apt update &amp;amp;&amp;amp; sudo apt upgrade&#xD;&#xA;sudo apt install openssh-server&#xD;&#xA;service ssh status&#xD;&#xA;# 随后可以本机SSH使用安装过程设置的账户密码登录服务器&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;修改监听端口&#34;&gt;&#xD;&#xA;  修改监听端口&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bf%ae%e6%94%b9%e7%9b%91%e5%90%ac%e7%ab%af%e5%8f%a3&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo vi /etc/ssh/sshd_config&#xD;&#xA;# 内容&#xD;&#xA;Port 2222&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修改后要重启&lt;/p&gt;</description>
    </item>
    <item>
      <title>依赖注入|控制反转|自动装配</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/spring/ioc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/spring/ioc/</guid>
      <description>&lt;h1 id=&#34;依赖注入控制反转自动装配&#34;&gt;&#xD;&#xA;  依赖注入|控制反转|自动装配&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5%e6%8e%a7%e5%88%b6%e5%8f%8d%e8%bd%ac%e8%87%aa%e5%8a%a8%e8%a3%85%e9%85%8d&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;控制反转ioc与依赖注入di&#34;&gt;&#xD;&#xA;  控制反转(IOC)与依赖注入(DI)&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8e%a7%e5%88%b6%e5%8f%8d%e8%bd%acioc%e4%b8%8e%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5di&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;控制反转基本概念：  &lt;br&gt;&#xA;将对象的创建和管理的控制权，从某个实体类，转交给 Spring 容器&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;在传统模式中，对象需要哪些资源就要在类代码中写明自己去 new 出来&lt;br&gt;&#xA;现在则统一由 Spring 提供，从主动变成了被动。称为控制反转&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;依赖注入基本概念：&lt;br&gt;&#xA;对象间的依赖关系，被 Spring 容器自动注入到需要他们的对象中去&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;也就是由 Spring 容器来管理对象间的依赖关系&#xA;依赖注入是控制反转的一种实现形式&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;指的是组件自身提供普通的 Java 方法声明依赖关系。容器全权负责组件依赖关系的装配，将根据这些声明主动将符合依赖关系的对象设置给需要的对象，实现原理是反射&lt;/li&gt;&#xA;&lt;li&gt;为了实现控制反转的概念，Spring 实现了依赖注入的机制&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;依赖注入机制的使用方式：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;属性注入形式&#xA;xml方式：使类有 Set 方法，并设置 bean 和 property 。Spring 读取 xml 文件时，认为需要向 bean a 注入 bean b。这实质上是通过，使类有 set 方法，从而可实现用xml文件声明属性依赖关系，从而声明依赖关系，寻求注入的方式。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;img src=&#34;./images/DI-param.png&#34; alt=&#34;属性注入&#34; title=&#34;属性注入&#34;/&gt;&lt;/p&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;构造器注入形式&#xA;xml方式：使类具备有参构造函数，并设置 bean 和 property。实质上与上述是相似的，只是多支持了一种声明的方式。&#xA;&lt;img src=&#34;./images/DI-struct.png&#34; alt=&#34;构造器注入&#34; title=&#34;构造器注入&#34;/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Java显式配置&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过注解，描述某个类应该作为 Bean 被容器管理，且内部包含一些如何在上下文中创建 Bean 的细节。如 @Configuration。&lt;/li&gt;&#xA;&lt;li&gt;通过注解，描述某个方法的返回结果应该作为 Bean 被容器管理，如 @Bean。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;自动装配&#34;&gt;&#xD;&#xA;  自动装配&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%87%aa%e5%8a%a8%e8%a3%85%e9%85%8d&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;上述的依赖注入的使用方式，实际上都是在告诉 Spring 容器如何装配对象间的依赖关系&#xA;Spring 对于描述 Bean 如何进行装配时，提供了三种主要的装配机制：&lt;/p&gt;</description>
    </item>
    <item>
      <title>基本数据类型</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/common-class/basic-data/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/common-class/basic-data/</guid>
      <description>&lt;h1 id=&#34;基本数据类型&#34;&gt;&#xD;&#xA;  基本数据类型&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;整型&#34;&gt;&#xD;&#xA;  整型：&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b4%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Byte 8位 1字节&lt;/li&gt;&#xA;&lt;li&gt;Short 16位 2字节&lt;/li&gt;&#xA;&lt;li&gt;Int 32位 4字节&lt;/li&gt;&#xA;&lt;li&gt;Long 64位 8字节&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;浮点型&#34;&gt;&#xD;&#xA;  浮点型&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b5%ae%e7%82%b9%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Float 32位&lt;/li&gt;&#xA;&lt;li&gt;Double 64位&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;字符型&#34;&gt;&#xD;&#xA;  字符型&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ad%97%e7%ac%a6%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Char 16位Unicode&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;布尔型&#34;&gt;&#xD;&#xA;  布尔型&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b8%83%e5%b0%94%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Boolean 32位&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;可以自动从短类型转为长类型&lt;br&gt;&#xA;如果把大整数转成小数类型，会有精度丢失&lt;br&gt;&#xA;如果强转类型，则会截尾，丢失尾部数据&lt;/p&gt;</description>
    </item>
    <item>
      <title>深拷贝/浅拷贝</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/other/clone/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/other/clone/</guid>
      <description>&lt;h1 id=&#34;深拷贝浅拷贝&#34;&gt;&#xD;&#xA;  深拷贝/浅拷贝&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b7%b1%e6%8b%b7%e8%b4%9d%e6%b5%85%e6%8b%b7%e8%b4%9d&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;对象拷贝，就是将一个对象复制一份。复制方法不同则有不同结果&lt;/p&gt;&#xA;&lt;h2 id=&#34;浅拷贝&#34;&gt;&#xD;&#xA;  浅拷贝&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b5%85%e6%8b%b7%e8%b4%9d&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;新建一个对象，将对方的属性全部复制过来&#xA;有自己的堆内存地址，但是对方的属性中的引用类型，对于双方来说是共享的，只复制了内存地址&#xA;只拷贝了第一层&lt;/p&gt;&#xA;&lt;h2 id=&#34;深拷贝&#34;&gt;&#xD;&#xA;  深拷贝&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b7%b1%e6%8b%b7%e8%b4%9d&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;有多少层就拷贝多少层，两个对象完全分开，但是内容相同&lt;/p&gt;&#xA;&lt;h2 id=&#34;相关接口和方法&#34;&gt;&#xD;&#xA;  相关接口和方法&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%9b%b8%e5%85%b3%e6%8e%a5%e5%8f%a3%e5%92%8c%e6%96%b9%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;cloneable接口&#34;&gt;&#xD;&#xA;  Cloneable接口&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cloneable%e6%8e%a5%e5%8f%a3&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;是一个标记接口，在类中重写Object中的Clone方法，类调用clone方法才能克隆成功&lt;br&gt;&#xA;可以直接调用super.clone()，来使用Object中的clone方法得到浅克隆结果&lt;br&gt;&#xA;如果不实现该接口，则会抛出CloneNotSupported异常&lt;br&gt;&#xA;Cloneable接口下没有任何方法&lt;/p&gt;&#xA;&lt;h3 id=&#34;objectclone方法&#34;&gt;&#xD;&#xA;  Object.clone方法&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#objectclone%e6%96%b9%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;该方法被native修饰，是一个空方法，没有方法体（native修饰都是如此）&lt;br&gt;&#xA;每一个native方法在JVM中都有一个同名实现体&lt;br&gt;&#xA;判断是否实现Cloneable接口，是在JVM方法体中实现的&lt;br&gt;&#xA;默认实现浅拷贝&lt;/p&gt;&#xA;&lt;h2 id=&#34;如何实现深拷贝&#34;&gt;&#xD;&#xA;  如何实现深拷贝？&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e6%b7%b1%e6%8b%b7%e8%b4%9d&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;使用序列化将对象变成字节流，输入再输出&lt;br&gt;&#xA;或者让内部每一层对象都实现clone方法，调用clone方法时，将clone出来的对象的属性值替换成原属性值的clone结果&lt;br&gt;&#xA;或者嵌套遍历访问其中每个元素，新建对象复制值&lt;/p&gt;</description>
    </item>
    <item>
      <title>线程的创建和使用</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/multi-thread/thread-create/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/multi-thread/thread-create/</guid>
      <description>&lt;h1 id=&#34;线程的创建和使用&#34;&gt;&#xD;&#xA;  线程的创建和使用&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e7%9a%84%e5%88%9b%e5%bb%ba%e5%92%8c%e4%bd%bf%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;可以直接new Thread()创建一个线程&lt;br&gt;&#xA;要想让线程执行某个任务，创建线程时可以传入具体的一个Runnable对象，内含实现方法&lt;br&gt;&#xA;最后调用线程的start方法开始执行&lt;/p&gt;&#xA;&lt;p&gt;设置任务的方式：&lt;/p&gt;&#xA;&lt;h2 id=&#34;实现runnable接口&#34;&gt;&#xD;&#xA;  实现Runnable接口&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%9e%e7%8e%b0runnable%e6%8e%a5%e5%8f%a3&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;内部实现run方法，创建线程时作为实例化参数传递进去，则start线程后会执行run方法&lt;br&gt;&#xA;无法获取返回值，run方法是void的，且不支持传递参数进去&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public class RunnableExample {&#xD;&#xA;    public static void main(String[] args) {&#xD;&#xA;        // 创建Runnable接口的实现类&#xD;&#xA;        Runnable task = new Runnable() {&#xD;&#xA;            @Override&#xD;&#xA;            public void run() {&#xD;&#xA;                System.out.println(&amp;#34;通过实现Runnable接口创建的线程正在执行任务&amp;#34;);&#xD;&#xA;                try {&#xD;&#xA;                    Thread.sleep(1000);&#xD;&#xA;                } catch (InterruptedException e) {&#xD;&#xA;                    e.printStackTrace();&#xD;&#xA;                }&#xD;&#xA;                System.out.println(&amp;#34;任务执行完毕&amp;#34;);&#xD;&#xA;            }&#xD;&#xA;        };&#xD;&#xA;&#xD;&#xA;        // 创建线程并传入Runnable实例&#xD;&#xA;        Thread thread = new Thread(task);&#xD;&#xA;        // 启动线程&#xD;&#xA;        thread.start();&#xD;&#xA;    }&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;实现callable接口&#34;&gt;&#xD;&#xA;  实现Callable接口&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%9e%e7%8e%b0callable%e6%8e%a5%e5%8f%a3&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;这是一个泛型接口，实现其中的call方法，方法的返回值即接口指定的泛型&lt;br&gt;&#xA;实现类放进一个FutureTask对象中，将FutureTask对象传入Thread构造方法&lt;br&gt;&#xA;执行完毕后，通过FutureTask对象的get方法可以获取返回值&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import java.util.concurrent.*;&#xD;&#xA;&#xD;&#xA;public class CallableExample {&#xD;&#xA;    public static void main(String[] args) {&#xD;&#xA;        // 创建Callable接口的实现类&#xD;&#xA;        Callable&amp;lt;String&amp;gt; callableTask = new Callable&amp;lt;String&amp;gt;() {&#xD;&#xA;            @Override&#xD;&#xA;            public String call() throws Exception {&#xD;&#xA;                System.out.println(&amp;#34;通过实现Callable接口创建的线程正在执行任务&amp;#34;);&#xD;&#xA;                Thread.sleep(2000);&#xD;&#xA;                return &amp;#34;任务执行结果：成功&amp;#34;;&#xD;&#xA;            }&#xD;&#xA;        };&#xD;&#xA;&#xD;&#xA;        // 将Callable包装成FutureTask&#xD;&#xA;        FutureTask&amp;lt;String&amp;gt; futureTask = new FutureTask&amp;lt;&amp;gt;(callableTask);&#xD;&#xA;        // 创建线程并传入FutureTask&#xD;&#xA;        Thread thread = new Thread(futureTask);&#xD;&#xA;        // 启动线程&#xD;&#xA;        thread.start();&#xD;&#xA;&#xD;&#xA;        try {&#xD;&#xA;            // 获取任务执行结果（会阻塞直到任务完成）&#xD;&#xA;            String result = futureTask.get();&#xD;&#xA;            System.out.println(&amp;#34;获取到的返回值：&amp;#34; + result);&#xD;&#xA;        } catch (InterruptedException | ExecutionException e) {&#xD;&#xA;            e.printStackTrace();&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;继承thread类&#34;&gt;&#xD;&#xA;  继承Thread类&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%a7%e6%89%bfthread%e7%b1%bb&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;因为Thread类实现了Runnable接口，我们可以继承Thread类实现run方法，实例化我们实现的子类，然后执行start，即可运行其中的方法&lt;br&gt;&#xA;但是继承整个Thread类开销过大，一般不使用。&lt;br&gt;&#xA;且Java不支持多重继承，继承了Thread接口无法继承其他类，但是接口则可以实现多个，所以使用接口实现传递方法比较好。&lt;/p&gt;</description>
    </item>
    <item>
      <title>AOP</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/spring/aop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/spring/aop/</guid>
      <description>&lt;h1 id=&#34;aop&#34;&gt;&#xD;&#xA;  AOP&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aop&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;基本概念：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;编程时将所需逻辑写在切面中&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这么做的好处是，让一些公共的逻辑，重复的代码，能够出现在统一的位置，即切面中，方便维护，减少重复代码的开发量。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;思路上，是通过为某些切面，为某些方法提供行为增强。这种增强可能出现在方法执行前，方法执行后，方法返回前，方法异常时等。&lt;/li&gt;&#xA;&lt;li&gt;实现方法上，出于对某个方法进行前置或后置逻辑的编写的角度，想要通过代理模式来实现功能。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Spring的切面实现，支持了两种代理模式：JDK动态代理（默认）、CGLIB动态代理&lt;/p&gt;&#xA;&lt;h2 id=&#34;spring的动态代理实现&#34;&gt;&#xD;&#xA;  Spring的动态代理实现&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring%e7%9a%84%e5%8a%a8%e6%80%81%e4%bb%a3%e7%90%86%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;众所周知，代理模式的实现方法就是为当前类或者方法创建代理类&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;实际调用时调用代理类&lt;/li&gt;&#xA;&lt;li&gt;代理类再调用原本方法逻辑，代理类本身可以在调用原本方法前后&amp;quot;编织&amp;quot;入一些定义好的代码，在调用原本方法前后执行&amp;quot;编织&amp;quot;入的方法，实现&amp;quot;方法增强&amp;quot;&lt;/li&gt;&#xA;&lt;li&gt;探讨Spring如何实现动态代理，其实是探讨Spring如何动态创建代理类&#xA;&lt;ul&gt;&#xA;&lt;li&gt;静态代理是直接硬编码编写代理类，并替换调用方方法调用代理类&lt;/li&gt;&#xA;&lt;li&gt;但是动态代理就需要有一套代码，能根据不同内容的原本类，动态构建一个代理类，并在调用原本方法前后调用切面类内编写的增强方法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;静态代理示例&#34;&gt;&#xD;&#xA;  静态代理示例&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%9d%99%e6%80%81%e4%bb%a3%e7%90%86%e7%a4%ba%e4%be%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class ProxySubject implements Subject {&#xD;&#xA;    private RealSubject realSubject;&#xD;&#xA;&#xD;&#xA;    public ProxySubject(RealSubject realSubject) {&#xD;&#xA;        this.realSubject = realSubject;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    @Override&#xD;&#xA;    public void request() {&#xD;&#xA;        // 方法调用前的增强代码&#xD;&#xA;        System.out.println(&amp;#34;ProxySubject: Before calling the real subject.&amp;#34;);&#xD;&#xA;&#xD;&#xA;        // 调用被代理对象的方法&#xD;&#xA;        realSubject.request();&#xD;&#xA;&#xD;&#xA;        // 方法调用后的增强代码&#xD;&#xA;        System.out.println(&amp;#34;ProxySubject: After calling the real subject.&amp;#34;);&#xD;&#xA;    }&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;spring-aop-动态代理源码解析&#34;&gt;&#xD;&#xA;  Spring AOP 动态代理源码解析&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-aop-%e5%8a%a8%e6%80%81%e4%bb%a3%e7%90%86%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;接下来从源码层面逐一剖析Spring是如何实现AOP&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用项目：&lt;a href=&#34;https://github.com/constructor-md/kuibu-service&#34;&gt;跬步后端项目仓库&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;Branch: main&lt;/li&gt;&#xA;&lt;li&gt;commit: f2763b5c8308f59a399ad32ae2cdffef8aee1ee0&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;我的项目采用 SpringBoot:2.7.6 版本，直接引入 spring-boot-starter-aop 包&#xA;&lt;img src=&#34;./images/pom-springboot.png&#34; alt=&#34;pom-springboot&#34; title=&#34;pom-springboot&#34;/&gt;&#xA;&lt;img src=&#34;./images/pom-aop.png&#34; alt=&#34;pom-aop&#34; title=&#34;pom-aop&#34;/&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>ConcurrentHashMap</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/collection/ConcurrentHashMap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/collection/ConcurrentHashMap/</guid>
      <description>&lt;h1 id=&#34;concurrenthashmap&#34;&gt;&#xD;&#xA;  ConcurrentHashMap&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#concurrenthashmap&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;是一个支持高并发更新和查询的哈希表，基于 HashMap 实现&lt;br&gt;&#xA;HashMap 本身没有对多线程情况进行线程安全的处理 &lt;br&gt;&#xA;如果改用 HashTable 或者 Collections.synchronizedMap，则会对整个容器进行加锁，通知时间的其他操作都会被阻塞&lt;br&gt;&#xA;但是 ConcurrentHashMap 不对整个容器加锁，而是对一小部分加锁，不影响其他位置的操作&lt;/p&gt;&#xA;&lt;h2 id=&#34;数据结构&#34;&gt;&#xD;&#xA;  数据结构&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;jdk18-以前segementreentranlock分段锁&#34;&gt;&#xD;&#xA;  JDK1.8 以前：Segement+ReentranLock（分段锁）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jdk18-%e4%bb%a5%e5%89%8dsegementreentranlock%e5%88%86%e6%ae%b5%e9%94%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;由 HashMap 实现的 Segment 组成，实际是多段的 HashMap。可以理解为 ConcurrentHashMap 中有一个 Segement 数组，每个 Segement 就是一个 HashMap。&lt;/li&gt;&#xA;&lt;li&gt;采用分段锁的思想。写操作时，通过只锁涉及到的 Segment 的方式，保证修改的线程安全，同时不影响其它部分的并发操作。&lt;/li&gt;&#xA;&lt;li&gt;Segment 内部进行扩容，和 HashMap 的扩容逻辑相似，先生成新数组，然后转移元素到新数组中。&lt;/li&gt;&#xA;&lt;li&gt;每个 Segment 单独扩容，互不干扰。是否需要扩容也是 Segment 内部单独判断，是否超过阈值&lt;/li&gt;&#xA;&lt;li&gt;默认创建 16 个 Segment，即默认最多允许并发 16 个不同的写&lt;/li&gt;&#xA;&lt;li&gt;并发度是Segment数量，比较固定&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;segment-实现的弊端&#34;&gt;&#xD;&#xA;  Segment 实现的弊端&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#segment-%e5%ae%9e%e7%8e%b0%e7%9a%84%e5%bc%8a%e7%ab%af&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;寻找元素需要两次 Hash&lt;/li&gt;&#xA;&lt;li&gt;提供了并发级别的默认设置，默认 16 个 Segment，无法根据实际场景动态调整，但是不一定适用于大部分场景，最好是让用户自己评估需要多少把锁&lt;/li&gt;&#xA;&lt;li&gt;存储成本比 HashMap 高，每个 Segment 最小容量为 2，默认并发级别 16，假如只需要存储 16 个元素，那么会建立一个 32 容量的 ConcurrentHashMap 来存&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;jdk18-以后nodesynchronizedcas&#34;&gt;&#xD;&#xA;  JDK1.8 以后：Node+Synchronized+CAS&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jdk18-%e4%bb%a5%e5%90%8enodesynchronizedcas&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;采用 Node 数组+链表/红黑树的数据结构（与HashMap高度相似 Node也只是一个数据节点）&lt;/li&gt;&#xA;&lt;li&gt;当链表长度超过 8 且数组长度 ≥ 64 时，链表转换为红黑树，提升查询效率&lt;/li&gt;&#xA;&lt;li&gt;每次操作某个槽位，都以该槽位的第一个元素作为锁，通过 synchronized 加锁，其他节点内仍可并发。锁粒度降到最低&lt;/li&gt;&#xA;&lt;li&gt;依赖 JVM 对 synchronized 的轻量级锁优化，性能优于显式 ReentrantLock&lt;/li&gt;&#xA;&lt;li&gt;槽位为空时（无锁写入），通过 CAS 原子操作直接写入数据&lt;/li&gt;&#xA;&lt;li&gt;移除 Segment，降低锁粒度、减少内存开销和哈希计算次数&lt;/li&gt;&#xA;&lt;li&gt;无锁读：通过 volatile 修饰的 Node 数组保证可见性，直接读取头节点。若为链表，遍历链表；若为红黑树，通过树结构查找&lt;/li&gt;&#xA;&lt;li&gt;并发度是理论上限为数组长度，随着数据变化动态调整&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;put-操作流程&#34;&gt;&#xD;&#xA;  put 操作流程&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#put-%e6%93%8d%e4%bd%9c%e6%b5%81%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;数组是否初始化，没有则初始化数组&lt;/li&gt;&#xA;&lt;li&gt;插入位置是否为空，是则使用 CAS 写入，size+1 并检查是否需要扩容&lt;/li&gt;&#xA;&lt;li&gt;是否正在扩容，是则协助扩容，扩容完毕后再从头判断起&lt;/li&gt;&#xA;&lt;li&gt;当前节点加锁，插入数据，解锁，szie+1 并检查是否需要扩容&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>InnoDB 事务</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/mysql/innodb_transaction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/mysql/innodb_transaction/</guid>
      <description>&lt;h1 id=&#34;innodb-事务&#34;&gt;&#xD;&#xA;  InnoDB 事务&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#innodb-%e4%ba%8b%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;MySQL中，事务功能主要是由 InnoDB 存储引擎来实现的&lt;/p&gt;&#xA;&lt;h2 id=&#34;innodb-事务特性acid及实现&#34;&gt;&#xD;&#xA;  InnoDB 事务特性（ACID）及实现&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#innodb-%e4%ba%8b%e5%8a%a1%e7%89%b9%e6%80%a7acid%e5%8f%8a%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;原子性atomicity&#34;&gt;&#xD;&#xA;  原子性（Atomicity）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8e%9f%e5%ad%90%e6%80%a7atomicity&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;事务内的操作要么全部成功，要么全部失败&lt;/p&gt;&#xA;&lt;p&gt;通过Undo Log实现原子性&lt;br&gt;&#xA;Undo Log 记录事务操作的反操作，或者说记录了每个操作前的数据，当事务需要回滚时，可以根据Undo Log恢复数据。&lt;br&gt;&#xA;从而实现事务内的操作要么全部执行，要么都不执行&lt;/p&gt;&#xA;&lt;h3 id=&#34;一致性consistency&#34;&gt;&#xD;&#xA;  一致性（Consistency）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%80%e8%87%b4%e6%80%a7consistency&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;事务必须使数据库从一个一致性状态变换到另一个一致性状态&lt;br&gt;&#xA;依赖于原子性和隔离性的实现，还依赖于数据库自身的完整性约束(如外键、CHECK 约束等)和应用程序的正确逻辑&lt;/p&gt;&#xA;&lt;h3 id=&#34;持久性durability&#34;&gt;&#xD;&#xA;  持久性（Durability）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8c%81%e4%b9%85%e6%80%a7durability&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作&lt;br&gt;&#xA;通过数据写入磁盘，以及Redo Log记录写入内存未写入磁盘的操作，在系统崩溃恢复时写入磁盘。保证持久性&lt;br&gt;&#xA;Redo Log本身在磁盘顺序写入，速度很快&lt;/p&gt;&#xA;&lt;h3 id=&#34;隔离性isolation&#34;&gt;&#xD;&#xA;  隔离性（Isolation）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%9a%94%e7%a6%bb%e6%80%a7isolation&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;多个并发事务之间要相互隔离。对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始&lt;/p&gt;&#xA;&lt;p&gt;通过MVCC和锁机制实现隔离性&lt;/p&gt;&#xA;&lt;p&gt;先说明MVCC隔离性实现原理，锁机制放在锁的篇章中&lt;/p&gt;&#xA;&lt;h3 id=&#34;mvcc&#34;&gt;&#xD;&#xA;  MVCC&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mvcc&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;innodb通过ReadView快照和版本链实现MVCC&lt;/p&gt;&#xA;&lt;h4 id=&#34;readview-快照&#34;&gt;&#xD;&#xA;  ReadView 快照&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#readview-%e5%bf%ab%e7%85%a7&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;Readview是代码中的对象，主要有如下属性：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;m_ids: 生成ReadView时当前系统中活跃的读写事务的事务id列表（未提交的事务）&lt;/li&gt;&#xA;&lt;li&gt;min_trx_id: 生成ReadView时当前系统中活跃的读写事务的最小事务id m_ids的最小值（最早的未提交事务）&lt;/li&gt;&#xA;&lt;li&gt;max_trx_id: 生成ReadView时系统应该分配给下一个事务的id值（下一个事务）&lt;/li&gt;&#xA;&lt;li&gt;creator_trx_id: 生成该ReadView的事务的id（所属事务）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;版本链&#34;&gt;&#xD;&#xA;  版本链&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%89%88%e6%9c%ac%e9%93%be&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;在Innodb中，以最新记录和 undo log 中的历史记录形成了版本链&lt;br&gt;&#xA;Innodb的每行数据，都有两个隐藏字段：事务ID和回滚指针&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;事务ID代表这行数据由哪个事务最后更新，回滚指针指向Undo Log中这行数据的上一个版本&lt;/li&gt;&#xA;&lt;li&gt;Undo Log中记录了数据的每个版本，同样也携带着修改成该版本的事务ID和指向上一个版本的回滚指针&lt;/li&gt;&#xA;&lt;li&gt;每行最新的数据，以及Undo Log中的历史版本中的数据，的回滚指针们形成了一条链表，即版本链&lt;/li&gt;&#xA;&lt;li&gt;事务的每个修改，不论是否已经提交，都会被记录在版本链上&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;MySQL 中有专门的 Purge 线程，会定期检查 Undo Log，删除那些已经不再需要的记录&lt;br&gt;&#xA;Purge 操作会遍历 Undo Log 链表，找到那些没有被任何活动事务引用的节点，并将其从磁盘上删除，释放空间&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL</title>
      <link>https://constructor-md.github.io/codestack/docs/deploy/mysql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/deploy/mysql/</guid>
      <description>&lt;h1 id=&#34;mysql&#34;&gt;&#xD;&#xA;  MySQL&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mysql&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;安装版本：MySQL 8.0.20&lt;/p&gt;&#xA;&lt;p&gt;部署方式：一主二从&lt;/p&gt;&#xA;&lt;p&gt;运行方式：docker-compose&lt;/p&gt;&#xA;&lt;h2 id=&#34;各节点安装&#34;&gt;&#xD;&#xA;  各节点安装&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%90%84%e8%8a%82%e7%82%b9%e5%ae%89%e8%a3%85&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;创建mysql目录&#34;&gt;&#xD;&#xA;  创建MySQL目录&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9b%e5%bb%bamysql%e7%9b%ae%e5%bd%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 放置所有mysql相关文件 比如my.cnf&#xD;&#xA;sudo mkdir /DATA/mysql&#xD;&#xA;# 放置mysql数据文件 也作为mysql&#xD;&#xA;sudo mkdir /DATA/mysql/mysql&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;创建mysql用户并设置权限&#34;&gt;&#xD;&#xA;  创建MySQL用户并设置权限&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9b%e5%bb%bamysql%e7%94%a8%e6%88%b7%e5%b9%b6%e8%ae%be%e7%bd%ae%e6%9d%83%e9%99%90&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 创建mysql用户 设置为不可登陆系统 并设置用户的主目录为/DATA/mysql/mysql&#xD;&#xA;sudo useradd -r -s /sbin/nologin -d /DATA/mysql/mysql mysql&#xD;&#xA;# 指定mysql用户的主目录为/DATA/mysql/mysql&#xD;&#xA;sudo usermod -d /DATA/mysql/mysql mysql&#xD;&#xA;# 递归地将/DATA/mysql/mysql目录及其所有子目录和文件的所有者和所属组设置为mysql用户和mysql组&#xD;&#xA;sudo chown -R mysql:mysql /DATA/mysql/mysql&#xD;&#xA;# 递归地将/DATA/mysql/mysql目录及其子目录设和文件的权限设置为755&#xD;&#xA;# 755：所有者有读写和执行权限，组用户和其他用户有读和执行权限&#xD;&#xA;sudo chmod -R 755 /DATA/mysql/mysql&#xD;&#xA;# 查找/etc/passwd文件中包含mysql的行 /etc/passwd是系统用户信息文件，包含所有用户的基本信息&#xD;&#xA;grep mysql /etc/passwd&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;操作失误时的可选操作&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 删除用户及其主目录 没有r不删除主目录&#xD;&#xA;sudo userdel -r mysql&#xD;&#xA;# 手动删除主目录&#xD;&#xA;sudo rm -rf /DATA/mysql&#xD;&#xA;# 检查 &#xD;&#xA;grep mysql /etc/passwd&#xD;&#xA;# 删除用户组&#xD;&#xA;sudo groupdel mysql&#xD;&#xA;# 检查用户组是否删除&#xD;&#xA;grep mysql /etc/group&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;docker-compose文件&#34;&gt;&#xD;&#xA;  docker-compose文件&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#docker-compose%e6%96%87%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 创建docker-compose文件在/DATA下，或者追加在已有文件中&#xD;&#xA;vim docker-compose.yml&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;docker-compose.yml&lt;/p&gt;</description>
    </item>
    <item>
      <title>String|StringBuilder|StringBuffer</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/common-class/string-stringbuilder-stringbuffer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/common-class/string-stringbuilder-stringbuffer/</guid>
      <description>&lt;h1 id=&#34;stringstringbuilderstringbuffer&#34;&gt;&#xD;&#xA;  String|StringBuilder|StringBuffer&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#stringstringbuilderstringbuffer&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;string&#34;&gt;&#xD;&#xA;  String&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#string&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;String是不可变字符串对象&lt;/li&gt;&#xA;&lt;li&gt;如果进行修改，会生成一个新的字符串赋给引用&lt;/li&gt;&#xA;&lt;li&gt;由于不可变，所以线程安全&lt;/li&gt;&#xA;&lt;li&gt;String的字面量值会被放入字符串常量池&lt;/li&gt;&#xA;&lt;li&gt;当进行字符串的equals比较，由于String重写了equals方法，调用时是比较每一个char字符来判断是否相等&lt;/li&gt;&#xA;&lt;li&gt;当进行==比较时，比较的是对象的内存地址是否相等&lt;/li&gt;&#xA;&lt;li&gt;如果使用字面量“”== String对象，则实际上比较的是字符串常量池中该字面量的地址和堆中String的地址，结果肯定是不相等&lt;/li&gt;&#xA;&lt;li&gt;当使用==比较两个String，结果也是不相等&lt;/li&gt;&#xA;&lt;li&gt;可以使用String.intern方法取出字符串常量池的地址，从而==判断可以相等&lt;/li&gt;&#xA;&lt;li&gt;当需要比较字符串是否相等时，equals永远是不会出错的方法&lt;/li&gt;&#xA;&lt;li&gt;String a = new String(&amp;ldquo;xx&amp;rdquo;);时，可能出现一个或两个对象，一个在堆里，字面量在常量池&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;stringbuffer&#34;&gt;&#xD;&#xA;  StringBuffer&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#stringbuffer&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;线程安全，append方法加入了synchronized同步锁。效率低&lt;/p&gt;&#xA;&lt;h2 id=&#34;stringbuilder&#34;&gt;&#xD;&#xA;  StringBuilder&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#stringbuilder&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;线程不安全，append方法未加锁，但效率高&lt;/p&gt;</description>
    </item>
    <item>
      <title>线程池的创建和运行逻辑</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/multi-thread/thread-pool/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/multi-thread/thread-pool/</guid>
      <description>&lt;h1 id=&#34;线程池的创建和运行逻辑&#34;&gt;&#xD;&#xA;  线程池的创建和运行逻辑&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%9a%84%e5%88%9b%e5%bb%ba%e5%92%8c%e8%bf%90%e8%a1%8c%e9%80%bb%e8%be%91&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;threadpoolexecutor&#34;&gt;&#xD;&#xA;  ThreadPoolExecutor&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#threadpoolexecutor&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ThreadPoolExecutor executor = new ThreadPoolExecutor(&#xD;&#xA;            2,                   // 核心线程数&#xD;&#xA;            5,                   // 最大线程数&#xD;&#xA;            60,                  // 空闲线程存活时间&#xD;&#xA;            TimeUnit.SECONDS,&#xD;&#xA;            new LinkedBlockingQueue&amp;lt;&amp;gt;(10), // 任务队列&#xD;&#xA;            Executors.defaultThreadFactory(), // 线程工厂&#xD;&#xA;            new ThreadPoolExecutor.CallerRunsPolicy() // 拒绝策略&#xD;&#xA;        );&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;主要参数&#34;&gt;&#xD;&#xA;  主要参数&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%bb%e8%a6%81%e5%8f%82%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;线程池内部使用队列+线程实现&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;coolPoolSize:常驻核心线程数&lt;/li&gt;&#xA;&lt;li&gt;maxPoolSize:能够容纳同时执行的最大线程数&lt;/li&gt;&#xA;&lt;li&gt;keepAliveTime:多余的空闲线程的存活时间&lt;br&gt;&#xA;当线程池数量超过corePoolSize，空闲时间达到keepAliveTime，线程会被销毁到只剩下corePoolSize为止&lt;/li&gt;&#xA;&lt;li&gt;handler：拒绝策略，当线程池超过max时，如何拒绝请求执行的runnable&lt;/li&gt;&#xA;&lt;li&gt;workQueue:任务队列，提交但尚未被执行的任务&lt;/li&gt;&#xA;&lt;li&gt;线程工厂：线程工厂生产线程时可以指定线程的命名规则，可以设置线程分组，设置线程优先级等&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;使用线程池执行任务时：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;如果线程池的数量小于core，即使线程都空闲，也创建新线程处理任务&lt;/li&gt;&#xA;&lt;li&gt;线程池数量等于core，缓冲队列workQueue未满，任务放入任务队列等待&lt;/li&gt;&#xA;&lt;li&gt;大于core，队列满，数量小于max，创建新线程处理任务&lt;/li&gt;&#xA;&lt;li&gt;大于core，队列满，数量等于max，使用拒绝策略拒绝&lt;/li&gt;&#xA;&lt;li&gt;大于 core，空闲时间超过keep，线程被销毁到等于core&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;根据机器和应用设置线程数&#34;&gt;&#xD;&#xA;  根据机器和应用设置线程数&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a0%b9%e6%8d%ae%e6%9c%ba%e5%99%a8%e5%92%8c%e5%ba%94%e7%94%a8%e8%ae%be%e7%bd%ae%e7%ba%bf%e7%a8%8b%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 获取CPU核数&#xD;&#xA;int cpuCores = Runtime.getRuntime().availableProcessors();&#xD;&#xA;# 计算密集型（主要消耗CPU）：线程数 = CPU核数 + 1&#xD;&#xA;int corePoolSize = cpuCores + 1;&#xD;&#xA;int maxPoolSize = cpuCores + 1;&#xD;&#xA;# IO密集型（多IO等待）：线程数 = 2 * CPU核数&#xD;&#xA;int corePoolSize = 2 * cpuCores;&#xD;&#xA;int maxPoolSize = 2 * cpuCores;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;拒绝策略&#34;&gt;&#xD;&#xA;  拒绝策略&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8b%92%e7%bb%9d%e7%ad%96%e7%95%a5&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;AbortPolicy&lt;br&gt;&#xA;拒绝任务直接抛出异常RejectedExecution(RuntimeException)，让调用者感知，根据业务选择重试或放弃&lt;/li&gt;&#xA;&lt;li&gt;DiscardPolicy&lt;br&gt;&#xA;新任务提交后拒绝，不给通知。调用者不知道任务会被丢弃可能造成数据丢失&lt;/li&gt;&#xA;&lt;li&gt;DiscardOldestPolicy&lt;br&gt;&#xA;丢弃任务队列的头节点（通常是存活时间最久的任务），腾出扣减给新提交的任务，也有数据丢失风险&lt;/li&gt;&#xA;&lt;li&gt;CallerRunsPolicy&lt;br&gt;&#xA;把任务交给提交任务的线程执行。被提交的任务不会被丢弃，不会有业务损失；且提交任务的线程被占用，不会快速提交其他任务，减缓了任务提交的速度。线程池有空余时间处理其他任务，腾出空间&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;任务队列&#34;&gt;&#xD;&#xA;  任务队列&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%bb%e5%8a%a1%e9%98%9f%e5%88%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;SynchronousQueue&lt;br&gt;&#xA;直接提交形式的任务队列&lt;br&gt;&#xA;队列中不会有缓存的任务，每个任务已提交就会交给线程执行，如果线程数量达到最大值自然拒绝&lt;/li&gt;&#xA;&lt;li&gt;ArrayBlockingQueue&lt;br&gt;&#xA;有界任务队列，可以指定队列大小&#xA;符合一般的线程池执行逻辑，任务到来先创建线程，达到corePoolSize则写入队列，队列满则继续创建线程消费任务，达到max则执行拒绝策略&lt;/li&gt;&#xA;&lt;li&gt;LinkedBlockingQueue&lt;br&gt;&#xA;无界任务队列，不能指定队列大小，除非系统资源耗尽，否则不存在入队失败的情况。&lt;br&gt;&#xA;线程数达到corePoolSize不再增加，而是直接写入队列&lt;/li&gt;&#xA;&lt;li&gt;PriorityBlockingQueue&lt;br&gt;&#xA;优先任务队列，无界队列&lt;br&gt;&#xA;前面几种队列都是先进先出，这种是后进先出，主张先完成最新提交的任务&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;executors&#34;&gt;&#xD;&#xA;  Executors&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#executors&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;executorsnewfixedthreadpool&#34;&gt;&#xD;&#xA;  Executors.newFixedThreadPool&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#executorsnewfixedthreadpool&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ExecutorService executor = Executors.newFixedThreadPool(3);&#xD;&#xA;executor.submit(() -&amp;gt; {...});&#xD;&#xA;&#xD;&#xA;# Java实现&#xD;&#xA;public static ExecutorService newFixedThreadPool(int nThreads) {&#xD;&#xA;    return new ThreadPoolExecutor(nThreads, nThreads,&#xD;&#xA;                                  0L, TimeUnit.MILLISECONDS,&#xD;&#xA;                                  new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;创建固定数量的线程池：核心线程数和最大线程数固定相等&lt;/li&gt;&#xA;&lt;li&gt;控制可并发的线程数，空闲线程会在队列中等待&lt;/li&gt;&#xA;&lt;li&gt;空闲线程不会被回收。&lt;/li&gt;&#xA;&lt;li&gt;任务队列无界（LinkedBlockingQueue），可能导致 OOM&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;executorsnewcachedthreadpool&#34;&gt;&#xD;&#xA;  Executors.newCachedThreadPool&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#executorsnewcachedthreadpool&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ExecutorService executor = Executors.newCachedThreadPool();&#xD;&#xA;&#xD;&#xA;# Java实现&#xD;&#xA;public static ExecutorService newCachedThreadPool() {&#xD;&#xA;    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,&#xD;&#xA;                                  60L, TimeUnit.SECONDS,&#xD;&#xA;                                  new SynchronousQueue&amp;lt;Runnable&amp;gt;());&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;核心线程数为 0，最大线程数为Integer.MAX_VALUE。&lt;/li&gt;&#xA;&lt;li&gt;空闲线程存活 60 秒，自动回收。&lt;/li&gt;&#xA;&lt;li&gt;适合短时间内大量任务的场景，可能导致资源耗尽&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;executorsnewsinglethreadexecutor&#34;&gt;&#xD;&#xA;  Executors.newSingleThreadExecutor&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#executorsnewsinglethreadexecutor&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ExecutorService executor = Executors.newSingleThreadExecutor();&#xD;&#xA;&#xD;&#xA;# Java实现&#xD;&#xA;public static ExecutorService newSingleThreadExecutor() {&#xD;&#xA;    return new FinalizableDelegatedExecutorService&#xD;&#xA;        (new ThreadPoolExecutor(1, 1,&#xD;&#xA;                                0L, TimeUnit.MILLISECONDS,&#xD;&#xA;                                new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;()));&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;创建单线程线程池&lt;/li&gt;&#xA;&lt;li&gt;始终只有一个工作线程。&lt;/li&gt;&#xA;&lt;li&gt;任务按提交顺序串行执行。&lt;/li&gt;&#xA;&lt;li&gt;保证所有任务按顺序执行，避免多线程并发问题&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;executorsnewscheduledthreadpool&#34;&gt;&#xD;&#xA;  Executors.newScheduledThreadPool&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#executorsnewscheduledthreadpool&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);&#xD;&#xA;&#xD;&#xA;# Java实现&#xD;&#xA;public ScheduledThreadPoolExecutor(int corePoolSize) {&#xD;&#xA;    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,&#xD;&#xA;          new DelayedWorkQueue());&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;# 使用&#xD;&#xA;// a. scheduleAtFixedRate - 固定频率执行（任务开始时间间隔固定）&#xD;&#xA;executor.scheduleAtFixedRate(&#xD;&#xA;    () -&amp;gt; System.out.println(&amp;#34;固定频率任务：&amp;#34; + System.currentTimeMillis()),&#xD;&#xA;    0,         // 初始延迟&#xD;&#xA;    2,         // 周期&#xD;&#xA;    TimeUnit.SECONDS&#xD;&#xA;);&#xD;&#xA;&#xD;&#xA;// b. scheduleWithFixedDelay - 固定延迟执行（任务结束时间与下次开始时间间隔固定）&#xD;&#xA;executor.scheduleWithFixedDelay(&#xD;&#xA;    () -&amp;gt; {&#xD;&#xA;        try {&#xD;&#xA;            Thread.sleep(1500); // 模拟任务耗时&#xD;&#xA;        } catch (InterruptedException e) {&#xD;&#xA;            e.printStackTrace();&#xD;&#xA;        }&#xD;&#xA;        System.out.println(&amp;#34;固定延迟任务：&amp;#34; + System.currentTimeMillis());&#xD;&#xA;    },&#xD;&#xA;    0,         // 初始延迟&#xD;&#xA;    1,         // 延迟时间&#xD;&#xA;    TimeUnit.SECONDS&#xD;&#xA;);&#xD;&#xA;&#xD;&#xA;// c. schedule - 延迟执行一次&#xD;&#xA;executor.schedule(&#xD;&#xA;    () -&amp;gt; System.out.println(&amp;#34;仅执行一次的延迟任务&amp;#34;),&#xD;&#xA;    5,         // 延迟时间&#xD;&#xA;    TimeUnit.SECONDS&#xD;&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;执行定时任务的线程池：支持定时或周期性任务执行&lt;/li&gt;&#xA;&lt;li&gt;scheduleAtFixedReat 固定频率开始任务，以上一次任务的开始时间和这次任务的开始时间间隔固定&lt;/li&gt;&#xA;&lt;li&gt;scheduleWithFixedDelay 固定延迟开始任务，以上一次任务的结束时间和这次任务的开始时间之间固定延迟&lt;/li&gt;&#xA;&lt;li&gt;sechedule 延迟一段时间执行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;executorsnewsinglethreadscheduledexecutor&#34;&gt;&#xD;&#xA;  Executors.newSingleThreadScheduledExecutor&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#executorsnewsinglethreadscheduledexecutor&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();&#xD;&#xA;&#xD;&#xA;# Java实现&#xD;&#xA;public ScheduledThreadPoolExecutor(int corePoolSize) {&#xD;&#xA;    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,&#xD;&#xA;          new DelayedWorkQueue());&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;单线程的定时任务线程池，单线程保证任务按顺序执行&lt;/li&gt;&#xA;&lt;li&gt;适合需要定时执行的顺序任务（如每日数据备份）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;executorsnewworkstealingpool&#34;&gt;&#xD;&#xA;  Executors.newWorkStealingPool&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#executorsnewworkstealingpool&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ExecutorService executor = Executors.newWorkStealingPool();&#xD;&#xA;&#xD;&#xA;# Java实现&#xD;&#xA;public static ExecutorService newWorkStealingPool() {&#xD;&#xA;    return new ForkJoinPool&#xD;&#xA;        (Runtime.getRuntime().availableProcessors(),&#xD;&#xA;         ForkJoinPool.defaultForkJoinWorkerThreadFactory,&#xD;&#xA;         null, true);&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;根据当前CPU情况生成线程池，适用计算密集型应用&lt;/p&gt;</description>
    </item>
    <item>
      <title>访问控制修饰符</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/other/access-modifiers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/other/access-modifiers/</guid>
      <description>&lt;h1 id=&#34;访问控制修饰符&#34;&gt;&#xD;&#xA;  访问控制修饰符&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6%e4%bf%ae%e9%a5%b0%e7%ac%a6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;private：访问权仅限本类&lt;/li&gt;&#xA;&lt;li&gt;default：当前包下任何对象可访问&lt;/li&gt;&#xA;&lt;li&gt;protect：当前包和不同包的子类可以访问&lt;/li&gt;&#xA;&lt;li&gt;public：可以被任何访问&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>CopyOnWriteArrayList</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/collection/CopyOnWriteArrayList/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/collection/CopyOnWriteArrayList/</guid>
      <description>&lt;h1 id=&#34;copyonwritearraylist&#34;&gt;&#xD;&#xA;  CopyOnWriteArrayList&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#copyonwritearraylist&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;数据结构&#34;&gt;&#xD;&#xA;  数据结构&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;相当于一个线程安全的ArrayList，内部存储仍使用数组实现&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public class CopyOnWriteArrayList&amp;lt;E&amp;gt; implements List&amp;lt;E&amp;gt; {&#xD;&#xA;    private transient volatile Object[] array;  // 使用volatile保证可见性&#xD;&#xA;    final transient ReentrantLock lock = new ReentrantLock();  // 写锁&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;线程安全机制&#34;&gt;&#xD;&#xA;  线程安全机制&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e6%9c%ba%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;线程安全通过ReentrantLock实现，允许多线程并发读取，但只允许一个线程写入&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;内部维护final transient 的ReentrantLock对象作为全局锁&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;transient阻止默认序列化&lt;/li&gt;&#xA;&lt;li&gt;volatile保证可见性和有序性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;写操作首先进行加锁，结束后解锁。保证并发写的线程安全。&lt;/li&gt;&#xA;&lt;li&gt;添加新元素时，复制一个新数组，在新数组上添加。而此时并发的读操作则在原数组上进行。通过复制元素读写分离，来保证读写并发的性能。&lt;/li&gt;&#xA;&lt;li&gt;读到的可能不是最新的数据，不适合实时性要求很高的场景。&lt;/li&gt;&#xA;&lt;li&gt;采用写时复制思想（Copy on Write），适合读多写少的并发场景&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;局限性&#34;&gt;&#xD;&#xA;  局限性&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b1%80%e9%99%90%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;内存占用高：每次写操作都创建新数组，可能导致频繁 GC。&lt;br&gt;&#xA;（需要注意大数组情况性能很差）&lt;/li&gt;&#xA;&lt;li&gt;写操作性能差：涉及数组复制，写操作时间复杂度为 O (n)。&lt;br&gt;&#xA;（若需要强一致性且写操作较多，使用 Collections.synchronizedList）&lt;/li&gt;&#xA;&lt;li&gt;弱一致性：读操作可能看不到最新数据，不适合实时性要求高的场景&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>InnoDB 锁机制</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/mysql/innodb_lock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/mysql/innodb_lock/</guid>
      <description>&lt;h1 id=&#34;innodb-锁机制&#34;&gt;&#xD;&#xA;  InnoDB 锁机制&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#innodb-%e9%94%81%e6%9c%ba%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;锁分类和特性&#34;&gt;&#xD;&#xA;  锁分类和特性&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%94%81%e5%88%86%e7%b1%bb%e5%92%8c%e7%89%b9%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;S锁与X锁互斥，与S锁兼容&lt;/li&gt;&#xA;&lt;li&gt;X锁与S/X锁互斥&lt;/li&gt;&#xA;&lt;li&gt;加锁是实际是锁索引或者锁表&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果用了主键就锁聚簇索引&lt;/li&gt;&#xA;&lt;li&gt;如果用了二级索引就锁定二级索引再锁定聚簇索引&lt;/li&gt;&#xA;&lt;li&gt;如果没用到索引，就锁表&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;锁的释放时机是事务提交或回滚&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;行级锁&#34;&gt;&#xD;&#xA;  行级锁&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a1%8c%e7%ba%a7%e9%94%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基本的加锁是临键锁，因为一些条件转换为间隙锁、行锁、表锁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;记录锁sx锁&#34;&gt;&#xD;&#xA;  记录锁（S/X锁）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%ae%b0%e5%bd%95%e9%94%81sx%e9%94%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;单索引值锁&lt;/p&gt;&#xA;&lt;h4 id=&#34;间隙锁s锁&#34;&gt;&#xD;&#xA;  间隙锁（S锁）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%97%b4%e9%9a%99%e9%94%81s%e9%94%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在两行/两索引之间的左开右开区间锁&lt;/li&gt;&#xA;&lt;li&gt;间隙锁S与插入意向锁X互斥，作用是防止其他事务插入数据，避免幻读&lt;/li&gt;&#xA;&lt;li&gt;间隙锁S之间是兼容的&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;临键锁sx记录锁s间隙锁&#34;&gt;&#xD;&#xA;  临键锁（S/X记录锁+s间隙锁）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%b4%e9%94%ae%e9%94%81sx%e8%ae%b0%e5%bd%95%e9%94%81s%e9%97%b4%e9%9a%99%e9%94%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对记录行，以及以记录行本身主键/索引值为右边界，往前一个主键值/索引值为左边界的，左开右闭区间锁&lt;/li&gt;&#xA;&lt;li&gt;临键锁的记录部分与其他临键锁的记录部分根据记录锁的S/X区分冲突&#xA;&lt;ul&gt;&#xA;&lt;li&gt;临键锁的记录部分与其他临键锁的间隙锁不会冲突，不如说不存在加了间隙锁还有记录在中间的情况，也不存在有记录锁居然能加间隙锁的情况&lt;/li&gt;&#xA;&lt;li&gt;临键锁的间隙锁和其他临键锁的间隙锁不冲突&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;插入意向锁x模式间隙锁&#34;&gt;&#xD;&#xA;  插入意向锁（X模式间隙锁）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8f%92%e5%85%a5%e6%84%8f%e5%90%91%e9%94%81x%e6%a8%a1%e5%bc%8f%e9%97%b4%e9%9a%99%e9%94%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;与普通S间隙锁互斥，插入意向锁之间不互斥（特殊）&lt;/li&gt;&#xA;&lt;li&gt;insert插入数据时，需要对所在间隙加插入意向锁，多个事务可以对同一间隙加插入意向锁&lt;/li&gt;&#xA;&lt;li&gt;如果该间隙存在普通间隙锁，则插入意向锁会被阻塞&lt;/li&gt;&#xA;&lt;li&gt;多个事务插入数据，只要对应主键和索引无约束冲突，就可以并发执行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;表级锁&#34;&gt;&#xD;&#xA;  表级锁&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a1%a8%e7%ba%a7%e9%94%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;h4 id=&#34;表锁sx锁&#34;&gt;&#xD;&#xA;  表锁（S/X锁）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a1%a8%e9%94%81sx%e9%94%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当进行需要加锁操作，但是未能明确指定主键/索引时，Innodb会扫描全表，对主键聚簇索引加临键锁（覆盖所有行，等效表锁）&lt;/li&gt;&#xA;&lt;li&gt;或显示使用 Lock Tables xxx write/read (Innodb不推荐，应优先行锁)&lt;/li&gt;&#xA;&lt;li&gt;是极端状态下的行锁集合（全表行锁+间隙锁），性能极差&lt;/li&gt;&#xA;&lt;li&gt;S表锁阻塞各种行X锁，不阻塞S锁。X表锁阻塞各种行X锁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;意向锁isix锁表级信号锁&#34;&gt;&#xD;&#xA;  意向锁（IS/IX锁，表级信号锁）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%84%8f%e5%90%91%e9%94%81isix%e9%94%81%e8%a1%a8%e7%ba%a7%e4%bf%a1%e5%8f%b7%e9%94%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当事务对某行加行级S锁，自动对表加意向共享锁（IS锁）&lt;/li&gt;&#xA;&lt;li&gt;当事务对某行加行级X锁，自动对表加意向排他锁（IX锁）&lt;/li&gt;&#xA;&lt;li&gt;永远与行级S/X锁共存（行锁必然带有对应意向锁）&lt;/li&gt;&#xA;&lt;li&gt;作用仅是标记“表中存在行锁”，以与全表锁互斥，不阻塞其他行锁和表意向锁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;语句加锁情况枚举可重复读级别&#34;&gt;&#xD;&#xA;  语句加锁情况枚举（可重复读级别）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%ad%e5%8f%a5%e5%8a%a0%e9%94%81%e6%83%85%e5%86%b5%e6%9e%9a%e4%b8%be%e5%8f%af%e9%87%8d%e5%a4%8d%e8%af%bb%e7%ba%a7%e5%88%ab&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;可以根据语句加锁情况和对应区域锁的S/X模式，来理论判断锁冲突情况&lt;/p&gt;&#xA;&lt;h3 id=&#34;普通查询&#34;&gt;&#xD;&#xA;  普通查询&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%99%ae%e9%80%9a%e6%9f%a5%e8%af%a2&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不加锁，快照读，不会导致并发阻塞。且因为是快照读，不会幻读&lt;/li&gt;&#xA;&lt;li&gt;基于MVCC进行快照读，查询开始时生成快照，可读取已提交事务和本快照事务修改的数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;select--for-update&#34;&gt;&#xD;&#xA;  SELECT &amp;hellip; FOR UPDATE&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#select--for-update&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;唯一索引等值查询且匹配到数据，对匹配行加行锁（X锁）&lt;/li&gt;&#xA;&lt;li&gt;唯一索引范围查询且匹配到数据，对所有匹配行加临键锁（X记录锁+S间隙锁）&lt;/li&gt;&#xA;&lt;li&gt;唯一索引查询未匹配到数据，目标值所在间隙加间隙锁（S锁）&lt;/li&gt;&#xA;&lt;li&gt;普通索引范围查询匹配到数据，范围内索引项加临键锁（X记录锁+S间隙锁），对应主键行锁（X锁）&lt;/li&gt;&#xA;&lt;li&gt;普通索引查询未匹配到数据，目标值所在间隙加间隙锁（S锁）&lt;/li&gt;&#xA;&lt;li&gt;不使用索引/索引失效，退化为全表锁（各行X锁，间隙S锁）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;select--lock-in-share-mode&#34;&gt;&#xD;&#xA;  SELECT &amp;hellip; LOCK IN SHARE MODE&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#select--lock-in-share-mode&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;唯一索引等值查询且匹配到数据，对匹配行加行锁（S锁）&lt;/li&gt;&#xA;&lt;li&gt;唯一索引范围查询且匹配到数据，对所有匹配行加临键锁（S记录锁+S间隙锁）&lt;/li&gt;&#xA;&lt;li&gt;唯一索引查询未匹配到数据，目标值所在间隙加间隙锁（S锁）&lt;/li&gt;&#xA;&lt;li&gt;普通索引范围查询匹配到数据，范围内索引项加临键锁（S记录锁+S间隙锁），对应主键行锁（S锁）&lt;/li&gt;&#xA;&lt;li&gt;普通索引查询未匹配到数据，目标值所在间隙加间隙锁（S锁）&lt;/li&gt;&#xA;&lt;li&gt;不使用索引/索引失效，退化为全表锁（各行S锁，间隙S锁）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;insert&#34;&gt;&#xD;&#xA;  insert&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#insert&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;单行插入&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;尝试对插入间隙加插入意向锁X锁，如果存在间隙锁S锁，就阻塞等待&lt;/li&gt;&#xA;&lt;li&gt;加锁成功后执行插入，对插入位置加X锁，仅自己能插入，并执行插入&lt;/li&gt;&#xA;&lt;li&gt;如果位置上有别的数据插入的数据，则阻塞等待其他事务提交释放锁&lt;/li&gt;&#xA;&lt;li&gt;多个事务可以并发插入同个间隙的不同位置，不互相阻塞&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;批量插入&#xA;逐行执行多个单行插入，重复上述过程&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;update&#34;&gt;&#xD;&#xA;  update&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#update&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对where条件匹配的行加X锁&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果用了唯一索引（索引扫描），对匹配索引值加记录X锁&lt;/li&gt;&#xA;&lt;li&gt;如果用了普通索引（索引扫描），对匹配索引值加临键X锁&lt;/li&gt;&#xA;&lt;li&gt;如果没有使用索引或者索引失效（全表扫描），对全表加X表锁(所有记录X临键锁)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;如果会更新索引字段，旧索引项加X锁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;delete&#34;&gt;&#xD;&#xA;  delete&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#delete&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对where条件匹配的行加X锁&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果用了唯一索引（索引扫描），对匹配索引值加记录X锁&lt;/li&gt;&#xA;&lt;li&gt;如果用了普通索引（索引扫描），对匹配索引值加临键X锁&lt;/li&gt;&#xA;&lt;li&gt;如果没有使用索引或者索引失效（全表扫描），对全表加X表锁(所有记录X临键锁)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;可以优化的操作方向&#34;&gt;&#xD;&#xA;  可以优化的操作方向&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%af%e4%bb%a5%e4%bc%98%e5%8c%96%e7%9a%84%e6%93%8d%e4%bd%9c%e6%96%b9%e5%90%91&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;测试机检查&#34;&gt;&#xD;&#xA;  测试机检查&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b5%8b%e8%af%95%e6%9c%ba%e6%a3%80%e6%9f%a5&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;测试SQL执行究竟是加表锁还是行锁等，修改以避免表锁&lt;/p&gt;</description>
    </item>
    <item>
      <title>Redis</title>
      <link>https://constructor-md.github.io/codestack/docs/deploy/redis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/deploy/redis/</guid>
      <description>&lt;h1 id=&#34;redis&#34;&gt;&#xD;&#xA;  Redis&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#redis&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;安装版本：7.0.4&lt;/p&gt;&#xA;&lt;p&gt;部署方式：一主二从三哨兵&lt;/p&gt;&#xA;&lt;p&gt;节点分配：每节点一个Redis-Server，一个Sentinel&lt;/p&gt;&#xA;&lt;p&gt;运行方式：docker-compose&lt;/p&gt;&#xA;&lt;h2 id=&#34;目录和用户权限&#34;&gt;&#xD;&#xA;  目录和用户权限&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%9b%ae%e5%bd%95%e5%92%8c%e7%94%a8%e6%88%b7%e6%9d%83%e9%99%90&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;创建redis和sentinel目录&#34;&gt;&#xD;&#xA;  创建Redis和Sentinel目录&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9b%e5%bb%baredis%e5%92%8csentinel%e7%9b%ae%e5%bd%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 存放所有Redis相关文件&#xD;&#xA;sudo mkdir /DATA/redis&#xD;&#xA;# 存放Redis和Sentinel配置文件&#xD;&#xA;sudo mkdir /DATA/redis/config&#xD;&#xA;# 存放Sentinel配置和文件&#xD;&#xA;sudo mkdir /DATA/redis/config/sentinel&#xD;&#xA;# 存放挂载docker内运行Redis的数据目录&#xD;&#xA;sudo mkdir /DATA/redis/data&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;创建redis用户并设置工作目录&#34;&gt;&#xD;&#xA;  创建redis用户并设置工作目录&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9b%e5%bb%baredis%e7%94%a8%e6%88%b7%e5%b9%b6%e8%ae%be%e7%bd%ae%e5%b7%a5%e4%bd%9c%e7%9b%ae%e5%bd%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 创建 redis 用户 设置为不可登陆系统 并设置用户的主目录为/DATA/redis/data&#xD;&#xA;sudo useradd -r -s /sbin/nologin -d /DATA/redis/data redis&#xD;&#xA;# 指定 redis 用户的主目录为/DATA/redis/data&#xD;&#xA;sudo usermod -d /DATA/redis/data redis&#xD;&#xA;# 递归地将/DATA/redis/data目录及其所有子目录和文件的所有者和所属组设置为redis用户和redis组&#xD;&#xA;sudo chown -R redis:redis /DATA/redis/data&#xD;&#xA;# 递归地将/DATA/redis/data目录及其子目录设和文件的权限设置为755&#xD;&#xA;# 755：所有者有读写和执行权限，组用户和其他用户有读和执行权限&#xD;&#xA;sudo chmod -R 755 /DATA/redis/data&#xD;&#xA;# 查找/etc/passwd文件中包含mysql的行 /etc/passwd是系统用户信息文件，包含所有用户的基本信息&#xD;&#xA;grep redis /etc/passwd&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;主节点配置&#34;&gt;&#xD;&#xA;  主节点配置&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%bb%e8%8a%82%e7%82%b9%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;redisconf&#34;&gt;&#xD;&#xA;  redis.conf&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#redisconf&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo vim /DATA/redis/config/redis.conf&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# 监听端口&#xD;&#xA;port 63790&#xD;&#xA;# 访问密码&#xD;&#xA;requirepass password&#xD;&#xA;# 数据库数量 使用cluster模式时只会有一个database即DB0&#xD;&#xA;databases 16&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# 绑定本机的网络接口（网卡） 绑定的是网卡的IP地址&#xD;&#xA;# 0.0.0.0 监听所有 默认127.0.0.1&#xD;&#xA;bind 0.0.0.0&#xD;&#xA;&#xD;&#xA;# 默认开启&#xD;&#xA;# 如果没有设置密码和且没有设置bind，只允许本机访问&#xD;&#xA;protected-mode yes&#xD;&#xA;&#xD;&#xA;# 单位秒，timeout时间内客户端没有数据交互，关闭连接&#xD;&#xA;timeout 60&#xD;&#xA;&#xD;&#xA;# 客户端同时连接的最大数量 默认10000&#xD;&#xA;# 达到最大值时关闭新连接并返回max number of clients reached&#xD;&#xA;maxclients 1000&#xD;&#xA;&#xD;&#xA;# 内存管理 &#xD;&#xA;# 最大内存，推荐最大设置为6GB&#xD;&#xA;# 不要设置过大内存，防止执行RDB内存快照文件或者AOF重写时因为数据太大阻塞太长时间&#xD;&#xA;maxmemory 2GB&#xD;&#xA;&#xD;&#xA;# 内存淘汰策略 默认noeviction&#xD;&#xA;# noeviction -&amp;gt; 不删除任何 key，内存满了直接返回报错&#xD;&#xA;# 默认情况下slave节点会忽略maxmemory配置，除非被提升为master&#xD;&#xA;# 只有master会执行内存淘汰策略，master删除key后会发送DEL指令给slave&#xD;&#xA;maxmemory-policy noeviction&#xD;&#xA;&#xD;&#xA;# 过期key滞留在内存的比例 默认值为1 表示10%&#xD;&#xA;# 设置的越小，一次淘汰周期需要消耗的CPU更多 需要删除更多的过期数据&#xD;&#xA;active-expire-effort 1&#xD;&#xA;&#xD;&#xA;# 持久化&#xD;&#xA;# AOF持久化开启&#xD;&#xA;appendonly yes&#xD;&#xA;&#xD;&#xA;# AOF 持久化模式，默认为 &amp;#34;always&amp;#34;。可以是 always、everysec 或 no&#xD;&#xA;# always：每个写操作都立即同步到磁盘，最费性能&#xD;&#xA;# everysec：每秒钟同步一次到磁盘，折中的选择&#xD;&#xA;# no：完全依赖操作系统的行为，可能会丢失数据，但性能最高&#xD;&#xA;appendfsync everysec&#xD;&#xA;&#xD;&#xA;# AOF-RDB混合持久化&#xD;&#xA;# 配置成yes必须先开启AOF AOF重写生成的文件将同时包含RDB和AOF格式内容&#xD;&#xA;# 推荐开启&#xD;&#xA;aof-use-rdb-preamble yes&#xD;&#xA;&#xD;&#xA;# 性能监控&#xD;&#xA;# 慢查询日志 执行时间只是命令阶段的时间，不包括建立连接发送回复等&#xD;&#xA;# slow log 仅保存在内存中，效率很高&#xD;&#xA;# 执行时间大于多少微秒的查询进行记录 1s = 1,000,000微秒 默认10000&#xD;&#xA;slowlog-log-slower-than 10000&#xD;&#xA;&#xD;&#xA;# 最多保存多少条慢查询日志 slowlog本身是FIFO 默认128&#xD;&#xA;slowlog-max-len 128&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;sentinelconf&#34;&gt;&#xD;&#xA;  sentinel.conf&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#sentinelconf&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo vim /DATA/redis/config/sentinel/sentinel.conf&#xD;&#xA;&#xD;&#xA;# 哨兵端口&#xD;&#xA;port 26379&#xD;&#xA;&#xD;&#xA;# 监控的redis主节点的ip port&#xD;&#xA;# master-name 自定义&#xD;&#xA;# quorum 多少个sentinel主观认为master失联，认为客观上master失联&#xD;&#xA;# sentinel monitor &amp;lt;master-name&amp;gt; &amp;lt;ip&amp;gt; &amp;lt;redis-port&amp;gt; &amp;lt;quorum&amp;gt;&#xD;&#xA;sentinel monitor mymaster 192.168.1.11 63790 2&#xD;&#xA;&#xD;&#xA;# redis实例的密码 主从的访问密码必须要一样&#xD;&#xA;sentinel auth-pass mymaster password&#xD;&#xA;&#xD;&#xA;# 指定多少毫秒之后主节点没有应答哨兵&#xD;&#xA;# 此时哨兵主观上认为主节点下线&#xD;&#xA;# 默认30秒&#xD;&#xA;# sentinel down-after-milliseconds &amp;lt;master-name&amp;gt; &amp;lt;milliseconds&amp;gt;&#xD;&#xA;sentinel down-after-milliseconds mymaster 30000&#xD;&#xA;&#xD;&#xA;# 设置故障转移时，从节点同步新主节点数据的并发数量&#xD;&#xA;# 值越小，对主节点的压力越小，但同步速度可能较慢&#xD;&#xA;# sentinel parallel-syncs &amp;lt;master-name&amp;gt; &amp;lt;numslaves&amp;gt;&#xD;&#xA;sentinel parallel-syncs mymaster 1&#xD;&#xA;&#xD;&#xA;# 设置故障转移的超时时间（单位：毫秒）&#xD;&#xA;# 如果故障转移在这个时间内没有完成，则认为失败&#xD;&#xA;sentinel failover-timeout mymaster 180000&#xD;&#xA;&#xD;&#xA;# 配置哨兵自身的ip 避免走自动检测给出其他哨兵访问不到的地址&#xD;&#xA;sentinel announce-ip 192.168.1.11&#xD;&#xA;sentinel announce-port 36379&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;docker-composeyml&#34;&gt;&#xD;&#xA;  docker-compose.yml&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#docker-composeyml&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo vim /DATA/docker-compose.yml&#xD;&#xA;&#xD;&#xA;version: &amp;#39;3&amp;#39;  # 使用docker-compose版本3&#xD;&#xA;services:  # 定义服务&#xD;&#xA;    redis7:&#xD;&#xA;      image: redis:7.0.4&#xD;&#xA;      container_name: redis7&#xD;&#xA;      user: &amp;#34;996:986&amp;#34;&#xD;&#xA;      restart: always&#xD;&#xA;      ports:&#xD;&#xA;        - 63790:63790&#xD;&#xA;      environment:&#xD;&#xA;        TZ: &amp;#34;Asia/Shanghai&amp;#34;&#xD;&#xA;      volumes:&#xD;&#xA;        - /DATA/redis/config/redis.conf:/etc/redis/redis.conf&#xD;&#xA;        - /DATA/redis/data:/data&#xD;&#xA;      command: [&amp;#34;redis-server&amp;#34;, &amp;#34;/etc/redis/redis.conf&amp;#34;]&#xD;&#xA;    sentinel:&#xD;&#xA;      image: redis:7.0.4&#xD;&#xA;      container_name: sentinel&#xD;&#xA;      restart: always&#xD;&#xA;      ports:&#xD;&#xA;        - 36379:26379&#xD;&#xA;      volumes:&#xD;&#xA;        - /DATA/redis/config/sentinel:/etc/redis/config/sentinel&#xD;&#xA;      environment:&#xD;&#xA;        TZ: &amp;#34;Asia/Shanghai&amp;#34;&#xD;&#xA;      command: [&amp;#34;redis-sentinel&amp;#34;, &amp;#34;/etc/redis/config/sentinel/sentinel.conf&amp;#34;]&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;docker-composeyml语法验证&#34;&gt;&#xD;&#xA;  docker-compose.yml语法验证&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#docker-composeyml%e8%af%ad%e6%b3%95%e9%aa%8c%e8%af%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker-compose config&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;子节点配置&#34;&gt;&#xD;&#xA;  子节点配置&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ad%90%e8%8a%82%e7%82%b9%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;redisconf-1&#34;&gt;&#xD;&#xA;  redis.conf&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#redisconf-1&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo vim /DATA/redis/config/redis.conf&#xD;&#xA;&#xD;&#xA;# 监听端口 sentinel不知道外面映射啥端口，只好把内外端口设置一样&#xD;&#xA;port 63790&#xD;&#xA;# 访问密码&#xD;&#xA;requirepass password&#xD;&#xA;# 数据库数量 使用cluster模式时只会有一个database即DB0&#xD;&#xA;databases 16&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# 绑定本机的网络接口（网卡） 绑定的是网卡的IP地址&#xD;&#xA;# 0.0.0.0 监听所有 默认127.0.0.1&#xD;&#xA;bind 0.0.0.0&#xD;&#xA;&#xD;&#xA;# 默认开启&#xD;&#xA;# 如果没有设置密码和且没有设置bind，只允许本机访问&#xD;&#xA;protected-mode yes&#xD;&#xA;&#xD;&#xA;# 单位秒，timeout时间内客户端没有数据交互，关闭连接&#xD;&#xA;timeout 60&#xD;&#xA;&#xD;&#xA;# 客户端同时连接的最大数量 默认10000&#xD;&#xA;# 达到最大值时关闭新连接并返回max number of clients reached&#xD;&#xA;maxclients 1000&#xD;&#xA;&#xD;&#xA;# 内存管理 &#xD;&#xA;# 最大内存，推荐最大设置为6GB&#xD;&#xA;# 不要设置过大内存，防止执行RDB内存快照文件或者AOF重写时因为数据太大阻塞太长时间&#xD;&#xA;maxmemory 2GB&#xD;&#xA;&#xD;&#xA;# 内存淘汰策略 默认noeviction&#xD;&#xA;# noeviction -&amp;gt; 不删除任何 key，内存满了直接返回报错&#xD;&#xA;# 默认情况下slave节点会忽略maxmemory配置，除非被提升为master&#xD;&#xA;# 只有master会执行内存淘汰策略，master删除key后会发送DEL指令给slave&#xD;&#xA;maxmemory-policy noeviction&#xD;&#xA;&#xD;&#xA;# 过期key滞留在内存的比例 默认值为1 表示10%&#xD;&#xA;# 设置的越小，一次淘汰周期需要消耗的CPU更多 需要删除更多的过期数据&#xD;&#xA;active-expire-effort 1&#xD;&#xA;&#xD;&#xA;# 持久化&#xD;&#xA;# AOF持久化开启&#xD;&#xA;appendonly yes&#xD;&#xA;&#xD;&#xA;# AOF 持久化模式，默认为 &amp;#34;always&amp;#34;。可以是 always、everysec 或 no&#xD;&#xA;# always：每个写操作都立即同步到磁盘，最费性能&#xD;&#xA;# everysec：每秒钟同步一次到磁盘，折中的选择&#xD;&#xA;# no：完全依赖操作系统的行为，可能会丢失数据，但性能最高&#xD;&#xA;appendfsync everysec&#xD;&#xA;&#xD;&#xA;# AOF-RDB混合持久化&#xD;&#xA;# 配置成yes必须先开启AOF AOF重写生成的文件将同时包含RDB和AOF格式内容&#xD;&#xA;# 推荐开启&#xD;&#xA;aof-use-rdb-preamble yes&#xD;&#xA;&#xD;&#xA;# 性能监控&#xD;&#xA;# 慢查询日志 执行时间只是命令阶段的时间，不包括建立连接发送回复等&#xD;&#xA;# slow log 仅保存在内存中，效率很高&#xD;&#xA;# 执行时间大于多少微秒的查询进行记录 1s = 1,000,000微秒 默认10000&#xD;&#xA;slowlog-log-slower-than 10000&#xD;&#xA;&#xD;&#xA;# 最多保存多少条慢查询日志 slowlog本身是FIFO 默认128&#xD;&#xA;slowlog-max-len 128&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# 主从复制&#xD;&#xA;# replicaof &amp;lt;masterip&amp;gt; &amp;lt;masterport&amp;gt;将当前实例成为master的从节点&#xD;&#xA;replicaof 192.168.1.11 63790&#xD;&#xA;&#xD;&#xA;# master节点的requiepass&#xD;&#xA;masterauth **********&#xD;&#xA;&#xD;&#xA;# 从节点只读，默认为yes，建议保留默认配置&#xD;&#xA;replica-read-only yes&#xD;&#xA;&#xD;&#xA;# slave每10s Ping一次master&#xD;&#xA;repl-ping-replica-period 10&#xD;&#xA;&#xD;&#xA;# slave与master之间的复制超时时间，默认60s&#xD;&#xA;repl-timeout 60&#xD;&#xA;&#xD;&#xA;# slave优先级 哨兵使用 默认100&#xD;&#xA;# master节点挂掉，哨兵选择priority最小的slave节点作为新的master&#xD;&#xA;replica-priority 100&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;sentinelconf-1&#34;&gt;&#xD;&#xA;  sentinel.conf&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#sentinelconf-1&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo scp -P 2222 quanta@192.168.1.11:/DATA/redis/config/sentinel.conf /DATA/redis/config/sentinel.conf&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修改配置sentinel ip&lt;/p&gt;</description>
    </item>
    <item>
      <title>Spring事务</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/spring/transaction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/spring/transaction/</guid>
      <description>&lt;h1 id=&#34;spring事务&#34;&gt;&#xD;&#xA;  Spring事务&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring%e4%ba%8b%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;事务实现&#34;&gt;&#xD;&#xA;  事务实现&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8b%e5%8a%a1%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;基于数据库事务和AOP&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;对于使用了@Transactional注解的Bean，创建代理对象&lt;/li&gt;&#xA;&lt;li&gt;当调用代理对象的方法时，如果方法上有@Transactional注解，利用事务管理器创建一个数据库连接&lt;/li&gt;&#xA;&lt;li&gt;修改数据库连接的autocommit属性为false，禁止此连接自动提交&lt;/li&gt;&#xA;&lt;li&gt;执行当前方法，方法中会包含sql，没有异常就直接提交事务&lt;/li&gt;&#xA;&lt;li&gt;出现异常且需要回滚则回滚事务，不需要回滚就仍然提交事务&lt;/li&gt;&#xA;&lt;li&gt;Spring的事务隔离级别就是数据库的隔离级别&lt;/li&gt;&#xA;&lt;li&gt;Spring事务的传播机制时Spring事务自己实现的，有很多种。用于设置不同场景下，对嵌套方法是否该用同一个事务执行的情况进行支持&lt;/li&gt;&#xA;&lt;li&gt;传播机制是通过数据库连接来实现的，每个数据库连接一个事务，当传播机制配置为应该需要新开一个事务，实际上就是为方法新建一个数据库连接，在新连接上执行SQL。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;默认事务传播机制是：REQUIRED，如果存在事务则加入，不存在则创建&lt;/p&gt;&#xA;&lt;h2 id=&#34;事务传播机制&#34;&gt;&#xD;&#xA;  事务传播机制&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8b%e5%8a%a1%e4%bc%a0%e6%92%ad%e6%9c%ba%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;事务传播机制指的是当事务方法被调用时，事务如何传播&lt;/p&gt;&#xA;&lt;p&gt;传播机制的指定：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    @Transactional(propagation = Propagation.REQUIRED)&#xD;&#xA;    public void calledMethod() {&#xD;&#xA;&#xD;&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;propagation_required默认&#34;&gt;&#xD;&#xA;  PROPAGATION_REQUIRED（默认）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#propagation_required%e9%bb%98%e8%ae%a4&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果调用方法不存在事务，则创建一个事务&lt;br&gt;&#xA;从数据源获取一个新的数据库连接并开启新事务&lt;/li&gt;&#xA;&lt;li&gt;如果调用方法有事务，则加入该事务&lt;br&gt;&#xA;也就是不做处理，复用当前的数据库连接和事务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;效果：存在且仅存在一个事务，回滚到最开始事务创建时&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;调用方有事务，和调用方一起作为原子操作&lt;/li&gt;&#xA;&lt;li&gt;调用方没有事务，自己是原子操作&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;propagation_supports&#34;&gt;&#xD;&#xA;  PROPAGATION_SUPPORTS&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#propagation_supports&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果调用方法不存在事务，以非事务方式运行&lt;br&gt;&#xA;获取数据源连接执行SQL，但不开启事务&lt;/li&gt;&#xA;&lt;li&gt;如果调用方法有事务，则加入该事务&lt;br&gt;&#xA;复用当前的数据库连接和事务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;效果：遵从被调用方的决定，有就用，没有也不开&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;调用方有事务，和调用方一起作为原子操作&lt;/li&gt;&#xA;&lt;li&gt;调用方没有事务，都不是原子操作&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;propagation_mandatory&#34;&gt;&#xD;&#xA;  PROPAGATION_MANDATORY&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#propagation_mandatory&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果调用方法不存在事务，抛出异常&lt;br&gt;&#xA;发现当前没有事务，抛出 IllegalTransactionStateException 异常 即要求必须在事务环境下执行&lt;/li&gt;&#xA;&lt;li&gt;如果调用方法有事务，则加入该事务&lt;br&gt;&#xA;复用当前的数据库连接和事务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;效果：必须有事务才能调用该方法&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;调用方有事务，和调用方一起作为原子操作&lt;/li&gt;&#xA;&lt;li&gt;调用方没有事务，报错&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;propagation_requires_new&#34;&gt;&#xD;&#xA;  PROPAGATION_REQUIRES_NEW&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#propagation_requires_new&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果调用方法不存在事务，则创建一个新事务 &lt;br&gt;&#xA;从数据源获取一个新的数据库连接并开启新事务&lt;/li&gt;&#xA;&lt;li&gt;如果调用方法有事务，挂起当前事务，并创建新事务执行&lt;br&gt;&#xA;挂起调用者事务，获取新的链接并开启新事务，执行完毕后，回复调用者的事务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;效果：不管调用方有无事务，自己都是单独事务执行&#xA;调用方和自己是两个原子，报错不影响调用方，也不被调用方影响&lt;/p&gt;</description>
    </item>
    <item>
      <title>封装|继承|多态</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/other/encap-inher-poly/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/other/encap-inher-poly/</guid>
      <description>&lt;h1 id=&#34;封装继承多态&#34;&gt;&#xD;&#xA;  封装|继承|多态&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b0%81%e8%a3%85%e7%bb%a7%e6%89%bf%e5%a4%9a%e6%80%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;封装&#34;&gt;&#xD;&#xA;  封装&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b0%81%e8%a3%85&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;说明一个类的属性或行为与其他类的关系&lt;br&gt;&#xA;隐藏了类的内部实现机制，使得可以在不影响使用的情况下，改变类的内部结构，同时也保护了数据&lt;br&gt;&#xA;对于外界而言，内部细节被隐藏，暴露出来的仅是访问方法&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;属性的封装：&lt;br&gt;&#xA;使用者只能通过事先定制好的方法来访问数据，可以方便地加入逻辑控制，限制对属性的不合理操作&lt;/li&gt;&#xA;&lt;li&gt;方法的封装：&lt;br&gt;&#xA;使用者按照既定的方式调用方法，不必关心方法的内部实现，便于使用、便于修改、增加代码的可维护性&lt;br&gt;&#xA;目标是实现低耦合，高内聚&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;继承&#34;&gt;&#xD;&#xA;  继承&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%a7%e6%89%bf&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;从已有的类派生出新的类，新的类吸收已有类的数据属性和行为，并可以扩展新的能力&lt;br&gt;&#xA;本质上是特殊到一般的关系，即is-a关系&lt;br&gt;&#xA;子类继承父类，表明子类是一种特殊的父类，并具备父类不具有的一些属性或方法。&lt;br&gt;&#xA;从多种实现类中抽象出一个基类，使其具备多种实现类的共同特性，当实现类使用extends关键字继承了基类后，实现类就具备了这些相同的属性&lt;br&gt;&#xA;继承的类叫子类（派生类或超类），被继承的类叫做父类（或基类）&lt;br&gt;&#xA;Java通过extends关键字实现继承，父类中private定义的变量和方法不会被继承，不能在子类中直接操作父类通过private定义的变量以及方法。&lt;br&gt;&#xA;继承避免了对一般类和特殊类之间共同特征进行的重复描述，通过继承可以清晰地表达每一项共同特征所适应的概念范围。在一般类中定义的属性和操作&lt;br&gt;&#xA;适用于这个类本身和它以下的每一层特殊类的全部对象。&lt;br&gt;&#xA;运用继承原则使得系统模型清晰简练&lt;/p&gt;&#xA;&lt;h2 id=&#34;多态&#34;&gt;&#xD;&#xA;  多态&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a4%9a%e6%80%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;指的是类与类之间的关系&lt;br&gt;&#xA;两个类之间由继承关系，存在方法的重写。于是可以在调用时由父类引用指向子类对象。&lt;br&gt;&#xA;多态必备三个要素：继承、重写、父类引用指向子类对象&lt;/p&gt;&#xA;&lt;h2 id=&#34;为什么这些特性可以让我们写出更好的代码&#34;&gt;&#xD;&#xA;  为什么这些特性可以让我们写出更好的代码？&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%bf%99%e4%ba%9b%e7%89%b9%e6%80%a7%e5%8f%af%e4%bb%a5%e8%ae%a9%e6%88%91%e4%bb%ac%e5%86%99%e5%87%ba%e6%9b%b4%e5%a5%bd%e7%9a%84%e4%bb%a3%e7%a0%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;封装：增加代码可复用性&lt;/li&gt;&#xA;&lt;li&gt;继承：增加代码可复用性，使得系统模型更加清晰，减少重复描述&lt;/li&gt;&#xA;&lt;li&gt;多态：增加代码灵活性，实现随便变，都可以通过统一的父类引用来调用实际对象方法&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>比较对象相等</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/common-class/object-equals/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/common-class/object-equals/</guid>
      <description>&lt;h1 id=&#34;比较对象相等&#34;&gt;&#xD;&#xA;  比较对象相等&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%af%94%e8%be%83%e5%af%b9%e8%b1%a1%e7%9b%b8%e7%ad%89&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;对于8种基本数据类型，==比较的是操作数的值之间的关系&lt;br&gt;&#xA;其余一切皆是对象，==比较的是内存地址&lt;br&gt;&#xA;由Object继承来的equals方法比较的是内存地址&lt;/p&gt;&#xA;&lt;p&gt;Object规范约定：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果两个对象通过equals方法比较是相等的，则hashcode方法结果值必须相等&lt;/li&gt;&#xA;&lt;li&gt;如果两个对象通过equals方法比较不相等，则不要求hashcode方法结果相等&#xA;当一个程序执行过程中，equals方法没有修改任何信息，同一个对象上重复调用hashcode方法，必须返回相同值&lt;br&gt;&#xA;两个应用互相调用，则hascode可以不一致。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这意味着，当我们要重写equals方法时，必须重写hashcode方法。&lt;br&gt;&#xA;否则可能违反：同一对象的hashcode值必须相等的约定&lt;br&gt;&#xA;会使得一些使用hashcode的类使用出现问题&lt;br&gt;&#xA;如HashMap，存入时会调用类自身的hashcode方法得到hashcode；&lt;/p&gt;</description>
    </item>
    <item>
      <title>泛型</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/other/generics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/other/generics/</guid>
      <description>&lt;h1 id=&#34;泛型&#34;&gt;&#xD;&#xA;  泛型&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b3%9b%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;为什么需要泛型&#34;&gt;&#xD;&#xA;  为什么需要泛型&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e6%b3%9b%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;以集合为例，如果写死类型，集合就不通用，只能放某个类或者子类&lt;br&gt;&#xA;但是实际上，一个集合的设计需要给所有类型使用，包括未知的用户自定义类型&lt;/p&gt;&#xA;&lt;p&gt;如果使用 Object 代替，存储时方便，取出时需要显式强制类型转换&lt;br&gt;&#xA;与此同时，集合中还可以存放多种类型数据，导致强转、具体操作等均不安全&lt;br&gt;&#xA;如果判断类型再强转，会增加代码复杂度&lt;br&gt;&#xA;（Object 没有限制范围的能力）&lt;/p&gt;&#xA;&lt;p&gt;如果考虑存放时限制类型，但只能限制自己的编码，如果存在多人编码，调用自己的集合，获取到的数据可能就不是安全的类型。久而久之自己都可能忘记&lt;/p&gt;&#xA;&lt;p&gt;如果将某个类型对某种集合的操作封装起来，使用封装类操作集合，则导致有多少类型就要封装多少个集合操作类，代码超级冗余，且只能处理已有类型，不能处理新类型。导致只要一个新类要用集合，就要写一个封装类，不可取&lt;/p&gt;&#xA;&lt;p&gt;从根本上来说，泛型是为了实现Java面向对象环境下，类之间容纳未知类的安全操作能力，以解决上述问题带来的编码困境&lt;/p&gt;&#xA;&lt;p&gt;比如，在某个对象新建时就指定了泛型参数&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;该对象的方法只能使用指定类型，避免乱传参数&lt;/li&gt;&#xA;&lt;li&gt;编译时就会报错，避免运行时出问题&lt;/li&gt;&#xA;&lt;li&gt;取用元素也不必转换&lt;/li&gt;&#xA;&lt;li&gt;可以编写一套代码，适用所有类型&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;泛型方法&#34;&gt;&#xD;&#xA;  泛型方法&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b3%9b%e5%9e%8b%e6%96%b9%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;泛型方法可以定义在泛型类，也可以定义在普通类&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class A&amp;lt;T&amp;gt; {&#xD;&#xA;  public void method(T t) {&#xD;&#xA;    // do something...&#xD;&#xA;  }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;class A {&#xD;&#xA;  public &amp;lt;T&amp;gt; void method(T t) {&#xD;&#xA;    // do something...&#xD;&#xA;  }&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;定义泛型方法需要在泛型类前面指定泛型参数，从而在方法中使用具体泛型参数，或者在泛型方法前定义&lt;br&gt;&#xA;但使用时不需要手动指定具体类型，会根据调用进行类型推断&lt;br&gt;&#xA;如果是基本类型，会自动装箱为包装类&lt;/p&gt;&#xA;&lt;p&gt;由于静态类型方法不能访问类上定义的泛型参数，因为类上的泛型参数只能在对象实例化时指定，所以静态方法要使用泛型就必须定义成泛型方法&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class A {&#xD;&#xA;  public static &amp;lt;T&amp;gt; void method(T t) {&#xD;&#xA;    // do something...&#xD;&#xA;  }&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;类型擦除&#34;&gt;&#xD;&#xA;  类型擦除&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b1%bb%e5%9e%8b%e6%93%a6%e9%99%a4&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;List&amp;lt;String&amp;gt; strings = new ArrayList&amp;lt;&amp;gt;();&#xD;&#xA;List&amp;lt;Integer&amp;gt; ints = new ArrayList&amp;lt;&amp;gt;();&#xD;&#xA;Println(ints.getClass() == strings.getClass())&#xD;&#xA;# 结果为true。仿佛类型参数不存在&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是因为：&lt;/p&gt;</description>
    </item>
    <item>
      <title>线程中断</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/multi-thread/thread-interrupt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/multi-thread/thread-interrupt/</guid>
      <description>&lt;h1 id=&#34;线程中断&#34;&gt;&#xD;&#xA;  线程中断&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e4%b8%ad%e6%96%ad&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;如何中断线程&#34;&gt;&#xD;&#xA;  如何中断线程？&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a6%82%e4%bd%95%e4%b8%ad%e6%96%ad%e7%ba%bf%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;调用线程对象的interrupt方法中断指定线程&lt;/p&gt;&#xA;&lt;h2 id=&#34;如何判断当前线程是否被中断&#34;&gt;&#xD;&#xA;  如何判断当前线程是否被中断？&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a6%82%e4%bd%95%e5%88%a4%e6%96%ad%e5%bd%93%e5%89%8d%e7%ba%bf%e7%a8%8b%e6%98%af%e5%90%a6%e8%a2%ab%e4%b8%ad%e6%96%ad&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;调用线程对象的isInterrupted方法&lt;/p&gt;&#xA;&lt;h2 id=&#34;线程中断线程就停止了吗&#34;&gt;&#xD;&#xA;  线程中断线程就停止了吗？&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e4%b8%ad%e6%96%ad%e7%ba%bf%e7%a8%8b%e5%b0%b1%e5%81%9c%e6%ad%a2%e4%ba%86%e5%90%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;程序中，我们不能随便中断一个线程，因为十分不安全，因为我们不知道线程当前处于何种状态&lt;br&gt;&#xA;强行中断可能会导致锁不能释放、操作数据库可能导致事务无法提交等&lt;br&gt;&#xA;Java中将线程的Stop方法设置为过时，禁止使用。&lt;br&gt;&#xA;当我们执行线程的interrupt方法时，本质不是中断线程，而是设置一个标志位&lt;br&gt;&#xA;当一个线程的interrupt方法被调用：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;如果线程当前阻塞，如io、wait，会立马退出阻塞，并抛出Interruption异常，我们通过捕获Interruption异常，做一定处理，然后让线程结束方法退出&lt;/li&gt;&#xA;&lt;li&gt;如果线程在运行中，则不受影响继续运行。仅仅是线程的中断标记被设置为true，需要线程自己在适当的位置检查isInterrupted方法来查看自己是否被中断，并作退出操作&lt;/li&gt;&#xA;&lt;li&gt;值得一提的是，Thread.isInterrupted() 判断中断异常后，中断标志位会变为false，相当于中断标志位被清空。如果后面还想判断执行停止，此时需要手动再次中断或者设置标志位&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# Java实现 Thread类&#xD;&#xA;public static boolean interrupted() {&#xD;&#xA;    return currentThread().isInterrupted(true);&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;public boolean isInterrupted() {&#xD;&#xA;    return isInterrupted(false);&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;private native boolean isInterrupted(boolean ClearInterrupted);&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;如果一个任务创建了线程池来执行子任务需要中断主任务和子任务&#34;&gt;&#xD;&#xA;  如果一个任务创建了线程池来执行子任务，需要中断主任务和子任务&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a6%82%e6%9e%9c%e4%b8%80%e4%b8%aa%e4%bb%bb%e5%8a%a1%e5%88%9b%e5%bb%ba%e4%ba%86%e7%ba%bf%e7%a8%8b%e6%b1%a0%e6%9d%a5%e6%89%a7%e8%a1%8c%e5%ad%90%e4%bb%bb%e5%8a%a1%e9%9c%80%e8%a6%81%e4%b8%ad%e6%96%ad%e4%b8%bb%e4%bb%bb%e5%8a%a1%e5%92%8c%e5%ad%90%e4%bb%bb%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;则在主任务的中断操作中，调用线程池的中断方法停止线程池&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;shutdown方法&lt;br&gt;&#xA;拒接新任务，新任务提交时执行拒绝策略。&lt;br&gt;&#xA;但是队列中的任务仍会继续执行直到完毕，中断空闲线程&lt;/li&gt;&#xA;&lt;li&gt;shutdownNow方法&lt;br&gt;&#xA;拒接新任务，新任务提交执行拒绝策略。 &lt;br&gt;&#xA;调用所有线程的interrupt方法进行终端，子任务需要自己执行结束任务。&lt;br&gt;&#xA;任务队列中的任务不会继续执行，并返回被抛弃的任务List&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>雪崩|限流|熔断|降级</title>
      <link>https://constructor-md.github.io/codestack/docs/project/server-runtime-excption/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/project/server-runtime-excption/</guid>
      <description>&lt;h1 id=&#34;雪崩限流熔断降级&#34;&gt;&#xD;&#xA;  雪崩|限流|熔断|降级&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%9b%aa%e5%b4%a9%e9%99%90%e6%b5%81%e7%86%94%e6%96%ad%e9%99%8d%e7%ba%a7&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;服务雪崩&#34;&gt;&#xD;&#xA;  服务雪崩：&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9c%8d%e5%8a%a1%e9%9b%aa%e5%b4%a9&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;A 调用 B，B 调用 C&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果大量请求突然到 A，如果 A 撑住了，则 A 会将压力传导到 C&lt;/li&gt;&#xA;&lt;li&gt;如果 C 撑不住，则 C 会请求堆积，从而 B 请求堆积，从而 A 不可用&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;解决方式是服务降级和服务熔断&lt;/p&gt;&#xA;&lt;h2 id=&#34;服务限流&#34;&gt;&#xD;&#xA;  服务限流：&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9c%8d%e5%8a%a1%e9%99%90%e6%b5%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;高并发下，为了保护系统，可以对访问服务的请求进行数量上的限制，防止系统不被大量请求压垮&lt;/p&gt;&#xA;&lt;h2 id=&#34;服务熔断&#34;&gt;&#xD;&#xA;  服务熔断：&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9c%8d%e5%8a%a1%e7%86%94%e6%96%ad&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;服务 A 调用的某个服务 B 不可用时，A 为了保证自己不受影响，不再调用服务 B，直接返回一个结果，减轻两个服务的压力，直到 B 恢复&lt;/p&gt;&#xA;&lt;h2 id=&#34;服务降级&#34;&gt;&#xD;&#xA;  服务降级：&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9c%8d%e5%8a%a1%e9%99%8d%e7%ba%a7&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;发现系统压力过载时，通过关闭某个服务或限流减轻系统压力&lt;/p&gt;&#xA;&lt;h2 id=&#34;理解&#34;&gt;&#xD;&#xA;  理解&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%90%86%e8%a7%a3&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;都是为了防止系统崩溃，都会让用户体验到某些功能暂不可用&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;熔断是下游服务故障触发&lt;/li&gt;&#xA;&lt;li&gt;降级是为了主动降低系统负载&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>ArrayList|LinkedList</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/collection/ArrayList-LinkedList/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/collection/ArrayList-LinkedList/</guid>
      <description>&lt;h1 id=&#34;arraylist-和-linkedlist&#34;&gt;&#xD;&#xA;  ArrayList 和 LinkedList&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#arraylist-%e5%92%8c-linkedlist&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;arraylist&#34;&gt;&#xD;&#xA;  ArrayList&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#arraylist&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;ArrayList是一个可扩容的，底层用数组实现的，非线程安全的集合类&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;实现RamdonAsceess接口，无实质内容，声明性质，表明ArrayList支持随机访问&lt;/li&gt;&#xA;&lt;li&gt;实现Cloneable，声明需要复写clone()接口，且可以支持克隆&lt;/li&gt;&#xA;&lt;li&gt;实现Serializable，声明可序列化&lt;/li&gt;&#xA;&lt;li&gt;初始容量10，最大容量Integer.MAX_VALUE - 8。&lt;/li&gt;&#xA;&lt;li&gt;出现可能越界的操作时检查是否需要扩容，每次扩容为原来的1.5倍&lt;/li&gt;&#xA;&lt;li&gt;内部维护元素的数组使用transient修饰，阻止默认的序列化和反序列化。原因是大多情况下数组不是满的，默认的序列化会把空的部分也序列化进去。ArrayList自己实现了合适的序列化和反序列化方法&lt;/li&gt;&#xA;&lt;li&gt;内部维护一个自增变量，记录修改的次数，添加、删除、扩容都会使操作数++，相当于版本号。作用是在迭代器遍历过程中检查数组是否被修改，迭代器遍历过程中是禁止修改的。只要版本号不对，就会抛出异常，这就是fail-fast&lt;/li&gt;&#xA;&lt;li&gt;扩容方法是新建一个更大容量的数组，然后将元素复制过去。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;linkedlist&#34;&gt;&#xD;&#xA;  LinkedList&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#linkedlist&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;LinkedList一个内部用双向链表实现的List，同时实现了Deque接口，可以当作队列或者栈来使用。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;实现Cloneable和Serializable，可以被克隆也可以被序列化&lt;/li&gt;&#xA;&lt;li&gt;克隆时和ArrayList一样是浅拷贝&lt;/li&gt;&#xA;&lt;li&gt;实现了Deque接口，支持两端的元素插入和删除&lt;/li&gt;&#xA;&lt;li&gt;继承AbstractSequential类，声明支持按次序访问&lt;/li&gt;&#xA;&lt;li&gt;内部维护头节点和尾节点，以及元素个数&lt;/li&gt;&#xA;&lt;li&gt;内部静态类Node包含元素、前驱和后继节点&lt;/li&gt;&#xA;&lt;li&gt;支持从头部、尾部、任意位置添加、删除元素&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;对比&#34;&gt;&#xD;&#xA;  对比&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%b9%e6%af%94&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;ArrayList是数组，LinkedList是链表&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基于数组的ArrayList，底层连续存储&lt;br&gt;&#xA;知道第一个元素的位置就可以通过索引快速访问到后续元素，随机查找速度O(1)&lt;br&gt;&#xA;删除数据和插入数据可能需要重排数据中的所有数据或者是更新索引，开销大O(n)&lt;br&gt;&#xA;ArrayList需要扩容，每次扩容会备用一些没被使用的数组空间&lt;/li&gt;&#xA;&lt;li&gt;基于链表的LinkedList，底层可以离散存储&lt;br&gt;&#xA;每个节点存储数据、前一个元素引用、后一个元素引用&#xA;增删时不需要像数组那样重新计算大小或者更新索引，增删速度O(1)&lt;br&gt;&#xA;查询需要逐个元素直到找到，效率低O(n)&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Bean 生命周期与 SpringBoot 扩展点</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/spring/bean-liftcycle-and-extension/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/spring/bean-liftcycle-and-extension/</guid>
      <description>&lt;h1 id=&#34;bean-生命周期与-springboot-扩展点&#34;&gt;&#xD;&#xA;  Bean 生命周期与 SpringBoot 扩展点&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#bean-%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e4%b8%8e-springboot-%e6%89%a9%e5%b1%95%e7%82%b9&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;生命周期：&lt;br&gt;&#xA;从对象的创建到销毁的过程&lt;/p&gt;&#xA;&lt;p&gt;从 SpringBootApplication.run 方法出发，执行到 AbstractApplication.refresh 方法&lt;br&gt;&#xA;从此处开始进行 BeanFactory 等资源的准备、XML/注解的扫描&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Spring 创建 BeanFactory ，工厂扫描 XML、Java 注解等，生成 BeanDefinition 对象&lt;/li&gt;&#xA;&lt;li&gt;调用工厂方法根据 BeanDefinition 对象通过反射生成 Bean 实例，完成实例化&lt;/li&gt;&#xA;&lt;li&gt;Spring 将值和 Bean 引用注入到 Bean 对应属性&lt;/li&gt;&#xA;&lt;li&gt;如果 Bean 实现了 BeanNameAware 接口，Spring 将 Bean 的 ID 传递给 setBeanName 方法&lt;/li&gt;&#xA;&lt;li&gt;如果 Bean 实现了 BeanFactoryAware 接口，Spring 调用 setBeanFactory 将 BeanFactory 实例传入&lt;/li&gt;&#xA;&lt;li&gt;如果 Bean 实现了 ApplicationContextAware 接口，Spring 调用 setApplicationAware 将应用上下文传入&lt;/li&gt;&#xA;&lt;li&gt;如果 Bean 实现了 BeanPostProcessor 接口，Spring 调用 postProcessBeforeInitialization 方法&lt;/li&gt;&#xA;&lt;li&gt;如果 Bean 中有 @PostConstruct 方法，执行该方法&lt;/li&gt;&#xA;&lt;li&gt;如果 Bean 实现了 InitilizingBean 接口，Spring 调用 afterPropertiesSet 方法；如果 @Bean 声明了 initMethod，Spring 再调用该方法&lt;/li&gt;&#xA;&lt;li&gt;如果 Bean 实现了 BeanPostProcessor 接口，Spring 调用 postProcessorAfterInitialization 方法&lt;/li&gt;&#xA;&lt;li&gt;此时 Bean 的属性已经设置和前后置操作完毕，完成了初始化。Bean 将一直存在于应用上下文中，直到应用上下文被销毁&lt;/li&gt;&#xA;&lt;li&gt;如果 Bean 中有 @PreDestory 方法，执行该方法&lt;/li&gt;&#xA;&lt;li&gt;如果 Bean 实现了 DisposableBean 接口，Spring 将调用 destory 方法。如果 @Bean 声明了 destoryMethod，Spring 再调用该方法。&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>ElasticSearch</title>
      <link>https://constructor-md.github.io/codestack/docs/deploy/elasticsearch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/deploy/elasticsearch/</guid>
      <description>&lt;h1 id=&#34;elasticsearch&#34;&gt;&#xD;&#xA;  ElasticSearch&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#elasticsearch&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;安装版本：8.15.0&lt;/p&gt;&#xA;&lt;p&gt;部署方式：三节点&lt;/p&gt;&#xA;&lt;p&gt;运行方式：docker-compose&lt;/p&gt;&#xA;&lt;h2 id=&#34;linux系统设置&#34;&gt;&#xD;&#xA;  Linux系统设置&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#linux%e7%b3%bb%e7%bb%9f%e8%ae%be%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 修改内核参数&#xD;&#xA;# 设置每个进程最多拥有的最大内存映射区域数量 默认65536对ES来说不足&#xD;&#xA;echo &amp;#34;vm.max_map_count=262144&amp;#34; | sudo tee -a /etc/sysctl.conf&#xD;&#xA;sudo sysctl -p&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;创建目录&#34;&gt;&#xD;&#xA;  创建目录&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9b%e5%bb%ba%e7%9b%ae%e5%bd%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo mkdir /DATA/es /DATA/es/data /DATA/es/logs /DATA/es/plugins /DATA/es/config&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;权限设置&#34;&gt;&#xD;&#xA;  权限设置&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9d%83%e9%99%90%e8%ae%be%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo chmod -R 777 /DATA/es/data /DATA/es/logs /DATA/es/plugins /DATA/es/config&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;各单节点启动获取官方配置&#34;&gt;&#xD;&#xA;  各单节点启动获取官方配置&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%90%84%e5%8d%95%e8%8a%82%e7%82%b9%e5%90%af%e5%8a%a8%e8%8e%b7%e5%8f%96%e5%ae%98%e6%96%b9%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo vim /DATA/docker-compose.yml&#xD;&#xA;&#xD;&#xA;version: &amp;#39;3&amp;#39;&#xD;&#xA;services:&#xD;&#xA;  es:&#xD;&#xA;      image: docker.elastic.co/elasticsearch/elasticsearch:8.15.0&#xD;&#xA;      container_name: es&#xD;&#xA;      restart: always&#xD;&#xA;      environment:&#xD;&#xA;        - &amp;#34;ES_JAVA_OPTS=-Xms4g -Xmx4g&amp;#34; # 宿主机最大内存的一半 再留点给其他应用&#xD;&#xA;        - &amp;#34;ELASTIC_PASSWORD=********&amp;#34;&#xD;&#xA;        - &amp;#34;TZ=Asia/Shanghai&amp;#34;&#xD;&#xA;      ports:&#xD;&#xA;        - &amp;#34;19200:19200&amp;#34;&#xD;&#xA;        - &amp;#34;19300:19300&amp;#34;&#xD;&#xA;      volumes:&#xD;&#xA;        - /DATA/es/data:/usr/share/elasticsearch/data&#xD;&#xA;        - /DATA/es/logs:/usr/share/elasticsearch/logs&#xD;&#xA;        - /etc/hosts:/etc/hosts&#xD;&#xA;        - es_config:/usr/share/elasticsearch/config&#xD;&#xA;        - /DATA/es/plugins:/usr/share/elasticsearch/plugins&#xD;&#xA;      ulimits:&#xD;&#xA;        # mmap 映射内存不限制&#xD;&#xA;        memlock:&#xD;&#xA;          soft: -1                  &#xD;&#xA;          hard: -1&#xD;&#xA;        # 文件描述符打开个数修改    &#xD;&#xA;        nofile:                                          &#xD;&#xA;          soft: 65535                             &#xD;&#xA;          hard: 65535&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# 末尾添加 作用是不要让宿主机空目录覆盖&#xD;&#xA;volumes:&#xD;&#xA;      es_config:&#xD;&#xA;        driver: local&#xD;&#xA;        driver_opts:&#xD;&#xA;          type: none&#xD;&#xA;          device: /DATA/es/config&#xD;&#xA;          o: bind&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;#mmap 映射内存不限制&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java中线程的实现</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/multi-thread/java-thread/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/multi-thread/java-thread/</guid>
      <description>&lt;h1 id=&#34;java中线程的实现&#34;&gt;&#xD;&#xA;  Java中线程的实现&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#java%e4%b8%ad%e7%ba%bf%e7%a8%8b%e7%9a%84%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;线程与进程&#34;&gt;&#xD;&#xA;  线程与进程&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e4%b8%8e%e8%bf%9b%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;线程是比进程更加轻量级的调度执行单位，引入线程可以将进程的资源分配和执行调度分开，各个线程共享进程的资源，又可以独立调度&lt;br&gt;&#xA;线程是Java中处理器资源调度的最基本单位&lt;/p&gt;&#xA;&lt;h2 id=&#34;java线程的实现&#34;&gt;&#xD;&#xA;  Java线程的实现&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#java%e7%ba%bf%e7%a8%8b%e7%9a%84%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;Thread对象内的许多关键方法都被声明为native&lt;br&gt;&#xA;native方法意味着这个方法没有使用或无法使用平台无关的手段来实现，即，Java线程的实现依赖于平台对线程的实现&#xA;以HotSpot为例，每一个Java线程都是直接映射到一个操作系统原生线程来实现，中间没有额外的间接结构&lt;br&gt;&#xA;HotSpot自身不会干涉线程调度，只能设置优先级给操作系统提供调度建议，全权交给操作系统处理&lt;br&gt;&#xA;什么时候冻结/唤醒/停止线程、该给线程分配多少处理器执行时间、线程分配给哪个处理器执行，都是操作系统完成，操作系统全权决定&lt;/p&gt;&#xA;&lt;h2 id=&#34;java线程调度&#34;&gt;&#xD;&#xA;  Java线程调度：&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#java%e7%ba%bf%e7%a8%8b%e8%b0%83%e5%ba%a6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;线程调度指Java为线程分配处理器使用权的过程。&#xA;两种调度方式：协同式调度、抢占式调度&lt;br&gt;&#xA;Java使用的线程调度方式为抢占式调度&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;每个线程都是由系统分配执行时间，线程的切换线程自己不能决定。不会出现一个线程导致整个进程或系统阻塞的问题。&lt;/li&gt;&#xA;&lt;li&gt;Thread::yield方法主动让出执行时间，但是不能主动获取执行时间&lt;/li&gt;&#xA;&lt;li&gt;Java只能建议操作系统给一些线程分配多一点执行时间，另一些少一点。通过设置优先级来完成&lt;/li&gt;&#xA;&lt;li&gt;Java一共设置了十个级别的优先级，两个线程同时处于Ready状态时，优先级高的容易被同选择执行&lt;/li&gt;&#xA;&lt;li&gt;操作系统仍是全权掌握决定权，甚至可以更改优先级。我们无法在程序中准确判断一组状态都为Ready的线程哪一个会先执行。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;java线程状态转换&#34;&gt;&#xD;&#xA;  Java线程状态转换&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#java%e7%ba%bf%e7%a8%8b%e7%8a%b6%e6%80%81%e8%bd%ac%e6%8d%a2&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;Java语言定义了线程的六种状态：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;新建&lt;br&gt;&#xA;创建后尚未start的线程&lt;/li&gt;&#xA;&lt;li&gt;运行&lt;br&gt;&#xA;线程有可能在执行，有可能在等待操作系统分配执行时间&lt;/li&gt;&#xA;&lt;li&gt;无限期等待&lt;br&gt;&#xA;该状态的线程不会被分配处理器执行时间，必须等待其他线程显式唤醒&lt;br&gt;&#xA;如Thread.Join()，object.wait()的不设置Timeout的方法&lt;br&gt;&#xA;唤醒方法如notify()&lt;/li&gt;&#xA;&lt;li&gt;限期等待&lt;br&gt;&#xA;等待期间不会被分配处理器调度时间，但是不需要其他线程显式唤醒，一定时间后系统会自动唤醒&lt;br&gt;&#xA;如sleep，有参的wait、join等方法&lt;/li&gt;&#xA;&lt;li&gt;阻塞&lt;br&gt;&#xA;阻塞状态是在等待获取一个排他锁，将在另一个线程放弃一个排他锁时发生&lt;br&gt;&#xA;等待则是等待唤醒动作的出现&lt;/li&gt;&#xA;&lt;li&gt;结束&lt;br&gt;&#xA;已终止的线程状态，线程结束执行&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;wait和notifynotifyall&#34;&gt;&#xD;&#xA;  wait和notify/notifyAll&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#wait%e5%92%8cnotifynotifyall&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;wait和notify/notifyAll方法是Object对象的实例方法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 对象锁&#xD;&#xA;private static final Object lock = new Object();&#xD;&#xA;private static int count = 0;&#xD;&#xA;&#xD;&#xA;// 生产者&#xD;&#xA;public static void producer() {&#xD;&#xA;    synchronized (lock) {&#xD;&#xA;        count++;&#xD;&#xA;        System.out.println(&amp;#34;生产数据，count=&amp;#34; + count);&#xD;&#xA;        lock.notify(); // 唤醒消费者&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;// 消费者&#xD;&#xA;public static void consumer() {&#xD;&#xA;    synchronized (lock) {&#xD;&#xA;        while (count == 0) {&#xD;&#xA;            try {&#xD;&#xA;                System.out.println(&amp;#34;等待数据...&amp;#34;);&#xD;&#xA;                lock.wait(); // 释放锁并等待&#xD;&#xA;            } catch (InterruptedException e) {&#xD;&#xA;                e.printStackTrace();&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        count--;&#xD;&#xA;        System.out.println(&amp;#34;消费数据，count=&amp;#34; + count);&#xD;&#xA;    }&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;wait方法必须在sychronized同步代码块下使用，否则会报错&lt;/li&gt;&#xA;&lt;li&gt;wait() 让线程释放锁并进入等待状态，需通过 同一对象的 notify()/notifyAll() 唤醒。&lt;/li&gt;&#xA;&lt;li&gt;notify() 只能唤醒在该对象锁上等待的线程，且唤醒后线程需重新竞争锁&lt;/li&gt;&#xA;&lt;li&gt;wait()和notify()/notifyAll()必须成对出现&#xA;没有 notify()，wait() 线程会一直阻塞；&lt;br&gt;&#xA;没有 wait()，notify() 会被忽略（无等待线程时调用 notify() 无副作用）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;threadsleeplong-millis&#34;&gt;&#xD;&#xA;  Thread.sleep(long millis)&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#threadsleeplong-millis&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Thread类的静态方法&lt;/li&gt;&#xA;&lt;li&gt;让线程等待一段时间后继续执行，不需要显式环境&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;try {&#xD;&#xA;    Thread.sleep(1000);&#xD;&#xA;} catch (InterruptedException e) {&#xD;&#xA;    e.printStackTrace();&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;threadjoin&#34;&gt;&#xD;&#xA;  thread.join()&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#threadjoin&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Thread对象的实例方法&lt;/li&gt;&#xA;&lt;li&gt;等待线程执行结束&lt;/li&gt;&#xA;&lt;li&gt;让主线程等待该线程执行完毕后再继续执行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Thread thread = new Thread(() -&amp;gt; {&#xD;&#xA;    try {&#xD;&#xA;        Thread.sleep(2000);&#xD;&#xA;        System.out.println(&amp;#34;子线程执行完毕&amp;#34;);&#xD;&#xA;    } catch (InterruptedException e) {&#xD;&#xA;        e.printStackTrace();&#xD;&#xA;    }&#xD;&#xA;});&#xD;&#xA;&#xD;&#xA;thread.start();&#xD;&#xA;System.out.println(&amp;#34;主线程等待子线程结束...&amp;#34;);&#xD;&#xA;thread.join(); // 主线程阻塞，直到子线程结束&#xD;&#xA;System.out.println(&amp;#34;主线程继续执行&amp;#34;);&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;threadyield&#34;&gt;&#xD;&#xA;  Thread.yield()&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#threadyield&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Thread 类的静态方法&lt;/li&gt;&#xA;&lt;li&gt;主动让出当前线程的CPU资源，让当前线程从 运行状态 转为 就绪状态，允许其他同优先级线程抢占 CPU&#xA;不释放锁，也不阻塞线程，仅提示调度器重新分配资源。&lt;br&gt;&#xA;无法保证一定生效（调度器可能忽略 yield() 请求）&lt;/li&gt;&#xA;&lt;li&gt;可以用于测试线程优先级等（强制触发线程上下文切换）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Thread highPriorityThread = new Thread(() -&amp;gt; {&#xD;&#xA;    for (int i = 0; i &amp;lt; 3; i++) {&#xD;&#xA;        System.out.println(&amp;#34;高优先级线程执行：&amp;#34; + i);&#xD;&#xA;        Thread.yield(); // 主动让出 CPU，观察低优先级线程是否能执行&#xD;&#xA;    }&#xD;&#xA;});&#xD;&#xA;highPriorityThread.setPriority(Thread.MAX_PRIORITY);&#xD;&#xA;&#xD;&#xA;Thread lowPriorityThread = new Thread(() -&amp;gt; {&#xD;&#xA;    for (int i = 0; i &amp;lt; 3; i++) {&#xD;&#xA;        System.out.println(&amp;#34;低优先级线程执行：&amp;#34; + i);&#xD;&#xA;    }&#xD;&#xA;});&#xD;&#xA;lowPriorityThread.setPriority(Thread.MIN_PRIORITY);&#xD;&#xA;&#xD;&#xA;highPriorityThread.start();&#xD;&#xA;lowPriorityThread.start();&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;可以降低后台不重要线程（比如异步日志）的CPU占用&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public class LogTask implements Runnable {&#xD;&#xA;    @Override&#xD;&#xA;    public void run() {&#xD;&#xA;        while (!Thread.currentThread().isInterrupted()) {&#xD;&#xA;            // 执行轻量级任务（如日志记录）&#xD;&#xA;            logInfo();&#xD;&#xA;            Thread.yield(); // 让出 CPU，减少资源占用&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;可以降低线程空转的影响&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;while (conditionNotMet()) {&#xD;&#xA;    Thread.yield(); // 让出 CPU，避免忙等待&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>SQL执行过程</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/mysql/sql-execution/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/mysql/sql-execution/</guid>
      <description>&lt;h1 id=&#34;sql执行过程&#34;&gt;&#xD;&#xA;  SQL执行过程&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#sql%e6%89%a7%e8%a1%8c%e8%bf%87%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;查询sql执行顺序&#34;&gt;&#xD;&#xA;  查询SQL执行顺序&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9f%a5%e8%af%a2sql%e6%89%a7%e8%a1%8c%e9%a1%ba%e5%ba%8f&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;以如下SQL为例：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;select distinct table1.id as card_id &#xD;&#xA;from table1&#xD;&#xA;join table2 on table1.id = table2.id&#xD;&#xA;where table1.id &amp;lt; 2&#xD;&#xA;group by card_id&#xD;&#xA;having max(card_id) &amp;gt; 10&#xD;&#xA;order by card_id desc&#xD;&#xA;limit 1, 1;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行顺序如下&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;FROM，查询语句的开始，每个步骤为下一个步骤生成一个虚拟表，作为下一个步骤的输入&#xA;&lt;ol&gt;&#xA;&lt;li&gt;如果是表，直接操作表&lt;/li&gt;&#xA;&lt;li&gt;如果是子查询，先执行子查询&lt;/li&gt;&#xA;&lt;li&gt;如果要关联表，执行下述JOIN、ON&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;JOIN 关联表，生成笛卡尔乘积虚拟表&lt;/li&gt;&#xA;&lt;li&gt;ON，对JOIN出来的虚拟表进行按条件筛选，并生成一个新虚拟表&lt;/li&gt;&#xA;&lt;li&gt;WHERE，对虚拟表进行按条件筛选，生成一张新虚拟表&lt;/li&gt;&#xA;&lt;li&gt;GROUP BY，将按指定列的值分组，得到新的虚拟表。后续的所有步骤都只能操作被分组的列。&lt;/li&gt;&#xA;&lt;li&gt;AVG,SUM,MAX…，聚合函数 对分组的结果进行计算，不生成虚拟表&lt;/li&gt;&#xA;&lt;li&gt;HAVING，按条件筛选，主要和GROUP BY配合使用。且是唯一一个应用到已分组数据的筛选器。生成新虚拟表&lt;/li&gt;&#xA;&lt;li&gt;SELECT，选择指定列，生成新虚拟表&lt;/li&gt;&#xA;&lt;li&gt;DISTINCT，去重，对上出结果进行去重，移除相同的行。产生新虚拟表。使用GROUP BY后，DISTINCT多余。&lt;/li&gt;&#xA;&lt;li&gt;ORDER BY，按照对指定列升序或降序。返回游标，而不是虚拟表。&lt;/li&gt;&#xA;&lt;li&gt;LIMIT，取出指定行的记录，产生虚拟表并返回结果。Limit m,n表示从第m到第n数据。&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>分布式锁实现</title>
      <link>https://constructor-md.github.io/codestack/docs/project/distributed-lock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/project/distributed-lock/</guid>
      <description>&lt;h1 id=&#34;分布式锁实现&#34;&gt;&#xD;&#xA;  分布式锁实现&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;</description>
    </item>
    <item>
      <title>自动拆装箱</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/common-class/auto-bin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/common-class/auto-bin/</guid>
      <description>&lt;h1 id=&#34;自动拆装箱&#34;&gt;&#xD;&#xA;  自动拆装箱&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%87%aa%e5%8a%a8%e6%8b%86%e8%a3%85%e7%ae%b1&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;装箱：基本数据类型转换对象&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;拆箱：对象转换基本数据类型&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;自动装箱：编译器调用valueOf，将基本类型转换成对象&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;自动拆箱：编译器通过调用类似intValue、doubleValue方法，将对象转成基本类型&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;包装类型的享元模式：&lt;br&gt;&#xA;Integer类的静态内部类，在类加载时执行静态方法，静态方法中实例化了-128-127数值的Integer对象放入数组中，作为缓存&lt;/p&gt;&#xA;&lt;p&gt;类似的缓存存在于几乎所有对应包装类型（所以包装类型比较一定要用equals最保险）&lt;/p&gt;</description>
    </item>
    <item>
      <title>HashSet</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/collection/hashset/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/collection/hashset/</guid>
      <description>&lt;h1 id=&#34;hashset&#34;&gt;&#xD;&#xA;  HashSet&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hashset&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;数据结构&#34;&gt;&#xD;&#xA;  数据结构&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;内部维护一个HashMap，new HashSet实际是new HashMap&lt;/li&gt;&#xA;&lt;li&gt;添加元素时，查找HashMap是否有元素，没有存放则直接添加，存放了则调用equals比较&lt;/li&gt;&#xA;&lt;li&gt;如果相同则放弃添加，不同则添加到最后&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;注意点&#34;&gt;&#xD;&#xA;  注意点&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b3%a8%e6%84%8f%e7%82%b9&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;只能存放一个Null值&lt;/li&gt;&#xA;&lt;li&gt;线程不安全&lt;/li&gt;&#xA;&lt;li&gt;不能有重复元素&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>int|Integer</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/common-class/int-integer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/common-class/int-integer/</guid>
      <description>&lt;h1 id=&#34;int和integer的区别&#34;&gt;&#xD;&#xA;  int和Integer的区别&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#int%e5%92%8cinteger%e7%9a%84%e5%8c%ba%e5%88%ab&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;数据类型不同，int是基本数据类型，Integer是引用数据类型&lt;/li&gt;&#xA;&lt;li&gt;默认值不同，int默认值为0，Integer默认值为null&lt;/li&gt;&#xA;&lt;li&gt;存储方式不同&lt;/li&gt;&#xA;&lt;li&gt;int在内存中直接存储数值，如果是成员变量则放在堆内的对象中，如果是局部变量则放在线程私有的虚拟机栈中&lt;/li&gt;&#xA;&lt;li&gt;Integer是引用类型，存储的是一个对象地址，new时是生成一个指针指向该对象，实际对象在堆中&lt;/li&gt;&#xA;&lt;li&gt;实例化方式不同，Integer必须实例化才能使用，int不需要&lt;/li&gt;&#xA;&lt;li&gt;变量比较方式不同，int之间可以==比较，Integer之间最好equals比较&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;int和Integer之间的比较：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;int之间可以==比较&lt;/li&gt;&#xA;&lt;li&gt;int和Integer之间比较时，Integer自从拆箱变为int进行比较，可以==比较&lt;/li&gt;&#xA;&lt;li&gt;Integer和Integer之间比较，由于内部缓存了值为-128-127的对象，对这个范围内可以==比较，对其他范围必须eaquls比较，equals比较时是在比较内部的int值&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>MinIO</title>
      <link>https://constructor-md.github.io/codestack/docs/deploy/minio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/deploy/minio/</guid>
      <description>&lt;h1 id=&#34;minio&#34;&gt;&#xD;&#xA;  MinIO&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#minio&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;部署方式：单节点&lt;/p&gt;&#xA;&lt;p&gt;运行方式：docker-compose&lt;/p&gt;&#xA;&lt;h2 id=&#34;目录创建&#34;&gt;&#xD;&#xA;  目录创建&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%9b%ae%e5%bd%95%e5%88%9b%e5%bb%ba&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo mkdir /DATA/minio /DATA/minio/data /DATA/minio/config&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;docker-composeyml&#34;&gt;&#xD;&#xA;  docker-compose.yml&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#docker-composeyml&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo vim /DATA/docker-compose.yml&#xD;&#xA;&#xD;&#xA;services:&#xD;&#xA;  minio:&#xD;&#xA;    image: minio/minio&#xD;&#xA;    restart: always&#xD;&#xA;    mem_limit: 1G&#xD;&#xA;    ports:&#xD;&#xA;      - &amp;#34;9000:9000&amp;#34;&#xD;&#xA;      - &amp;#34;19001:9001&amp;#34;&#xD;&#xA;    container_name: minio&#xD;&#xA;    command: server /data --console-address &amp;#34;:9001&amp;#34;&#xD;&#xA;    environment:&#xD;&#xA;      - MINIO_ROOT_USER=admin&#xD;&#xA;      - MINIO_ROOT_PASSWORD=_admin123&#xD;&#xA;      - MINIO_BROWSER_DEFAULT_LOCALE=zh_CN&#xD;&#xA;    volumes:&#xD;&#xA;      - /DATA/minio/data:/data&#xD;&#xA;      - /DATA/minio/config:/root/.minio&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;9000 是MInIO S3 API端口&#xA;9001 是MinIO WebUI 控制台端口&#xA;需要的节点才映射出来即可&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;启动&#34;&gt;&#xD;&#xA;  启动&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%90%af%e5%8a%a8&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo docker-compose up -d minio&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;防火墙打开&#34;&gt;&#xD;&#xA;  防火墙打开&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%98%b2%e7%81%ab%e5%a2%99%e6%89%93%e5%bc%80&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo ufw allow 19001/tcp&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>SpringBoot 引入第三方 Jar 包</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/spring/three-party-jar-import/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/spring/three-party-jar-import/</guid>
      <description>&lt;h1 id=&#34;springboot-引入第三方-jar-包&#34;&gt;&#xD;&#xA;  SpringBoot 引入第三方 Jar 包&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#springboot-%e5%bc%95%e5%85%a5%e7%ac%ac%e4%b8%89%e6%96%b9-jar-%e5%8c%85&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;SpringBoot 通过 SPI 机制引入第三方 Jar 包&lt;/p&gt;&#xA;&lt;h2 id=&#34;spi-机制&#34;&gt;&#xD;&#xA;  SPI 机制&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spi-%e6%9c%ba%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;JAVA SPI：Server Provider Interface 服务提供者接口，服务发现机制&lt;br&gt;&#xA;以 JDBC 为例 &lt;br&gt;&#xA;JDBC：通常执行流程&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;加载数据库驱动&lt;/li&gt;&#xA;&lt;li&gt;通过DriverManager对象，获取Connection连接对象&lt;/li&gt;&#xA;&lt;li&gt;创建Statement对象执行SQL语句&lt;/li&gt;&#xA;&lt;li&gt;处理ResultSet结果集&lt;/li&gt;&#xA;&lt;li&gt;关闭连接&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;但是其中驱动加载时，Java 仅提供了一个接口，具体的驱动实现类是由各个数据库厂商提供的&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口不能被实例化，要想实例化，就必须知道具体驱动类的全限定名&lt;/li&gt;&#xA;&lt;li&gt;即需要知道驱动类的全限定名&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Java 开发者想出在项目下的 ClassPath 目录中，创建 META-INF/services 文件夹&lt;br&gt;&#xA;在文件夹内创建&lt;strong&gt;以实现接口全限定名为名&lt;/strong&gt;的文件，&lt;strong&gt;内容为实现类的全限定名&lt;/strong&gt;&lt;br&gt;&#xA;通过IO获取所有的全限定名，将指定的Class文件实例化存储到容器中，完成第三方的实现类的实例化&lt;br&gt;&#xA;通过java.util.ServiceLoader.load方法实现SPI&lt;/p&gt;&#xA;&lt;h2 id=&#34;springboot-自动装配&#34;&gt;&#xD;&#xA;  SpringBoot 自动装配&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#springboot-%e8%87%aa%e5%8a%a8%e8%a3%85%e9%85%8d&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;SpringBoot的自动装配：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SpringBoot 开发中必不可少需要将第三方框架的 Jar 包内容加载到 IOC 容器中&lt;/li&gt;&#xA;&lt;li&gt;但是SpringBoot默认加载启动类所在包或子包的内容，或者指定包扫描路径，指令包扫描路径在很多第三方引入的时候显然太繁琐&lt;/li&gt;&#xA;&lt;li&gt;由于包名未知，不能通过扫描注入&#xA;SpringBoot 实现思路：&lt;/li&gt;&#xA;&lt;li&gt;SpringBoot规定了要接入SpringBoot的第三方框架，需要在Classpath目录下的META-INF文件中定义spring.factories文件&lt;/li&gt;&#xA;&lt;li&gt;在其中定义需要被加载到IOC容器的类&lt;/li&gt;&#xA;&lt;li&gt;SpringBoot启动时会自动扫描ClassPath目录下的所有META-INF的spring.factories文件，读取其中的要注册的类，通过反射进行实例化&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;SPI机制让接口和具体实现类解耦，使得可以根据具体的业务情况启用或替换具体组件&lt;/p&gt;</description>
    </item>
    <item>
      <title>ThreadLocal</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/multi-thread/threadlocal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/multi-thread/threadlocal/</guid>
      <description>&lt;h1 id=&#34;threadlocal&#34;&gt;&#xD;&#xA;  ThreadLocal&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#threadlocal&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;ThreadLocal是线程自己的私有变量副本，仅属于当前线程&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;每个线程Thread对象中都带有一个ThreadLocalMap对象，我们可以创建一个ThreadLocal作为该Map的Key，然后在Value中存储想要的值&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;每一个ThreadLocal对象都有独一无二的ThreadLocalHashCode值&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;ThreadLocal set的时候，实际上是拿到Thread里面的ThreadLocalMap来进行Set&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;ThreadLocal对象使用完毕后，应该进行回收，手动调用ThreadLocal的remove方法&lt;br&gt;&#xA;避免线程不被回收时（如线程池），ThreadLocalMap中的对象不被回收，从而出现内存泄漏&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;经典使用场景&#34;&gt;&#xD;&#xA;  经典使用场景&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%8f%e5%85%b8%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;在多个层级的方法中传递某个参数&lt;br&gt;&#xA;为了避免在方法参数列表上每个都加上这些参数带来的冗余&lt;br&gt;&#xA;写入ThreadLocalMap中存储&lt;br&gt;&#xA;如连接管理，某个连接对象要在不同的方法间传递，但同时线程之间又不共享连接&lt;br&gt;&#xA;（减少同一个线程内多个函数或者组件之间公共变量的传递的复杂度）&lt;/p&gt;&#xA;&lt;h2 id=&#34;可能出现内存泄露的原因&#34;&gt;&#xD;&#xA;  可能出现内存泄露的原因&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%af%e8%83%bd%e5%87%ba%e7%8e%b0%e5%86%85%e5%ad%98%e6%b3%84%e9%9c%b2%e7%9a%84%e5%8e%9f%e5%9b%a0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;内存泄漏指的是程序中已经动态分配的堆内存由于某种原因未释放或无法释放，造成系统内存浪费，最终导致程序运行速度变慢等严重后果&lt;br&gt;&#xA;如果有一个对象，在将来再也不会被使用，但是就是没有被回收，那么认为该对象属于内存泄漏&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;ThreadLocalMap的生命周期与Thread一样长，如果Thread执行完某个业务后，不删除对应ThreadLocal，且线程不被销毁（线程池线程），内部保持着的内容显然对系统是无意义的，这就是一种内存泄漏。&lt;/li&gt;&#xA;&lt;li&gt;一些ThreadLocal错误使用导致内存泄露的场景：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ThreadLocal定义为局部变量，线程执行完后没有remove，线程未被销毁。则ThreadLocal对象的强引用消失，仅剩ThreadLocalMap中的弱引用Key，GC仍然会把对象回收。此时ThreadLocalMap就有一个Entry的key为null，不会被别人访问，也不会被GC回收。出现内存泄露。&lt;/li&gt;&#xA;&lt;li&gt;ThreadLocal定义为类变量，但是我们为了防止业务上的问题，在不理解ThreadLocal原理的情况下，每次都进入方法前去重新实例化ThreadLocal，业务结束后错误地将ThreadLocal设为null想以此避免业务上的问题，则以前的一些ThreadLocal对象强引用消失，出现上一个问题的内存泄漏。&lt;/li&gt;&#xA;&lt;li&gt;ThreadLocal定义为类变量，一个线程执行完毕后没有remove，且线程未被销毁。后续该线程再也没有被用来执行该业务，以至于内部的ThreadLocal根本没有被访问的机会，这也是一种内存泄漏。&lt;/li&gt;&#xA;&lt;li&gt;在ThreadLocalMap中如果有Entry的key为null时，会在下一次调用set\get\remove方法时进行清理。但是如果后续我们再也没有访问过这个ThreadLocalMap，那自然出现上一个问题的内存泄漏。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;为什么threadlocalmap要使用弱引用key&#34;&gt;&#xD;&#xA;  为什么ThreadLocalMap要使用弱引用key？&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88threadlocalmap%e8%a6%81%e4%bd%bf%e7%94%a8%e5%bc%b1%e5%bc%95%e7%94%a8key&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果key为强引用，如果我们用完不去手动删除，ThreadLocal对象由于强引用不会被回收，则Entry会内存泄露&lt;/li&gt;&#xA;&lt;li&gt;如果Key为弱引用，我们不去手动删除，ThreadLocal没有其他强引用的情况下，GC回收掉ThreadLocal，ThreadLocalMap有机会在下一次访问清理无用的ThreadLocal，尽量避免内存泄露&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;内存泄露是因为ThreadLocalMap和Thread生命周期一致，如果不去手动删除，ThreadLocal很可能是无意义的内容，这是一种内存泄漏&lt;br&gt;&#xA;弱引用是用来尽量减少内存泄露的一种举措，但不够完善，仍有内存泄露的可能，即后续没有访问哪些方法导致Entry不被清理，而不是内存泄漏的产生原因&lt;br&gt;&#xA;内存泄露的产生原因是我们的错误使用方法。&lt;/p&gt;&#xA;&lt;h2 id=&#34;最佳实践&#34;&gt;&#xD;&#xA;  最佳实践&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;ThreadLocal定义为静态不可变常量&lt;br&gt;&#xA;使用完对应的value后，调用ThreadLocal.remove清理&lt;/p&gt;</description>
    </item>
    <item>
      <title>序列化和反序列化</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/other/serailizable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/other/serailizable/</guid>
      <description>&lt;h1 id=&#34;序列化和反序列化&#34;&gt;&#xD;&#xA;  序列化和反序列化&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ba%8f%e5%88%97%e5%8c%96%e5%92%8c%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;基本介绍&#34;&gt;&#xD;&#xA;  基本介绍&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;● 序列化&#xA;对象转换为字节流的过程&lt;br&gt;&#xA;转换为字节流后可以进行网络传输、持久化存储或者缓存&lt;br&gt;&#xA;Java提供java.io.Serailizable 接口支持序列化，只要实现这个接口，就可以将该类的对象进行序列化。&lt;/p&gt;&#xA;&lt;p&gt;● 反序列化&#xA;将字节流重新转换为对象的过程&lt;/p&gt;&#xA;&lt;p&gt;● 关键类和接口&#xA;ObjectOutputStream 用于序列化&lt;br&gt;&#xA;ObjectInputStream 用于反序列化&lt;br&gt;&#xA;类必须实现 Serializable 接口才能被序列化&lt;/p&gt;&#xA;&lt;p&gt;● transient 关键字&#xA;使用 transient 关键字可以指定让某些字段不被序列化&lt;/p&gt;&#xA;&lt;p&gt;● serialVersionUID&#xA;每个类都应该定义一个 serialVersionUID，用于反序列化时验证版本一致性&lt;br&gt;&#xA;如果不指定，Java会根据类定义自动生成UID，版本不匹配可能导致反序列化失败&lt;br&gt;&#xA;类似指纹&lt;/p&gt;&#xA;&lt;p&gt;● 性能&#xA;Java 默认的序列化机制可能比较慢，尤其对于大规模分布式系统，可能选择更高效的序列化框架，如 protobuf、kryo&lt;/p&gt;&#xA;&lt;p&gt;● 安全性&#xA;反序列化可能导致潜在安全风险，因为通过恶意构造的字节流可能导致加载不安全类或者执行不期望的代码。所以要警惕字节流来源，对不确定的字节流反序列化时进行输入验证，避免漏洞&lt;/p&gt;&#xA;&lt;h2 id=&#34;必须要实现-serializable-吗&#34;&gt;&#xD;&#xA;  必须要实现 Serializable 吗&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bf%85%e9%a1%bb%e8%a6%81%e5%ae%9e%e7%8e%b0-serializable-%e5%90%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;此前所述：类必须实现 Serializable 接口才能被序列化&lt;br&gt;&#xA;主要是指序列化使用Java原生序列化器（ObjectOutputStream， ObjectInputStream），其中存在是否实现该接口的判断&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;./images/java-serializable.png&#34; alt=&#34;java-serializable.png&#34; title=&#34;java-serializable.png&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;这里使得String、数组、枚举之外的类必须实现 Serializable，否则抛出异常&lt;br&gt;&#xA;但许多Spring实现的第三方带有数据存储和传输能力的组件接入类，一般自定义实现序列化和反序列化器，而且不继承 Java 原生序列化和反序列化器&lt;br&gt;&#xA;如 spring-data-redis：&lt;br&gt;&#xA;&lt;img src=&#34;./images/spring-data-redis-serializable.png&#34; alt=&#34;spring-data-redis-serializable.png&#34; title=&#34;spring-data-redis-serializable.png&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;apache kafka：&#xA;&lt;img src=&#34;./images/kafka-serializable.png&#34; alt=&#34;kafka-serializable.png&#34; title=&#34;kafka-serializable.png&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;所以许多情况下，可以看见一些类不需要实现 Serializable 接口一般也能正常使用功能。&lt;br&gt;&#xA;许多类或者规范，需要实现 Serializable 接口的主要原因是，防止系统中存在混杂使用 Java原生序列化器的情况&lt;/p&gt;</description>
    </item>
    <item>
      <title>AQS</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/multi-thread/aqs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/multi-thread/aqs/</guid>
      <description>&lt;h1 id=&#34;aqs&#34;&gt;&#xD;&#xA;  AQS&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aqs&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;AQS：AbstractQueuedSynchronized类&lt;br&gt;&#xA;JUC包中的ReentrantLock、Semaphroe、ReentrantReadWriteLock、CountDownLatch等几乎所有类都依赖于AQS实现&lt;/p&gt;&#xA;&lt;h2 id=&#34;重要属性&#34;&gt;&#xD;&#xA;  重要属性&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%87%8d%e8%a6%81%e5%b1%9e%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;AQS有两个重要属性：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;以Node为节点实现的双向链表、先进先出队列，节点内包装线程&lt;/li&gt;&#xA;&lt;li&gt;STATE标志，通过CAS改变其值，象征锁资源&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;部分逻辑&#34;&gt;&#xD;&#xA;  部分逻辑&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%83%a8%e5%88%86%e9%80%bb%e8%be%91&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;线程抢占资源，就是尝试设置STATE标志位的值，ReentrantLock就是将其设置为1，如果重入则不断自增&lt;br&gt;&#xA;如果STATE &amp;gt; 0则该资源被占用，即锁定，其他线程不能获得锁&lt;/p&gt;&#xA;&lt;p&gt;线程抢占资源失败，则进入等锁队列中，等待头节点释放锁后唤醒后继节点得锁（公平锁），或唤醒所有节点抢锁（非公平锁）&lt;/p&gt;&#xA;&lt;p&gt;AQS是一个抽象类，继承AQS自己实现的同步器，只需要根据同步器需要满足得性质取实现线程获取和修改同步状态变量的方式，队列的维护已经被顶层实现好。&lt;br&gt;&#xA;仅需要实现父类的一些抽象方法，方法内部设置同步状态变量即可&lt;/p&gt;&#xA;&lt;p&gt;AQS独占锁：&lt;br&gt;&#xA;ReentrantLock、ReentrantWriteLock等&lt;br&gt;&#xA;AQS共享锁：&lt;br&gt;&#xA;ReentrantReadLock、Semaphore、ConutDownLatch等&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java的线程安全实现</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/multi-thread/java-thread-safe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/multi-thread/java-thread-safe/</guid>
      <description>&lt;h1 id=&#34;java的线程安全实现&#34;&gt;&#xD;&#xA;  Java的线程安全实现&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#java%e7%9a%84%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;线程安全的定义&#34;&gt;&#xD;&#xA;  线程安全的定义&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%9a%84%e5%ae%9a%e4%b9%89&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;多个线程同时访问一个对象/方法时，如果不用考虑这些线程运行时环境下的调度和交替进行，也不需要进行额外的同步，或者调用方进行任何其他协调&lt;br&gt;&#xA;调用该对象/方法的行为都能获得正确的结果，则该对象线程安全&lt;/p&gt;&#xA;&lt;h2 id=&#34;线程安全的实现方法&#34;&gt;&#xD;&#xA;  线程安全的实现方法&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%9a%84%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;互斥同步&#34;&gt;&#xD;&#xA;  互斥同步&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%92%e6%96%a5%e5%90%8c%e6%ad%a5&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;同步指：保证并发访问时，共享资源同一时刻只能被一个线程访问&lt;/li&gt;&#xA;&lt;li&gt;互斥是实现同步的一种手段。常见的互斥实现方式有：临界区、互斥量和信号量&lt;/li&gt;&#xA;&lt;li&gt;Java中的基本互斥手段为Synchronized关键字&lt;/li&gt;&#xA;&lt;li&gt;除此之外还有java.util.concurrent.locks包下的Lock接口&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;synchronized&#34;&gt;&#xD;&#xA;  Synchronized&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#synchronized&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;这是一种块结构的同步语法&lt;/li&gt;&#xA;&lt;li&gt;javac编译后，会在同步块的前后分别形成monitorenter和monitorexit两个字节码指令。两个指令都需要指定一个refrence类型的参数指定需要锁定和解锁的对象&lt;/li&gt;&#xA;&lt;li&gt;如果指定了一个对象，则以该对象的引用作为reference；如果没有明确指定，则根据修饰的方法类型（实例方法或类方法），来决定取代码所在对象实例还是取类型对应的Class对象作为锁&lt;/li&gt;&#xA;&lt;li&gt;JVM规范规定，执行monitorenter指令时，首先要尝试获取对象锁，如果没有被锁定或者当前线程已经持有，则锁计数器+1，执行monitorexit时，锁计数器-1；一旦计数器值为0，则锁被释放。&lt;/li&gt;&#xA;&lt;li&gt;如果当前线程获取锁失败，则进入阻塞状态，直到锁被释放&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;注意点：&lt;br&gt;&#xA;synchronized锁可重入&lt;br&gt;&#xA;synchronized同步块执行完毕并释放锁前，无条件阻塞后面的线程进入，意味着无法像处理某些数据库中的锁一样，强制已获取锁的线程释放锁，也无法让等锁线程中断等待和超时退出&lt;br&gt;&#xA;持有锁是重量级操作，由于Java的线程是内核线程实现，切换县城需要操作系统帮忙，涉及到内核态和用户态的转换，耗费很多处理器时间。虚拟机对synchronized进行了一些优化。优化后性能基本能和ReentrantLock持平&lt;/p&gt;&#xA;&lt;h3 id=&#34;非阻塞同步&#34;&gt;&#xD;&#xA;  非阻塞同步&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%9d%9e%e9%98%bb%e5%a1%9e%e5%90%8c%e6%ad%a5&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;互斥同步属于悲观的并发策略，总是认为只要不做正确的同步措施就一定会出问题，无论数据实际上是否发生竞争，都会加锁。有着线程切换、维护锁计数器的开销&lt;br&gt;&#xA;随着硬件指令集的发展，可以做到基于冲突检测的乐观并发策略。&lt;br&gt;&#xA;基本思想是：先执行操作，如果没有其他线程竞争，则操作成功，如果有冲突，则做其他补偿措施，通常措施是不断重试，直到没有竞争操作成功。&#xA;这种同步操作成为非阻塞同步，代码可称为无锁代码&lt;br&gt;&#xA;之所以必须依赖硬件指令集的发展，是要求操作和冲突检测的两个步骤具备原子性&lt;br&gt;&#xA;如果以来互斥同步保证原子性则失去意义，只能依靠硬件实现&lt;br&gt;&#xA;通过硬件来保证多次操作的行为只通过一条处理器指令就能完成。&lt;br&gt;&#xA;Java中使用的指令为CAS，比较并交换&lt;/p&gt;&#xA;&lt;h4 id=&#34;cas指令&#34;&gt;&#xD;&#xA;  CAS指令&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cas%e6%8c%87%e4%bb%a4&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;CAS：compare and swap&lt;br&gt;&#xA;能在不使用锁的情况下，非阻塞地实现多线程安全&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;需要三个操作数：内存地址V，旧的预期值A，准备设置的新值B&lt;/li&gt;&#xA;&lt;li&gt;执行时，当且仅当V符合A，才用B更新V，否则不执行更新。这是一个原子操作&lt;/li&gt;&#xA;&lt;li&gt;该操作由sun.misc.Unsafe类的compareAndSwapInt()和compareAndSwapLong等几个方法包装提供，编译结果是一条平台相关的处理器CAS指令&lt;/li&gt;&#xA;&lt;li&gt;设计上Unsafe类是不提供给用户程序调用的类，限制了只有启动类加载器加载的Class才能访问它，因此JDK9之前只有Java类库可以使用CAS&lt;/li&gt;&#xA;&lt;li&gt;J.U.C包中的整数原子类使用了CAS操作实现，如果用户程序需要使用，要么通过反射突破Unsafe的访问限制，要么通过Java类库API间接使用&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;注意点：&lt;br&gt;&#xA;CAS无法覆盖互斥同步的所有使用场景，有一个逻辑漏洞（ABA问题）：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;如果V读取时是A，准备赋值时也是A，不能说明它的值没有被其他线程改过。比如被赋值为B又改回来，会误认为没有被改过。&lt;/li&gt;&#xA;&lt;li&gt;为了解决这个问题，JUC包提供了带引用标记的AtomicStampedReference源自引用类，通过控制变量的版本来保证CAS的正确性，但是比较鸡肋，如果想解决ABA问题，可以使用传统互斥同步可能更高效&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>SpringMVC 接收 HTTP</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/spring/springmvc-http/indxe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/spring/springmvc-http/indxe/</guid>
      <description>&lt;h1 id=&#34;springmvc-接收-http&#34;&gt;&#xD;&#xA;  SpringMVC 接收 HTTP&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#springmvc-%e6%8e%a5%e6%94%b6-http&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SpringMVC 是一个基于 Spring 的 Web 框架，运行于 Tomcat 等 Servlet 容器上&lt;/li&gt;&#xA;&lt;li&gt;SpringBoot 内置 Tomcat 容器&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;当使用原生 Java Servlet 实现 Web 服务器，运行于 Tomcat 上时&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;用户发起一个 HTTP 请求，Tomcat 收到请求，解析 HTTP 报文&lt;/li&gt;&#xA;&lt;li&gt;Tomcat 根据 URL 找到对应的 Servlet，构建 HttpServletRequest 和 HttpServletResponce 对象，调用 servlet 的 service 方法，将对象引用传入该方法&lt;/li&gt;&#xA;&lt;li&gt;Service 方法获取 Http 请求相关的信息，区分请求类型调用不同的方法，将处理结果放入 Responce 对象。&lt;/li&gt;&#xA;&lt;li&gt;Tomcat 将 Responce 对象封装成 Http 响应报文，返回给客户端。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;当使用 SpringMVC 实现 Web 容器，运行于 Tomcat 上时：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;用户发起一个 HTTP 请求，Tomcat 收到请求，生成一个线程解析 HTTP 报文&lt;/li&gt;&#xA;&lt;li&gt;Tomcat 生成 HttpRequest 和 HttpResponce 对象，调用 HttpServlet.service 方法，最终将对象转发给 DispatcherServlet.doService 方法（即全流程只有一个 servlet 存在，与 URL 无关）&lt;/li&gt;&#xA;&lt;li&gt;DispatcherServlet 是统一访问点，将请求委托给其他业务处理器。doService 方法调用 doDispatch 方法执行分发&lt;/li&gt;&#xA;&lt;li&gt;在 Tomcat 初始化时，通知 Spring 初始化容器，SpringMVC 会遍历容器中的 Bean，找到每一个 Controller 的所有方法访问的 url，和 Controller 保存到一个 Map 中。（HandlerMapping 组件获得了 URL 和 Controller 的关系）&lt;/li&gt;&#xA;&lt;li&gt;分发时 doDispatch 方法根据 URL 找到 Controller，找到 Controller 中对应的方法。将 request 的参数等和方法上的参数根据注解等进行绑定，最后通过反射调用方法。&lt;/li&gt;&#xA;&lt;li&gt;具体业务逻辑执行完后，回到 DispatcherServlet，进行后续处理，封装视图等&lt;/li&gt;&#xA;&lt;li&gt;Tomcat 将响应对象封装成 HTTP 响应报文，返回给客户端&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;拦截器是在 Spring 中起作用，具体在分发前执行前置拦截器逻辑，分发后执行后置拦截器逻辑&lt;/li&gt;&#xA;&lt;li&gt;过滤器是在 Tomcat 中起作用，具体在进入 servlet 前后进行预处理&lt;/li&gt;&#xA;&lt;li&gt;切面是在具体方法前起作用，具体在调用方法逻辑前后，会处理注解、切点等的逻辑&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>迭代器</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/collection/Iterator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/collection/Iterator/</guid>
      <description>&lt;h1 id=&#34;迭代器&#34;&gt;&#xD;&#xA;  迭代器&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%ad%e4%bb%a3%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;集合类的顶层接口Collection继承了Iterable接口&lt;br&gt;&#xA;Iterable接口有一个方法&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 返回一个Iterator对象&#xD;&#xA;Iterator&amp;lt;T&amp;gt; iterator();&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Iterator接口，有三个方法：hashNext、next、remove&lt;br&gt;&#xA;各个集合中实现了Iterator内部类，实现了这几个方法&lt;/p&gt;&#xA;&lt;p&gt;使用时，首先获取集合对象中的Iterator对象，然后while循环判断hashNext，然后用Next获取数据&lt;br&gt;&#xA;迭代过程中可以使用迭代器的remove方法删除元素，不能使用集合的remove方法删除元素&lt;br&gt;&#xA;原因是迭代器会更新modCount和expectedModCount，使得判断可以通过，不用抛出异常&lt;br&gt;&#xA;这在单线程下没问题，在多线程下不安全&lt;/p&gt;&#xA;&lt;p&gt;增强for循环：&lt;br&gt;&#xA;底层使用Iterator实现，只能遍历集合或数组&lt;/p&gt;</description>
    </item>
    <item>
      <title>CountDownLatch</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/multi-thread/CountDownLatch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/multi-thread/CountDownLatch/</guid>
      <description>&lt;h1 id=&#34;countdownlatch&#34;&gt;&#xD;&#xA;  CountDownLatch&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#countdownlatch&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;使用&#34;&gt;&#xD;&#xA;  使用&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;new一个CountDownLatch，需要指定计数器值，表示需要等待执行完毕的线程数量&lt;/p&gt;&#xA;&lt;p&gt;开启多个线程执行任务，并调用CountDownLatch对象的await方法，开始等待任务执行&lt;br&gt;&#xA;每个线程的任务执行完后，都要调用CountDownLatch对象的countDown方法&lt;/p&gt;&#xA;&lt;p&gt;当调用countDown方法的线程数达到计数器值时，多线程任务执行完毕，await方法的等待状态被取消，外层逻辑继续向下执行&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;CountDownLatch latch = new CountDownLatch(3);&#xD;&#xA;&#xD;&#xA;// 创建并启动 3 个工作线程&#xD;&#xA;for (int i = 0; i &amp;lt; 3; i++) {&#xD;&#xA;    final int taskId = i;&#xD;&#xA;    new Thread(() -&amp;gt; {&#xD;&#xA;        try {&#xD;&#xA;            System.out.println(&amp;#34;任务&amp;#34; + taskId + &amp;#34;开始执行&amp;#34;);&#xD;&#xA;            // 执行...&#xD;&#xA;            System.out.println(&amp;#34;任务&amp;#34; + taskId + &amp;#34;完成&amp;#34;);&#xD;&#xA;        } catch (Exception e) {&#xD;&#xA;            // ...&#xD;&#xA;        } finally {&#xD;&#xA;            // 任务完成后，计数器减 1&#xD;&#xA;            latch.countDown();&#xD;&#xA;        }&#xD;&#xA;    }).start();&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;// 主线程等待，直到计数器变为 0&#xD;&#xA;System.out.println(&amp;#34;主线程等待所有任务完成...&amp;#34;);&#xD;&#xA;latch.await();&#xD;&#xA;System.out.println(&amp;#34;所有任务已完成，主线程继续执行&amp;#34;);&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;原理&#34;&gt;&#xD;&#xA;  原理&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;CountDownLatch基于AbstractQueuedSynchronized（AQS）实现&lt;br&gt;&#xA;await方法被调用时，主线程进入等锁队列&lt;br&gt;&#xA;countDown方法被调用时，CountDownLatch对象内部计数器-1&lt;br&gt;&#xA;CountDownLatch对象内部计数器为0时，主线程被唤醒，继续执行任务&lt;/p&gt;</description>
    </item>
    <item>
      <title>SpringBoot 相比 Spring</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/spring/springboot-spring/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/spring/springboot-spring/</guid>
      <description>&lt;h1 id=&#34;springboot-相比-spring&#34;&gt;&#xD;&#xA;  SpringBoot 相比 Spring&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#springboot-%e7%9b%b8%e6%af%94-spring&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;SpringBoot 的核心能力：快速启动、最小化配置&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;内嵌 Servlet 容器 Tomcat，可以让 Web 项目打成 jar 包，通过 java -jar 运行&lt;/li&gt;&#xA;&lt;li&gt;提供 starter pom 系列，简化 maven 的依赖加载，减少依赖冲突的产生&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;支持自动化配置&lt;/li&gt;&#xA;&lt;li&gt;不需要像 Spring 一样配置 Bean，使用 properties 或 yaml 配置文件以及配置类简单配置即可。&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Jenkins</title>
      <link>https://constructor-md.github.io/codestack/docs/deploy/jenkins/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/deploy/jenkins/</guid>
      <description>&lt;h1 id=&#34;jenkins安装与web项目部署&#34;&gt;&#xD;&#xA;  Jenkins安装与Web项目部署&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jenkins%e5%ae%89%e8%a3%85%e4%b8%8eweb%e9%a1%b9%e7%9b%ae%e9%83%a8%e7%bd%b2&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;考虑到可移植性、对宿主机的影响最小，方便试错等问题&lt;br&gt;&#xA;采用Docker-Compose运行Jenkins&lt;br&gt;&#xA;自定义jenkins镜像，镜像内安装jdk、maven、node以便安装运行&lt;br&gt;&#xA;如果需要支持多版本的软件环境，则定制多版本的镜像即可&lt;/p&gt;&#xA;&lt;h2 id=&#34;部署jenkins单节点&#34;&gt;&#xD;&#xA;  部署Jenkins单节点&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%83%a8%e7%bd%b2jenkins%e5%8d%95%e8%8a%82%e7%82%b9&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;目录及权限&#34;&gt;&#xD;&#xA;  目录及权限&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%9b%ae%e5%bd%95%e5%8f%8a%e6%9d%83%e9%99%90&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo mkdir /DATA/jenkins /DATA/jenkins/data&#xD;&#xA;&#xD;&#xA;sudo chmod -R 777 /DATA/jenkins/data&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;定制dockerfile&#34;&gt;&#xD;&#xA;  定制Dockerfile&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%9a%e5%88%b6dockerfile&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;提前安装Maven及Node 便于Java和前端打包&lt;br&gt;&#xA;运行镜像后尽量减少一些配置&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 使用最新的 Jenkins LTS 镜像&#xD;&#xA;FROM jenkins/jenkins:lts&#xD;&#xA;&#xD;&#xA;# 切换到 root 用户进行系统级操作&#xD;&#xA;USER root&#xD;&#xA;&#xD;&#xA;# 更新系统软件包列表&#xD;&#xA;RUN apt-get update &amp;amp;&amp;amp; apt-get install -y \&#xD;&#xA;    wget \&#xD;&#xA;    gnupg2 \&#xD;&#xA;    software-properties-common&#xD;&#xA;&#xD;&#xA;# 下载并安装 JDK 8&#xD;&#xA;RUN wget -O /tmp/openjdk-8.tar.gz https://download.java.net/openjdk/jdk8u41/ri/openjdk-8u41-b04-linux-x64-14_jan_2020.tar.gz&#xD;&#xA;RUN mkdir -p /usr/lib/jvm&#xD;&#xA;RUN tar -xzf /tmp/openjdk-8.tar.gz -C /usr/lib/jvm&#xD;&#xA;RUN rm /tmp/openjdk-8.tar.gz&#xD;&#xA;&#xD;&#xA;# 添加 NodeSource 源以安装 Node.js 18&#xD;&#xA;RUN curl -sL https://deb.nodesource.com/setup_18.x | bash -&#xD;&#xA;&#xD;&#xA;# 更新软件包列表&#xD;&#xA;RUN apt-get update&#xD;&#xA;&#xD;&#xA;# 安装 Node.js 18&#xD;&#xA;RUN apt-get install -y nodejs&#xD;&#xA;&#xD;&#xA;# 下载并安装 Maven 3.6.3&#xD;&#xA;RUN wget https://archive.apache.org/dist/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz -P /tmp&#xD;&#xA;RUN tar -xzf /tmp/apache-maven-3.6.3-bin.tar.gz -C /opt&#xD;&#xA;RUN ln -s /opt/apache-maven-3.6.3 /opt/maven&#xD;&#xA;RUN rm /tmp/apache-maven-3.6.3-bin.tar.gz&#xD;&#xA;&#xD;&#xA;# 配置 Maven 国内源&#xD;&#xA;RUN mkdir -p /usr/share/maven/ref/&#xD;&#xA;COPY settings.xml /usr/share/maven/ref/settings.xml&#xD;&#xA;&#xD;&#xA;# 配置 Node.js 国内源&#xD;&#xA;RUN npm config set registry https://registry.npmmirror.com&#xD;&#xA;&#xD;&#xA;# 配置Maven环境变量&#xD;&#xA;ENV MAVEN_HOME=/opt/maven&#xD;&#xA;ENV PATH=$PATH:$MAVEN_HOME/bin&#xD;&#xA;&#xD;&#xA;# 切换回 jenkins 用户&#xD;&#xA;USER jenkins&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;放在 /DATA/jenkins目录下&lt;/p&gt;</description>
    </item>
    <item>
      <title>ReentrantLock</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/multi-thread/ReentrantLock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/multi-thread/ReentrantLock/</guid>
      <description>&lt;h1 id=&#34;reentrantlock&#34;&gt;&#xD;&#xA;  ReentrantLock&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#reentrantlock&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;介绍&#34;&gt;&#xD;&#xA;  介绍&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;JDK5时，没有synchronized优化，该关键字加锁是个比较重的操作&lt;br&gt;&#xA;J.U.C.locks.Lock接口提供了基于类的全新互斥手段，后续扩展出了不同调度算法、不同特征、不同性能不同于一的各种锁&lt;/p&gt;&#xA;&lt;p&gt;重入锁（ReentrantLock）是Lock的最常见实现，是可重入的&lt;br&gt;&#xA;基本用法和synchronized相似，相比synchronized主要增加了三个高级功能：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;等待可中断&lt;br&gt;&#xA;持锁线程长期不释放锁，正在等待的线程可以放弃等待，改为处理其他事情&lt;/li&gt;&#xA;&lt;li&gt;公平锁&lt;br&gt;&#xA;多个线程等待同个锁时，必须按照申请所得时间顺序来依次获得锁&lt;br&gt;&#xA;非公平锁在锁什邡市，任何等锁线程都能有机会获得锁&lt;br&gt;&#xA;synchronized是非公平的，ReentrantLock默认也是非公平，但是可以通过布尔参数改为公平锁&lt;br&gt;&#xA;使用公平锁后ReentrantLock性能急剧下降，影响吞吐量&lt;/li&gt;&#xA;&lt;li&gt;锁绑定多个条件&lt;br&gt;&#xA;一个ReentrantLock可以绑定多个Condition对象&lt;br&gt;&#xA;synchronized中，锁对象的wait、notify或notifyAll方法配合可以实现一个隐含条件，但是如果要和多于一个的条件关联，则必须额外添加锁&lt;br&gt;&#xA;但ReentrantLock则多次调用newCondition即可&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;锁释放&#34;&gt;&#xD;&#xA;  锁释放&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%94%81%e9%87%8a%e6%94%be&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;使用Lock需要保证在Finally块中释放锁，否则抛出异常后可能永远不会释放锁&lt;br&gt;&#xA;synchronized则由虚拟机保证锁的正常释放&lt;/p&gt;&#xA;&lt;h2 id=&#34;基本实现原理&#34;&gt;&#xD;&#xA;  基本实现原理&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e6%9c%ac%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;Lock接口的实现内部封装了一个AQS同步队列&lt;br&gt;&#xA;AQS同步队列支持先进先出，数据结构为双向链表，维护头尾指针，方便从任意一个位置访问前后节点&lt;br&gt;&#xA;线程如果得锁失败，就会被封装成Node进入等锁队列&lt;br&gt;&#xA;当获取锁的线程释放锁，就从队列中取出一个节点唤醒线程&lt;/p&gt;&#xA;&lt;p&gt;一个线程得锁失败，则加入队列尾，通过尾结点指针对接队列尾&lt;br&gt;&#xA;通过CAS将tail指向新的尾节点&lt;br&gt;&#xA;一个线程释放锁，唤醒后继节点，后继节点得锁成功后，会把自己设为队列头节点&lt;br&gt;&#xA;设置头节点不需要用CAS，因为设置头节点是获取锁的线程来完成&lt;br&gt;&#xA;同步锁只能由一个线程获取，所以不需要CAS保证&lt;/p&gt;&#xA;&lt;p&gt;ReentraintLock锁对象，通过CAS进行加锁，如果加锁失败，则走锁竞争的逻辑&lt;br&gt;&#xA;加锁成功则走加锁成功逻辑&lt;/p&gt;&#xA;&lt;p&gt;加锁成功后，会设置state属性值，支持可重入，同个每次加锁state值加一，解锁则减一，如果state值大一0，说明此时有线程持有锁，=0则是五锁状态&lt;/p&gt;&#xA;&lt;h2 id=&#34;公平非公平锁&#34;&gt;&#xD;&#xA;  公平/非公平锁&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%ac%e5%b9%b3%e9%9d%9e%e5%85%ac%e5%b9%b3%e9%94%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;公平锁就是锁释放后唤醒后继节点获得锁 &lt;br&gt;&#xA;非公平锁就是唤醒全部线程，让他们都CAS一下，谁成功谁就得锁，不成功就进入队列等待下一次&lt;/p&gt;</description>
    </item>
    <item>
      <title>日志文件及作用</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/mysql/logfile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/mysql/logfile/</guid>
      <description>&lt;h1 id=&#34;日志文件及作用&#34;&gt;&#xD;&#xA;  日志文件及作用&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%97%a5%e5%bf%97%e6%96%87%e4%bb%b6%e5%8f%8a%e4%bd%9c%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;errorlog-错误日志&#34;&gt;&#xD;&#xA;  error.log 错误日志：&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#errorlog-%e9%94%99%e8%af%af%e6%97%a5%e5%bf%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt;对MySQL的启动、运行、关闭过程进行了记录&#xD;&#xA;用于问题的排查，如例如权限问题、配置错误、磁盘空间不足&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;slowlog-慢查询日志&#34;&gt;&#xD;&#xA;  slow.log 慢查询日志：&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#slowlog-%e6%85%a2%e6%9f%a5%e8%af%a2%e6%97%a5%e5%bf%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt;可通过slow_query_log_file参数在配置文件中指定文件名，若未指定，默认在数据目录下，文件名为hostname-slow.log&#xD;&#xA;默认情况下不启动慢查询日志，需要手动设置&#xD;&#xA;用于定位执行时间超过设置值的SQL，以及没有使用索引的SQL&#xD;&#xA;可以通过mysqldupmslow查找和筛选慢查询日志的内容&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;查询日志&#34;&gt;&#xD;&#xA;  查询日志：&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9f%a5%e8%af%a2%e6%97%a5%e5%bf%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt;其文件名可通过general_log_file参数在配置文件中指定，若未指定，默认在数据目录下，文件名为hostname.log&#xD;&#xA;记录了所有对MySQL数据库请求的信息，不论是否得到了正确执行&#xD;&#xA;但由于会记录所有语句，开启该日志会对性能产生较大影响，所以通常只在调试或测试环境中开启&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;二进制日志binlog&#34;&gt;&#xD;&#xA;  二进制日志bin.log&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%97%a5%e5%bf%97binlog&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt;二进制日志由一系列文件组成，文件名格式为binlog.xxxxxx ，其中xxxxxx是一个 6 位的数字序号，从 000001 开始递增。其文件名前缀可通过log_bin参数在配置文件中指定&#xD;&#xA;记录了所有对MySQL数据库进行的更改&#xD;&#xA;作用：&#xD;&#xA;    数据恢复，数据库全备文件恢复&#xD;&#xA;    主从复制，通过复制和执行二进制日志，使从库和主库实时同步&#xD;&#xA;    审计判断是否有对数据库攻击&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;中继日志relay-log&#34;&gt;&#xD;&#xA;  中继日志（Relay Log）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ad%e7%bb%a7%e6%97%a5%e5%bf%97relay-log&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt;文件名格式为relay-log.xxxxxx ，其中xxxxxx是一个 6 位的数字序号，从 000001 开始递增。文件名前缀可通过relay_log参数在配置文件中指定。&#xD;&#xA;作用：&#xD;&#xA;    在主从复制架构中，从服务器从主服务器接收二进制日志内容后，会将其存储在中继日志中&#xD;&#xA;    从服务器的 SQL 线程会读取中继日志中的内容，并在本地执行相应的 SQL 语句，从而实现数据的同步&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;事务日志innodb&#34;&gt;&#xD;&#xA;  事务日志（Innodb）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8b%e5%8a%a1%e6%97%a5%e5%bf%97innodb&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;redo-log-重做日志&#34;&gt;&#xD;&#xA;  Redo log 重做日志:&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#redo-log-%e9%87%8d%e5%81%9a%e6%97%a5%e5%bf%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt;默认文件名为ib_logfile0、ib_logfile1等，可通过innodb_log_files_in_group参数指定日志文件的数量，通过innodb_log_file_size参数指定每个日志文件的大小。&#xD;&#xA;用于保证事务的持久性&#xD;&#xA;MySQL中有大量缓存，数据修改时首先更新缓存，但是缓存并非马上同步到磁盘，即为脏页&#xD;&#xA;但是数据库如果宕机，则内存数据丢失，重启无法恢复&#xD;&#xA;所以每次修改内存就要写redo log，redo log顺序写入，磁盘的顺序读写速度远快于随机读写，写操作对性能影响较小&#xD;&#xA;Redo log是物理日志，记录数据页的物理修改，用于恢复提交后的物理数据页&#xD;&#xA;如果数据库意外重启，会根据redo log进行数据恢复&#xD;&#xA;如果redo log有事务提交，则提交事务修改数据。也仅能恢复到数据最后提交的状态&#xD;&#xA;可以利用 Redo Log 将未写入磁盘的数据页恢复到崩溃前的状态&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;undo-log-回滚日志&#34;&gt;&#xD;&#xA;  Undo log 回滚日志:&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#undo-log-%e5%9b%9e%e6%bb%9a%e6%97%a5%e5%bf%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt;InnoDB Undo Log 没有单独的文件名，它是存储在系统表空间（ibdata1）或独立的 undo 表空间中的。可通过innodb_undo_tablespaces参数指定独立 undo 表空间的数量&#xD;&#xA;undo log是逻辑日志，每次修改数据，undolog中出现一条反操作的记录&#xD;&#xA;可以用于事务回滚，也可以根据undolog回溯到某个特定版本的数据&#xD;&#xA;用于实现事务的原子性和多版本并发控制（MVCC）&#xD;&#xA;在事务执行过程中，Undo Log 会记录数据修改前的状态，当事务需要回滚时，可以根据 Undo Log 将数据恢复到事务开始前的状态&#xD;&#xA;同时，MVCC 通过 Undo Log 提供数据的多个版本，使得不同事务可以同时访问同一数据的不同版本，提高并发性能&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Explain参数解释和查询成本分析</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/mysql/explain/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/mysql/explain/</guid>
      <description>&lt;h1 id=&#34;explain参数解释和查询成本分析&#34;&gt;&#xD;&#xA;  Explain参数解释和查询成本分析&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#explain%e5%8f%82%e6%95%b0%e8%a7%a3%e9%87%8a%e5%92%8c%e6%9f%a5%e8%af%a2%e6%88%90%e6%9c%ac%e5%88%86%e6%9e%90&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;explain&#34;&gt;&#xD;&#xA;  Explain&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#explain&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;通过执行 explain [sql] 得到执行计划&lt;/p&gt;&#xA;&lt;p&gt;如果from中包含子查询，会查并生成临时表&lt;/p&gt;&#xA;&lt;p&gt;explain执行完之后执行show warnings，有时候可以直接拷贝出来直接使用，大多时候可以用于参考执行&lt;/p&gt;&#xA;&lt;h3 id=&#34;结果列分析&#34;&gt;&#xD;&#xA;  结果列分析&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%93%e6%9e%9c%e5%88%97%e5%88%86%e6%9e%90&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;h4 id=&#34;id&#34;&gt;&#xD;&#xA;  id&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#id&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;有几个select就有几个id，id按select出现的顺序增长，id大的先执行，null最后执行，相同则从上往下执行&lt;/p&gt;&#xA;&lt;h4 id=&#34;select_type&#34;&gt;&#xD;&#xA;  select_type&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#select_type&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;simple 简单查询，没有子查询和union&lt;/li&gt;&#xA;&lt;li&gt;primary 复杂查询中最外层迭代select&lt;/li&gt;&#xA;&lt;li&gt;subquery 包含在select中的子查询，不在from中&lt;/li&gt;&#xA;&lt;li&gt;dependent subquery select语句出现的子查询，依赖外部查询&lt;/li&gt;&#xA;&lt;li&gt;derived 包含在from子句的子查询，会把结果放在临时表（派生表）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;table&#34;&gt;&#xD;&#xA;  table&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#table&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;这一行的查询在访问哪个表&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;from子句有子查询时，table列是&lt;!-- raw HTML omitted --&gt;格式，表示当前查询依赖id=N的查询，会先执行id=N的查询&lt;/li&gt;&#xA;&lt;li&gt;有union时，union result的table列的值为union 1,2，1和2表示参与union的select的id&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;type&#34;&gt;&#xD;&#xA;  type&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#type&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;表示关联类型或访问类型，表示mysql决定如何查找表中的行，查找数据行记录的大概范围, 从最优到最差依次为：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;system &amp;gt; const &amp;gt; eq_ref &amp;gt; ref &amp;gt; range &amp;gt; index &amp;gt; ALL&#xA;一般来说应该最少把查询保持在range级别，最好达到ref&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;system MyIsm出现，表为空或者记录唯一时&lt;/li&gt;&#xA;&lt;li&gt;const 主键索引或唯一索引的等值查询&lt;/li&gt;&#xA;&lt;li&gt;eq_ref join的时候有驱动表和被驱动表，被驱动表走唯一或者主键索引时&lt;/li&gt;&#xA;&lt;li&gt;ref 非主键或非唯一索引的等值查询，关联查询时被驱动表的驱动键走非唯一索引&lt;/li&gt;&#xA;&lt;li&gt;range 一般索引的范围查询&lt;/li&gt;&#xA;&lt;li&gt;index 全表扫描，非聚簇索引的叶子节点&lt;/li&gt;&#xA;&lt;li&gt;All 聚簇索引的全表扫描&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;possible-keys列&#34;&gt;&#xD;&#xA;  possible keys列&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#possible-keys%e5%88%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;显示查询可能使用哪些索引来查找&lt;/p&gt;</description>
    </item>
    <item>
      <title>异常体系</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/other/exception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/other/exception/</guid>
      <description>&lt;h1 id=&#34;异常体系&#34;&gt;&#xD;&#xA;  异常体系&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%82%e5%b8%b8%e4%bd%93%e7%b3%bb&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;throwable&#34;&gt;&#xD;&#xA;  Throwable&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#throwable&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;Throwable 类是所有异常和错误的超类&lt;br&gt;&#xA;两个直接子类为 Error 和 Exception，分别表示错误和异常&lt;/p&gt;&#xA;&lt;h2 id=&#34;error&#34;&gt;&#xD;&#xA;  Error&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#error&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;Error 指的是程序无法处理的错误，由 JVM 产生和抛出&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如 OutOfMemoryError、StackOverFlowError、ThreadDeath 等。Error 发生时，JVM 会选择终止线程&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;exception&#34;&gt;&#xD;&#xA;  Exception&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#exception&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;分为不检查异常（unchecked Exception）和检查异常（checked exception）&lt;br&gt;&#xA;也是运行时异常（RuntimeException）和非运行时异常&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Exception 是程序可以处理的异常，分为两大类，运行时异常和非运行时异常。程序中需要尽量去解决这些异常&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;运行时异常&#34;&gt;&#xD;&#xA;  运行时异常&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%90%e8%a1%8c%e6%97%b6%e5%bc%82%e5%b8%b8&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;指 RuntimeException 类及其子类，如 NullPointerException、IndexOutOfBoundsException 等。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;属于不检查异常，程序可以选择捕获处理，也可以不处理&#xA;例如：&lt;/li&gt;&#xA;&lt;li&gt;NullPointerException - 空指针引用异常&lt;/li&gt;&#xA;&lt;li&gt;ClassCastException - 类型强制转换异常&lt;/li&gt;&#xA;&lt;li&gt;IllegalArgumentException - 传递非法参数异常&lt;/li&gt;&#xA;&lt;li&gt;ArithmeticException - 算术运算异常&lt;/li&gt;&#xA;&lt;li&gt;ArrayStoreException - 向数组中存放与声明类型不兼容对象异常&lt;/li&gt;&#xA;&lt;li&gt;IndexOutOfBoundsException - 下标越界异常&lt;/li&gt;&#xA;&lt;li&gt;NegativeArraySizeException - 创建一个大小为负数的数组错误异常&lt;/li&gt;&#xA;&lt;li&gt;NumberFormatException - 数字格式异常&lt;/li&gt;&#xA;&lt;li&gt;SecurityException - 安全异常&lt;/li&gt;&#xA;&lt;li&gt;UnsupportedOperationException - 不支持的操作异常&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;非运行时异常&#34;&gt;&#xD;&#xA;  非运行时异常&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%9d%9e%e8%bf%90%e8%a1%8c%e6%97%b6%e5%bc%82%e5%b8%b8&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;指 Exception 类及其子类中 RuntimeException 类及其子类以外的类&lt;/p&gt;</description>
    </item>
    <item>
      <title>一些设计理论</title>
      <link>https://constructor-md.github.io/codestack/docs/project/design-theory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/project/design-theory/</guid>
      <description>&lt;h1 id=&#34;一些设计理论&#34;&gt;&#xD;&#xA;  一些设计理论&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%80%e4%ba%9b%e8%ae%be%e8%ae%a1%e7%90%86%e8%ae%ba&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;cap-理论&#34;&gt;&#xD;&#xA;  CAP 理论&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cap-%e7%90%86%e8%ae%ba&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;C 代表一致性：分布式系统中数据的一致性&lt;/li&gt;&#xA;&lt;li&gt;A 代表可用性：分布式系统是否正常可用&lt;/li&gt;&#xA;&lt;li&gt;P 代表分区容器性：分布式系统中出现网络问题的容错性&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CAP 理论：分布式系统中不可能同时满足 C 和 A，即要么 CP 要么 AP&lt;/li&gt;&#xA;&lt;li&gt;一致性和可用性只能取其一。需要数据强一致性就会损失可用性，需要可用性保证，就会损失强一致性&lt;/li&gt;&#xA;&lt;li&gt;实际生产环境遵循 BASE 理论&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;base-理论&#34;&gt;&#xD;&#xA;  BASE 理论&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#base-%e7%90%86%e8%ae%ba&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;BA：Basically Availiable，基本可用，允许一定程度的不可用，如系统故障导致请求时间变长或非核心部分不可用&lt;/li&gt;&#xA;&lt;li&gt;S：Soft state: 表示分布式系统可以处于一种中间状态，比如数据正在同步&lt;/li&gt;&#xA;&lt;li&gt;E：Eventually consistent: 最终一致性。不要求分布式系统数据实时一致，允许经过一段时间后一致，过程中系统也是可用的&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>索引树高度计算</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/mysql/tree-high/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/mysql/tree-high/</guid>
      <description>&lt;h1 id=&#34;索引树高度计算&#34;&gt;&#xD;&#xA;  索引树高度计算&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b4%a2%e5%bc%95%e6%a0%91%e9%ab%98%e5%ba%a6%e8%ae%a1%e7%ae%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;基本原理&#34;&gt;&#xD;&#xA;  基本原理&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;Innodb是索引组织表，每个页都包含一个PAGE_LEVEL，表示当前页在索引上的高度&lt;/p&gt;&#xA;&lt;p&gt;默认叶子节点高度为0，ROOT节点PAGE_LEVEL+1就是这棵索引高度&lt;/p&gt;&#xA;&lt;p&gt;PAGE_LEVEL在每个页的64位偏移位置，占用2字节&lt;/p&gt;&#xA;&lt;p&gt;找到ROOT页位置，知道单页大小，使用hexdump在指定表空间找到第PAGE_NO页的64位偏移量的后两个字节即可&lt;/p&gt;&#xA;&lt;h2 id=&#34;找到root页信息&#34;&gt;&#xD;&#xA;  找到ROOT页信息&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%89%be%e5%88%b0root%e9%a1%b5%e4%bf%a1%e6%81%af&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;SELECT b.name, a.name, index_id, type, a.space, a.PAGE_NO&#xD;&#xA;FROM information_schema.INNODB_SYS_INDEXES a,&#xD;&#xA;information_schema.INNODB_SYS_TABLES b&#xD;&#xA;WHERE a.table_id = b.table_id AND a.space &amp;lt;&amp;gt; 0;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结果：&#xA;&lt;img src=&#34;./images/root-info.png&#34; alt=&#34;&amp;ldquo;root页信息&amp;rdquo;&#34; title=&#34;root页信息&#34;/&gt;&#xA;其中（space、PAGE_NO）指向ROOT页&lt;/p&gt;&#xA;&lt;p&gt;space是表空间，可以是系统表空间（如ibdata1文件）或独立表空间（如每个InnoDB表的.ibd文件）。表空间由多个区（extent）组成，每个区包含连续的页（page）&lt;/p&gt;&#xA;&lt;p&gt;也就是ROOT页是space的page_no页&lt;/p&gt;&#xA;&lt;h2 id=&#34;查看innodb_page_size&#34;&gt;&#xD;&#xA;  查看innodb_page_size&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9f%a5%e7%9c%8binnodb_page_size&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;show variables like &amp;#39;innodb_page_size&amp;#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结果：&#xA;&lt;img src=&#34;./images/innodb_page_size.png&#34; alt=&#34;&amp;ldquo;innodb_page_size&amp;rdquo;&#34; title=&#34;innodb_page_size&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;也就是Innodb默认的页大小16KB&lt;/p&gt;&#xA;&lt;h2 id=&#34;找到root的page_level得到索引高度&#34;&gt;&#xD;&#xA;  找到ROOT的PAGE_LEVEL，得到索引高度&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%89%be%e5%88%b0root%e7%9a%84page_level%e5%be%97%e5%88%b0%e7%b4%a2%e5%bc%95%e9%ab%98%e5%ba%a6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;首先要找到表对应的ibd文件，也就是表空间文件&lt;/p&gt;&#xA;&lt;p&gt;所在位置是MySQL的数据目录下的数据库名文件夹下&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#查找MySQL数据目录&#xD;&#xA;show variables like &amp;#39;datadir&amp;#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;./images/dir.png&#34; alt=&#34;&amp;ldquo;dir&amp;rdquo;&#34; title=&#34;dir&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;我的MySQL是用Docker起的，docker中没有安装hexdump命令，不过这个目录被挂载出来了，考虑在宿主机上分析其中的ibd文件&lt;/p&gt;&#xA;&lt;p&gt;但所在文件夹和文件权限限制了宿主机外用户访问文件夹和文件&#xA;&lt;img src=&#34;./images/docker-dir.png&#34; alt=&#34;&amp;ldquo;docker-dir&amp;rdquo;&#34; title=&#34;docker-dir&#34;/&gt;&#xA;修改权限需要到docker容器中修改该文件和对应文件夹权限&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;chmod 755 path&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;原本权限为750，禁止其他用户读写文件夹&lt;/p&gt;&#xA;&lt;p&gt;修改后在宿主机进入文件夹中，找到所需文件，在文件夹执行命令&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;hexdump -C -s 49216 -n 10 goods_info_100M.ibd&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;./images/page-info.png&#34; alt=&#34;&amp;ldquo;page-info&amp;rdquo;&#34; title=&#34;page-info&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;前两个字节是PAGE_LEVEL，所以这个索引树高度为3+1 = 4&lt;/p&gt;</description>
    </item>
    <item>
      <title>JDK|JRE|JVM</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/other/java-softwre-package/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/other/java-softwre-package/</guid>
      <description>&lt;h1 id=&#34;jdkjrejvm&#34;&gt;&#xD;&#xA;  JDK|JRE|JVM&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jdkjrejvm&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;jvm&#34;&gt;&#xD;&#xA;  JVM：&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jvm&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;Java 虚拟机，Java 程序能够跨平台运行的核心&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;所有的 Java 程序都会被编译为.class 的类文件，同代码在任何平台上编译字节码都相同&lt;/li&gt;&#xA;&lt;li&gt;.class 文件在虚拟机上运行，由虚拟机将字节码解释给本地系统执行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;jre&#34;&gt;&#xD;&#xA;  JRE：&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jre&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;Java 运行时环境，即 Java 程序必须在 JRE 上运行&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;包含 JVM 和 Java 核心类库&lt;/li&gt;&#xA;&lt;li&gt;JVM 不能直接执行 class，还需要 Java 核心类库来解释 class&lt;/li&gt;&#xA;&lt;li&gt;安装 jre 后有 bin 和 lib 两个文件夹，可简单理解为分别是 JVM 和 Lib&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;jdk&#34;&gt;&#xD;&#xA;  JDK：&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jdk&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;Java 开发工具包，包括 JRE、Java 工具、编译器和调试器组成&lt;br&gt;&#xA;自带工具：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;java：Java 运行工具，运行.class 或 jar 包&lt;/li&gt;&#xA;&lt;li&gt;javac: Java 编译工具，将 Java 源代码编译为字节码&lt;/li&gt;&#xA;&lt;li&gt;javap: Java 反编译工具，将 Java 字节码反汇编为源代码&lt;/li&gt;&#xA;&lt;li&gt;jmap：Java 内存映射工具，打印执行 Java 进程、核心文件或远程调试服务器的配置信息&lt;/li&gt;&#xA;&lt;li&gt;jps: Java 进程状态工具，显示目标系统上的 HotSpot JVM 的 Java 进程信息&lt;/li&gt;&#xA;&lt;li&gt;jinfo: Java 配置信息工具，用于打印指定 Java 进程、核心文件或远程调试服务器的配置信息&lt;/li&gt;&#xA;&lt;li&gt;jstack: Java 堆栈跟踪工具，用于打印 Java 进程、核心为念 u 哦远程调试服务器的 Java 现成的堆栈跟踪信息&lt;/li&gt;&#xA;&lt;li&gt;jvisualvm: Java 可视化 JVM 检测、故障分析工具。图形化界面提供指定虚拟机的 Java 应用程序的详细信息&lt;/li&gt;&#xA;&lt;li&gt;jconsole：图形化界面的检测工具，监测并显示 Java 平台上的应用程序的性能和资源占用等信息&lt;/li&gt;&#xA;&lt;li&gt;javadoc: Java 文档工具，根据源代码中的注释信息生成 HTML 格式的 API 帮助文档&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;三者的关系&#34;&gt;&#xD;&#xA;  三者的关系：&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%89%e8%80%85%e7%9a%84%e5%85%b3%e7%b3%bb&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;JDK 包含 JRE、JRE 包含 JVM&lt;/li&gt;&#xA;&lt;li&gt;JVM 不能单独搞定 class 的执行，解释 class 需要使用 JRE 中的 Java 核心类库 lib&lt;/li&gt;&#xA;&lt;li&gt;我们利用 JDK 开发 Java 源程序，通过 JDK 提供的 javac 编译程序将源程序编译成 Java 字节码，在 JVM 使用 JRE 的 lib 解释这些字节码，映射到 CPU 指令集或 OS 的系统调用&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>TCP</title>
      <link>https://constructor-md.github.io/codestack/docs/basic/net/transport/tcp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/basic/net/transport/tcp/</guid>
      <description>&lt;h1 id=&#34;tcp&#34;&gt;&#xD;&#xA;  TCP&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#tcp&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议&lt;/p&gt;&#xA;&lt;h2 id=&#34;报文结构&#34;&gt;&#xD;&#xA;  报文结构&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8a%a5%e6%96%87%e7%bb%93%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;&lt;img src=&#34;./images/message.png&#34; alt=&#34;报文结构&#34; title=&#34;报文结构&#34;/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;源端口：发送方使用的端口号，16位&lt;/li&gt;&#xA;&lt;li&gt;目的端口：接收方使用的端口号，16位&lt;/li&gt;&#xA;&lt;li&gt;序号：本报文段发送数据的第一个字节的编号，32位&lt;/li&gt;&#xA;&lt;li&gt;确认号：接收方期望接收到的下一个报文段的第一个字节的编号&lt;/li&gt;&#xA;&lt;li&gt;数据偏移(首部长度)：指数据段中的数据部分的起始处距离TCP报文段起始处的偏移量，也就是TCP报文的报头部分的长度，接收端根据这个知道数据（有效载荷）从何处开始 4位&lt;/li&gt;&#xA;&lt;li&gt;保留字段：TCP协议将来的发展预留的空间，目前必须全部为0，6位&lt;/li&gt;&#xA;&lt;li&gt;标志位字段：共六个标志位，每个1bit&lt;/li&gt;&#xA;&lt;li&gt;窗口大小：表示发送该TCP报文的接收窗口还可以接受多少字节的数据量，用于TCP的流量控制，16位&lt;/li&gt;&#xA;&lt;li&gt;校验和：用于确认传输的数据有无损坏。发送端基于数据内容校验生成一个数值，接收端同样生成一个数值进行对比，相同的数据有效，反之无效则丢弃数据包，16位&lt;/li&gt;&#xA;&lt;li&gt;紧急指针：仅当标志位的URG字段值位1才有意义。指出有效载荷中位紧急数据的字节数。当所有紧急数据处理完，TCP告知应用程序恢复到正常操作。即使接收方窗口大小为0，也可以发送紧急数据，因为紧急数据无需缓存，16位&lt;/li&gt;&#xA;&lt;li&gt;选项字段：长度不定，但是必须是32bit的整数倍，即4字节的整数倍。内容可变，所以使用首部长度来区分选项部分的具体长度&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;如何分离首部和载荷确认首部长度&#34;&gt;&#xD;&#xA;  如何分离首部和载荷（确认首部长度）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a6%82%e4%bd%95%e5%88%86%e7%a6%bb%e9%a6%96%e9%83%a8%e5%92%8c%e8%bd%bd%e8%8d%b7%e7%a1%ae%e8%ae%a4%e9%a6%96%e9%83%a8%e9%95%bf%e5%ba%a6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;TCP固定首部长度20字节，以及选项字段&#xA;首部长度字段为4bits，最大可表示长度为1111，即15。表示单位是4字节&#xA;所以TCP首部最长是15*4 = 60字节&#xA;固定首部为20字节，选项部分为4字节的倍数，最大为40字节&#xA;这说明了数据偏移字段标识首部长度的原理&#xA;根据首部长度，可以分离首部和载荷&lt;/p&gt;&#xA;&lt;h2 id=&#34;连接的建立和断开&#34;&gt;&#xD;&#xA;  连接的建立和断开&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%9e%e6%8e%a5%e7%9a%84%e5%bb%ba%e7%ab%8b%e5%92%8c%e6%96%ad%e5%bc%80&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;TCP连接是TCP协议在网络中建立的可靠通信链路&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;这种可靠指的是不丢包，就是网络不太好的情况下可以尽量保证数据的完整接收（发送确认和重发）&lt;/p&gt;&#xA;&lt;p&gt;由IP协议锚定双方地址，由底层协议传输数据包，由高层协议进行数据的加解密&lt;/p&gt;&#xA;&lt;p&gt;换言之，TCP的可靠通信链路中保证的是传输和接收数据包的完整性，而不是包揽了链路的实际构建、数据包防伪等过程。不要把可靠性的理解在TCP扩展太多&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;为什么要建立连接&#34;&gt;&#xD;&#xA;  为什么要建立连接&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%bb%ba%e7%ab%8b%e8%bf%9e%e6%8e%a5&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;可靠性验证：建立连接的过程实际就是通信双方验证各自的发送和接受能力是否正常，双方的信道是否通畅&lt;/li&gt;&#xA;&lt;li&gt;协商参数：如序号初始值，MSS，是否启用SACK等&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;连接的建立---三次握手&#34;&gt;&#xD;&#xA;  连接的建立 - 三次握手&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%9e%e6%8e%a5%e7%9a%84%e5%bb%ba%e7%ab%8b---%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;服务器初始化状态&#xA;服务器端进程函数顺序：socket =&amp;gt; bind =&amp;gt; listen =&amp;gt; accept&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;socket()创建套接字listenfd&lt;/li&gt;&#xA;&lt;li&gt;bind()将套接字和端口绑定&lt;/li&gt;&#xA;&lt;li&gt;listen()让listenfd成为监听套接字，后续连接通过监听套接字获取，服务器处于监听状态&lt;/li&gt;&#xA;&lt;li&gt;accept()进程阻塞，直到有客户连接请求到达才返回&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;客户端发起连接请求 - 第一次握手&#xA;客户端进程函数顺序:socket =&amp;gt; connect&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;socket()创建套接字&lt;/li&gt;&#xA;&lt;li&gt;connect()调用时操作系统自动bind()，然后客户端进程就会向服务端进行发送连接请求报文&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;连接请求报文首部的标志位SYN=1&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
