<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CodeStack</title>
    <link>https://constructor-md.github.io/codestack/</link>
    <description>Recent content on CodeStack</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <atom:link href="https://constructor-md.github.io/codestack/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Ubuntu</title>
      <link>https://constructor-md.github.io/codestack/docs/deploy/ubuntu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/deploy/ubuntu/</guid>
      <description>&lt;h1 id=&#34;ubuntu&#34;&gt;&#xD;&#xA;  Ubuntu&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#ubuntu&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;采用版本：24.01&lt;/p&gt;&#xA;&lt;p&gt;安装过程：全部 Done&lt;/p&gt;&#xA;&lt;h2 id=&#34;非root用户上传文件&#34;&gt;&#xD;&#xA;  非Root用户上传文件&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%9d%9eroot%e7%94%a8%e6%88%b7%e4%b8%8a%e4%bc%a0%e6%96%87%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 赋予指定用户组用户在某个文件夹及其子文件夹上传文件的权限&#xD;&#xA; sudo chown -R quanta:quanta /DATA&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;时区设置&#34;&gt;&#xD;&#xA;  时区设置&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%97%b6%e5%8c%ba%e8%ae%be%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 查看当前时区&#xD;&#xA;timedatectl&#xD;&#xA;# 查看东八区全称&#xD;&#xA;timedatectl list-timezones | grep Shanghai&#xD;&#xA;# 设置时区&#xD;&#xA;sudo timedatectl set-timezone Asia/Shanghai&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;host设置&#34;&gt;&#xD;&#xA;  host设置&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#host%e8%ae%be%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;便于多主机内网互相访问&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo vim /etc/hosts&#xD;&#xA;&#xD;&#xA;# 补充相关机器的ip 主机名&#xD;&#xA;192.168.1.11 dataserver1&#xD;&#xA;192.168.1.12 dataserver2&#xD;&#xA;192.168.1.13 dataserver3&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;openssh安装&#34;&gt;&#xD;&#xA;  OpenSSH安装&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#openssh%e5%ae%89%e8%a3%85&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo apt update &amp;amp;&amp;amp; sudo apt upgrade&#xD;&#xA;sudo apt install openssh-server&#xD;&#xA;service ssh status&#xD;&#xA;# 随后可以本机SSH使用安装过程设置的账户密码登录服务器&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;修改监听端口&#34;&gt;&#xD;&#xA;  修改监听端口&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bf%ae%e6%94%b9%e7%9b%91%e5%90%ac%e7%ab%af%e5%8f%a3&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo vi /etc/ssh/sshd_config&#xD;&#xA;# 内容&#xD;&#xA;Port 2222&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修改后要重启&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL</title>
      <link>https://constructor-md.github.io/codestack/docs/deploy/mysql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/deploy/mysql/</guid>
      <description>&lt;h1 id=&#34;mysql&#34;&gt;&#xD;&#xA;  MySQL&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mysql&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;安装版本：MySQL 8.0.20&lt;/p&gt;&#xA;&lt;p&gt;部署方式：一主二从&lt;/p&gt;&#xA;&lt;p&gt;运行方式：docker-compose&lt;/p&gt;&#xA;&lt;h2 id=&#34;各节点安装&#34;&gt;&#xD;&#xA;  各节点安装&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%90%84%e8%8a%82%e7%82%b9%e5%ae%89%e8%a3%85&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;创建mysql目录&#34;&gt;&#xD;&#xA;  创建MySQL目录&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9b%e5%bb%bamysql%e7%9b%ae%e5%bd%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 放置所有mysql相关文件 比如my.cnf&#xD;&#xA;sudo mkdir /DATA/mysql&#xD;&#xA;# 放置mysql数据文件 也作为mysql&#xD;&#xA;sudo mkdir /DATA/mysql/mysql&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;创建mysql用户并设置权限&#34;&gt;&#xD;&#xA;  创建MySQL用户并设置权限&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9b%e5%bb%bamysql%e7%94%a8%e6%88%b7%e5%b9%b6%e8%ae%be%e7%bd%ae%e6%9d%83%e9%99%90&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 创建mysql用户 设置为不可登陆系统 并设置用户的主目录为/DATA/mysql/mysql&#xD;&#xA;sudo useradd -r -s /sbin/nologin -d /DATA/mysql/mysql mysql&#xD;&#xA;# 指定mysql用户的主目录为/DATA/mysql/mysql&#xD;&#xA;sudo usermod -d /DATA/mysql/mysql mysql&#xD;&#xA;# 递归地将/DATA/mysql/mysql目录及其所有子目录和文件的所有者和所属组设置为mysql用户和mysql组&#xD;&#xA;sudo chown -R mysql:mysql /DATA/mysql/mysql&#xD;&#xA;# 递归地将/DATA/mysql/mysql目录及其子目录设和文件的权限设置为755&#xD;&#xA;# 755：所有者有读写和执行权限，组用户和其他用户有读和执行权限&#xD;&#xA;sudo chmod -R 755 /DATA/mysql/mysql&#xD;&#xA;# 查找/etc/passwd文件中包含mysql的行 /etc/passwd是系统用户信息文件，包含所有用户的基本信息&#xD;&#xA;grep mysql /etc/passwd&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;操作失误时的可选操作&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 删除用户及其主目录 没有r不删除主目录&#xD;&#xA;sudo userdel -r mysql&#xD;&#xA;# 手动删除主目录&#xD;&#xA;sudo rm -rf /DATA/mysql&#xD;&#xA;# 检查 &#xD;&#xA;grep mysql /etc/passwd&#xD;&#xA;# 删除用户组&#xD;&#xA;sudo groupdel mysql&#xD;&#xA;# 检查用户组是否删除&#xD;&#xA;grep mysql /etc/group&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;docker-compose文件&#34;&gt;&#xD;&#xA;  docker-compose文件&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#docker-compose%e6%96%87%e4%bb%b6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 创建docker-compose文件在/DATA下，或者追加在已有文件中&#xD;&#xA;vim docker-compose.yml&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;docker-compose.yml&lt;/p&gt;</description>
    </item>
    <item>
      <title>Redis</title>
      <link>https://constructor-md.github.io/codestack/docs/deploy/redis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/deploy/redis/</guid>
      <description>&lt;h1 id=&#34;redis&#34;&gt;&#xD;&#xA;  Redis&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#redis&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;安装版本：7.0.4&lt;/p&gt;&#xA;&lt;p&gt;部署方式：一主二从三哨兵&lt;/p&gt;&#xA;&lt;p&gt;节点分配：每节点一个Redis-Server，一个Sentinel&lt;/p&gt;&#xA;&lt;p&gt;运行方式：docker-compose&lt;/p&gt;&#xA;&lt;h2 id=&#34;目录和用户权限&#34;&gt;&#xD;&#xA;  目录和用户权限&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%9b%ae%e5%bd%95%e5%92%8c%e7%94%a8%e6%88%b7%e6%9d%83%e9%99%90&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;创建redis和sentinel目录&#34;&gt;&#xD;&#xA;  创建Redis和Sentinel目录&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9b%e5%bb%baredis%e5%92%8csentinel%e7%9b%ae%e5%bd%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 存放所有Redis相关文件&#xD;&#xA;sudo mkdir /DATA/redis&#xD;&#xA;# 存放Redis和Sentinel配置文件&#xD;&#xA;sudo mkdir /DATA/redis/config&#xD;&#xA;# 存放Sentinel配置和文件&#xD;&#xA;sudo mkdir /DATA/redis/config/sentinel&#xD;&#xA;# 存放挂载docker内运行Redis的数据目录&#xD;&#xA;sudo mkdir /DATA/redis/data&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;创建redis用户并设置工作目录&#34;&gt;&#xD;&#xA;  创建redis用户并设置工作目录&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9b%e5%bb%baredis%e7%94%a8%e6%88%b7%e5%b9%b6%e8%ae%be%e7%bd%ae%e5%b7%a5%e4%bd%9c%e7%9b%ae%e5%bd%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 创建 redis 用户 设置为不可登陆系统 并设置用户的主目录为/DATA/redis/data&#xD;&#xA;sudo useradd -r -s /sbin/nologin -d /DATA/redis/data redis&#xD;&#xA;# 指定 redis 用户的主目录为/DATA/redis/data&#xD;&#xA;sudo usermod -d /DATA/redis/data redis&#xD;&#xA;# 递归地将/DATA/redis/data目录及其所有子目录和文件的所有者和所属组设置为redis用户和redis组&#xD;&#xA;sudo chown -R redis:redis /DATA/redis/data&#xD;&#xA;# 递归地将/DATA/redis/data目录及其子目录设和文件的权限设置为755&#xD;&#xA;# 755：所有者有读写和执行权限，组用户和其他用户有读和执行权限&#xD;&#xA;sudo chmod -R 755 /DATA/redis/data&#xD;&#xA;# 查找/etc/passwd文件中包含mysql的行 /etc/passwd是系统用户信息文件，包含所有用户的基本信息&#xD;&#xA;grep redis /etc/passwd&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;主节点配置&#34;&gt;&#xD;&#xA;  主节点配置&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%bb%e8%8a%82%e7%82%b9%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;redisconf&#34;&gt;&#xD;&#xA;  redis.conf&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#redisconf&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo vim /DATA/redis/config/redis.conf&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# 监听端口&#xD;&#xA;port 63790&#xD;&#xA;# 访问密码&#xD;&#xA;requirepass password&#xD;&#xA;# 数据库数量 使用cluster模式时只会有一个database即DB0&#xD;&#xA;databases 16&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# 绑定本机的网络接口（网卡） 绑定的是网卡的IP地址&#xD;&#xA;# 0.0.0.0 监听所有 默认127.0.0.1&#xD;&#xA;bind 0.0.0.0&#xD;&#xA;&#xD;&#xA;# 默认开启&#xD;&#xA;# 如果没有设置密码和且没有设置bind，只允许本机访问&#xD;&#xA;protected-mode yes&#xD;&#xA;&#xD;&#xA;# 单位秒，timeout时间内客户端没有数据交互，关闭连接&#xD;&#xA;timeout 60&#xD;&#xA;&#xD;&#xA;# 客户端同时连接的最大数量 默认10000&#xD;&#xA;# 达到最大值时关闭新连接并返回max number of clients reached&#xD;&#xA;maxclients 1000&#xD;&#xA;&#xD;&#xA;# 内存管理 &#xD;&#xA;# 最大内存，推荐最大设置为6GB&#xD;&#xA;# 不要设置过大内存，防止执行RDB内存快照文件或者AOF重写时因为数据太大阻塞太长时间&#xD;&#xA;maxmemory 2GB&#xD;&#xA;&#xD;&#xA;# 内存淘汰策略 默认noeviction&#xD;&#xA;# noeviction -&amp;gt; 不删除任何 key，内存满了直接返回报错&#xD;&#xA;# 默认情况下slave节点会忽略maxmemory配置，除非被提升为master&#xD;&#xA;# 只有master会执行内存淘汰策略，master删除key后会发送DEL指令给slave&#xD;&#xA;maxmemory-policy noeviction&#xD;&#xA;&#xD;&#xA;# 过期key滞留在内存的比例 默认值为1 表示10%&#xD;&#xA;# 设置的越小，一次淘汰周期需要消耗的CPU更多 需要删除更多的过期数据&#xD;&#xA;active-expire-effort 1&#xD;&#xA;&#xD;&#xA;# 持久化&#xD;&#xA;# AOF持久化开启&#xD;&#xA;appendonly yes&#xD;&#xA;&#xD;&#xA;# AOF 持久化模式，默认为 &amp;#34;always&amp;#34;。可以是 always、everysec 或 no&#xD;&#xA;# always：每个写操作都立即同步到磁盘，最费性能&#xD;&#xA;# everysec：每秒钟同步一次到磁盘，折中的选择&#xD;&#xA;# no：完全依赖操作系统的行为，可能会丢失数据，但性能最高&#xD;&#xA;appendfsync everysec&#xD;&#xA;&#xD;&#xA;# AOF-RDB混合持久化&#xD;&#xA;# 配置成yes必须先开启AOF AOF重写生成的文件将同时包含RDB和AOF格式内容&#xD;&#xA;# 推荐开启&#xD;&#xA;aof-use-rdb-preamble yes&#xD;&#xA;&#xD;&#xA;# 性能监控&#xD;&#xA;# 慢查询日志 执行时间只是命令阶段的时间，不包括建立连接发送回复等&#xD;&#xA;# slow log 仅保存在内存中，效率很高&#xD;&#xA;# 执行时间大于多少微秒的查询进行记录 1s = 1,000,000微秒 默认10000&#xD;&#xA;slowlog-log-slower-than 10000&#xD;&#xA;&#xD;&#xA;# 最多保存多少条慢查询日志 slowlog本身是FIFO 默认128&#xD;&#xA;slowlog-max-len 128&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;sentinelconf&#34;&gt;&#xD;&#xA;  sentinel.conf&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#sentinelconf&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo vim /DATA/redis/config/sentinel/sentinel.conf&#xD;&#xA;&#xD;&#xA;# 哨兵端口&#xD;&#xA;port 26379&#xD;&#xA;&#xD;&#xA;# 监控的redis主节点的ip port&#xD;&#xA;# master-name 自定义&#xD;&#xA;# quorum 多少个sentinel主观认为master失联，认为客观上master失联&#xD;&#xA;# sentinel monitor &amp;lt;master-name&amp;gt; &amp;lt;ip&amp;gt; &amp;lt;redis-port&amp;gt; &amp;lt;quorum&amp;gt;&#xD;&#xA;sentinel monitor mymaster 192.168.1.11 63790 2&#xD;&#xA;&#xD;&#xA;# redis实例的密码 主从的访问密码必须要一样&#xD;&#xA;sentinel auth-pass mymaster password&#xD;&#xA;&#xD;&#xA;# 指定多少毫秒之后主节点没有应答哨兵&#xD;&#xA;# 此时哨兵主观上认为主节点下线&#xD;&#xA;# 默认30秒&#xD;&#xA;# sentinel down-after-milliseconds &amp;lt;master-name&amp;gt; &amp;lt;milliseconds&amp;gt;&#xD;&#xA;sentinel down-after-milliseconds mymaster 30000&#xD;&#xA;&#xD;&#xA;# 设置故障转移时，从节点同步新主节点数据的并发数量&#xD;&#xA;# 值越小，对主节点的压力越小，但同步速度可能较慢&#xD;&#xA;# sentinel parallel-syncs &amp;lt;master-name&amp;gt; &amp;lt;numslaves&amp;gt;&#xD;&#xA;sentinel parallel-syncs mymaster 1&#xD;&#xA;&#xD;&#xA;# 设置故障转移的超时时间（单位：毫秒）&#xD;&#xA;# 如果故障转移在这个时间内没有完成，则认为失败&#xD;&#xA;sentinel failover-timeout mymaster 180000&#xD;&#xA;&#xD;&#xA;# 配置哨兵自身的ip 避免走自动检测给出其他哨兵访问不到的地址&#xD;&#xA;sentinel announce-ip 192.168.1.11&#xD;&#xA;sentinel announce-port 36379&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;docker-composeyml&#34;&gt;&#xD;&#xA;  docker-compose.yml&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#docker-composeyml&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo vim /DATA/docker-compose.yml&#xD;&#xA;&#xD;&#xA;version: &amp;#39;3&amp;#39;  # 使用docker-compose版本3&#xD;&#xA;services:  # 定义服务&#xD;&#xA;    redis7:&#xD;&#xA;      image: redis:7.0.4&#xD;&#xA;      container_name: redis7&#xD;&#xA;      user: &amp;#34;996:986&amp;#34;&#xD;&#xA;      restart: always&#xD;&#xA;      ports:&#xD;&#xA;        - 63790:63790&#xD;&#xA;      environment:&#xD;&#xA;        TZ: &amp;#34;Asia/Shanghai&amp;#34;&#xD;&#xA;      volumes:&#xD;&#xA;        - /DATA/redis/config/redis.conf:/etc/redis/redis.conf&#xD;&#xA;        - /DATA/redis/data:/data&#xD;&#xA;      command: [&amp;#34;redis-server&amp;#34;, &amp;#34;/etc/redis/redis.conf&amp;#34;]&#xD;&#xA;    sentinel:&#xD;&#xA;      image: redis:7.0.4&#xD;&#xA;      container_name: sentinel&#xD;&#xA;      restart: always&#xD;&#xA;      ports:&#xD;&#xA;        - 36379:26379&#xD;&#xA;      volumes:&#xD;&#xA;        - /DATA/redis/config/sentinel:/etc/redis/config/sentinel&#xD;&#xA;      environment:&#xD;&#xA;        TZ: &amp;#34;Asia/Shanghai&amp;#34;&#xD;&#xA;      command: [&amp;#34;redis-sentinel&amp;#34;, &amp;#34;/etc/redis/config/sentinel/sentinel.conf&amp;#34;]&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;docker-composeyml语法验证&#34;&gt;&#xD;&#xA;  docker-compose.yml语法验证&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#docker-composeyml%e8%af%ad%e6%b3%95%e9%aa%8c%e8%af%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker-compose config&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;子节点配置&#34;&gt;&#xD;&#xA;  子节点配置&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ad%90%e8%8a%82%e7%82%b9%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;redisconf-1&#34;&gt;&#xD;&#xA;  redis.conf&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#redisconf-1&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo vim /DATA/redis/config/redis.conf&#xD;&#xA;&#xD;&#xA;# 监听端口 sentinel不知道外面映射啥端口，只好把内外端口设置一样&#xD;&#xA;port 63790&#xD;&#xA;# 访问密码&#xD;&#xA;requirepass password&#xD;&#xA;# 数据库数量 使用cluster模式时只会有一个database即DB0&#xD;&#xA;databases 16&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# 绑定本机的网络接口（网卡） 绑定的是网卡的IP地址&#xD;&#xA;# 0.0.0.0 监听所有 默认127.0.0.1&#xD;&#xA;bind 0.0.0.0&#xD;&#xA;&#xD;&#xA;# 默认开启&#xD;&#xA;# 如果没有设置密码和且没有设置bind，只允许本机访问&#xD;&#xA;protected-mode yes&#xD;&#xA;&#xD;&#xA;# 单位秒，timeout时间内客户端没有数据交互，关闭连接&#xD;&#xA;timeout 60&#xD;&#xA;&#xD;&#xA;# 客户端同时连接的最大数量 默认10000&#xD;&#xA;# 达到最大值时关闭新连接并返回max number of clients reached&#xD;&#xA;maxclients 1000&#xD;&#xA;&#xD;&#xA;# 内存管理 &#xD;&#xA;# 最大内存，推荐最大设置为6GB&#xD;&#xA;# 不要设置过大内存，防止执行RDB内存快照文件或者AOF重写时因为数据太大阻塞太长时间&#xD;&#xA;maxmemory 2GB&#xD;&#xA;&#xD;&#xA;# 内存淘汰策略 默认noeviction&#xD;&#xA;# noeviction -&amp;gt; 不删除任何 key，内存满了直接返回报错&#xD;&#xA;# 默认情况下slave节点会忽略maxmemory配置，除非被提升为master&#xD;&#xA;# 只有master会执行内存淘汰策略，master删除key后会发送DEL指令给slave&#xD;&#xA;maxmemory-policy noeviction&#xD;&#xA;&#xD;&#xA;# 过期key滞留在内存的比例 默认值为1 表示10%&#xD;&#xA;# 设置的越小，一次淘汰周期需要消耗的CPU更多 需要删除更多的过期数据&#xD;&#xA;active-expire-effort 1&#xD;&#xA;&#xD;&#xA;# 持久化&#xD;&#xA;# AOF持久化开启&#xD;&#xA;appendonly yes&#xD;&#xA;&#xD;&#xA;# AOF 持久化模式，默认为 &amp;#34;always&amp;#34;。可以是 always、everysec 或 no&#xD;&#xA;# always：每个写操作都立即同步到磁盘，最费性能&#xD;&#xA;# everysec：每秒钟同步一次到磁盘，折中的选择&#xD;&#xA;# no：完全依赖操作系统的行为，可能会丢失数据，但性能最高&#xD;&#xA;appendfsync everysec&#xD;&#xA;&#xD;&#xA;# AOF-RDB混合持久化&#xD;&#xA;# 配置成yes必须先开启AOF AOF重写生成的文件将同时包含RDB和AOF格式内容&#xD;&#xA;# 推荐开启&#xD;&#xA;aof-use-rdb-preamble yes&#xD;&#xA;&#xD;&#xA;# 性能监控&#xD;&#xA;# 慢查询日志 执行时间只是命令阶段的时间，不包括建立连接发送回复等&#xD;&#xA;# slow log 仅保存在内存中，效率很高&#xD;&#xA;# 执行时间大于多少微秒的查询进行记录 1s = 1,000,000微秒 默认10000&#xD;&#xA;slowlog-log-slower-than 10000&#xD;&#xA;&#xD;&#xA;# 最多保存多少条慢查询日志 slowlog本身是FIFO 默认128&#xD;&#xA;slowlog-max-len 128&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# 主从复制&#xD;&#xA;# replicaof &amp;lt;masterip&amp;gt; &amp;lt;masterport&amp;gt;将当前实例成为master的从节点&#xD;&#xA;replicaof 192.168.1.11 63790&#xD;&#xA;&#xD;&#xA;# master节点的requiepass&#xD;&#xA;masterauth bucunzaide82838161&#xD;&#xA;&#xD;&#xA;# 从节点只读，默认为yes，建议保留默认配置&#xD;&#xA;replica-read-only yes&#xD;&#xA;&#xD;&#xA;# slave每10s Ping一次master&#xD;&#xA;repl-ping-replica-period 10&#xD;&#xA;&#xD;&#xA;# slave与master之间的复制超时时间，默认60s&#xD;&#xA;repl-timeout 60&#xD;&#xA;&#xD;&#xA;# slave优先级 哨兵使用 默认100&#xD;&#xA;# master节点挂掉，哨兵选择priority最小的slave节点作为新的master&#xD;&#xA;replica-priority 100&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;sentinelconf-1&#34;&gt;&#xD;&#xA;  sentinel.conf&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#sentinelconf-1&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo scp -P 2222 quanta@192.168.1.11:/DATA/redis/config/sentinel.conf /DATA/redis/config/sentinel.conf&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修改配置sentinel ip&lt;/p&gt;</description>
    </item>
    <item>
      <title>ElasticSearch</title>
      <link>https://constructor-md.github.io/codestack/docs/deploy/elasticsearch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/deploy/elasticsearch/</guid>
      <description>&lt;h1 id=&#34;elasticsearch&#34;&gt;&#xD;&#xA;  ElasticSearch&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#elasticsearch&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;安装版本：8.15.0&lt;/p&gt;&#xA;&lt;p&gt;部署方式：三节点&lt;/p&gt;&#xA;&lt;p&gt;运行方式：docker-compose&lt;/p&gt;&#xA;&lt;h2 id=&#34;linux系统设置&#34;&gt;&#xD;&#xA;  Linux系统设置&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#linux%e7%b3%bb%e7%bb%9f%e8%ae%be%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 修改内核参数&#xD;&#xA;# 设置每个进程最多拥有的最大内存映射区域数量 默认65536对ES来说不足&#xD;&#xA;echo &amp;#34;vm.max_map_count=262144&amp;#34; | sudo tee -a /etc/sysctl.conf&#xD;&#xA;sudo sysctl -p&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;创建目录&#34;&gt;&#xD;&#xA;  创建目录&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9b%e5%bb%ba%e7%9b%ae%e5%bd%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo mkdir /DATA/es /DATA/es/data /DATA/es/logs /DATA/es/plugins /DATA/es/config&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;权限设置&#34;&gt;&#xD;&#xA;  权限设置&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9d%83%e9%99%90%e8%ae%be%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo chmod -R 777 /DATA/es/data /DATA/es/logs /DATA/es/plugins /DATA/es/config&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;各单节点启动获取官方配置&#34;&gt;&#xD;&#xA;  各单节点启动获取官方配置&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%90%84%e5%8d%95%e8%8a%82%e7%82%b9%e5%90%af%e5%8a%a8%e8%8e%b7%e5%8f%96%e5%ae%98%e6%96%b9%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo vim /DATA/docker-compose.yml&#xD;&#xA;&#xD;&#xA;version: &amp;#39;3&amp;#39;&#xD;&#xA;services:&#xD;&#xA;  es:&#xD;&#xA;      image: docker.elastic.co/elasticsearch/elasticsearch:8.15.0&#xD;&#xA;      container_name: es&#xD;&#xA;      restart: always&#xD;&#xA;      environment:&#xD;&#xA;        - &amp;#34;ES_JAVA_OPTS=-Xms4g -Xmx4g&amp;#34; # 宿主机最大内存的一半 再留点给其他应用&#xD;&#xA;        - &amp;#34;ELASTIC_PASSWORD=bucunzaide2333&amp;#34;&#xD;&#xA;        - &amp;#34;TZ=Asia/Shanghai&amp;#34;&#xD;&#xA;      ports:&#xD;&#xA;        - &amp;#34;19200:19200&amp;#34;&#xD;&#xA;        - &amp;#34;19300:19300&amp;#34;&#xD;&#xA;      volumes:&#xD;&#xA;        - /DATA/es/data:/usr/share/elasticsearch/data&#xD;&#xA;        - /DATA/es/logs:/usr/share/elasticsearch/logs&#xD;&#xA;        - /etc/hosts:/etc/hosts&#xD;&#xA;        - es_config:/usr/share/elasticsearch/config&#xD;&#xA;        - /DATA/es/plugins:/usr/share/elasticsearch/plugins&#xD;&#xA;      ulimits:&#xD;&#xA;        # mmap 映射内存不限制&#xD;&#xA;        memlock:&#xD;&#xA;          soft: -1                  &#xD;&#xA;          hard: -1&#xD;&#xA;        # 文件描述符打开个数修改    &#xD;&#xA;        nofile:                                          &#xD;&#xA;          soft: 65535                             &#xD;&#xA;          hard: 65535&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# 末尾添加 作用是不要让宿主机空目录覆盖&#xD;&#xA;volumes:&#xD;&#xA;      es_config:&#xD;&#xA;        driver: local&#xD;&#xA;        driver_opts:&#xD;&#xA;          type: none&#xD;&#xA;          device: /DATA/es/config&#xD;&#xA;          o: bind&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;#mmap 映射内存不限制&lt;/p&gt;</description>
    </item>
    <item>
      <title>MinIO</title>
      <link>https://constructor-md.github.io/codestack/docs/deploy/minio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/deploy/minio/</guid>
      <description>&lt;h1 id=&#34;minio&#34;&gt;&#xD;&#xA;  MinIO&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#minio&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;部署方式：单节点&lt;/p&gt;&#xA;&lt;p&gt;运行方式：docker-compose&lt;/p&gt;&#xA;&lt;h2 id=&#34;目录创建&#34;&gt;&#xD;&#xA;  目录创建&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%9b%ae%e5%bd%95%e5%88%9b%e5%bb%ba&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo mkdir /DATA/minio /DATA/minio/data /DATA/minio/config&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;docker-composeyml&#34;&gt;&#xD;&#xA;  docker-compose.yml&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#docker-composeyml&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo vim /DATA/docker-compose.yml&#xD;&#xA;&#xD;&#xA;services:&#xD;&#xA;  minio:&#xD;&#xA;    image: minio/minio&#xD;&#xA;    restart: always&#xD;&#xA;    mem_limit: 1G&#xD;&#xA;    ports:&#xD;&#xA;      - &amp;#34;9000:9000&amp;#34;&#xD;&#xA;      - &amp;#34;19001:9001&amp;#34;&#xD;&#xA;    container_name: minio&#xD;&#xA;    command: server /data --console-address &amp;#34;:9001&amp;#34;&#xD;&#xA;    environment:&#xD;&#xA;      - MINIO_ROOT_USER=admin&#xD;&#xA;      - MINIO_ROOT_PASSWORD=_admin123&#xD;&#xA;      - MINIO_BROWSER_DEFAULT_LOCALE=zh_CN&#xD;&#xA;    volumes:&#xD;&#xA;      - /DATA/minio/data:/data&#xD;&#xA;      - /DATA/minio/config:/root/.minio&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;9000 是MInIO S3 API端口&#xA;9001 是MinIO WebUI 控制台端口&#xA;需要的节点才映射出来即可&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;启动&#34;&gt;&#xD;&#xA;  启动&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%90%af%e5%8a%a8&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo docker-compose up -d minio&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;防火墙打开&#34;&gt;&#xD;&#xA;  防火墙打开&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%98%b2%e7%81%ab%e5%a2%99%e6%89%93%e5%bc%80&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo ufw allow 19001/tcp&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>MVCC 多版本并发控制</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/mysql/mvcc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/mysql/mvcc/</guid>
      <description>&lt;h1 id=&#34;mvcc-多版本并发控制&#34;&gt;&#xD;&#xA;  MVCC 多版本并发控制&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mvcc-%e5%a4%9a%e7%89%88%e6%9c%ac%e5%b9%b6%e5%8f%91%e6%8e%a7%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;版本链&#34;&gt;&#xD;&#xA;  版本链&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%89%88%e6%9c%ac%e9%93%be&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;数据库中，以最新记录和undolog中的历史记录形成了版本链&lt;/p&gt;&#xA;&lt;p&gt;版本链中每个版本，除了具体行数据之外，还有该版本的事务ID、和回滚指针，每一行记录都有这两个隐藏列&lt;/p&gt;&#xA;&lt;p&gt;每个版本的回滚指针指向上一个版本&lt;/p&gt;&#xA;&lt;h2 id=&#34;readview-快照数据&#34;&gt;&#xD;&#xA;  ReadView 快照数据&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#readview-%e5%bf%ab%e7%85%a7%e6%95%b0%e6%8d%ae&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;作用：让数据库知道在具体查询的时候，应该去查询哪个版本的数据&lt;/p&gt;&#xA;&lt;p&gt;数据结构：代码里的一个对象&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;M_ids: 生成ReadView时当前系统中活跃的读写事务的事务id列表（未提交）&lt;/li&gt;&#xA;&lt;li&gt;Min_trax_id: 生成ReadView时当前系统中活跃的读写事务的最小事务id m_ids的最小值（最老的一个未提交）&lt;/li&gt;&#xA;&lt;li&gt;Max_trx_id: 生成ReadView时系统应该分配给下一个事务的id值（未生成即将生成）&lt;/li&gt;&#xA;&lt;li&gt;Creator_trx_id: 生成该ReadView的事务的id（创建者）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;ReadView如何判断版本链中哪个版本可用？&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Trx_id == creator_trx_id 可以访问这个版本（创建者可以访问）&lt;/li&gt;&#xA;&lt;li&gt;Trx_id &amp;lt; min_trx_id 可以访问这个版本（可以访问已提交的数据）&lt;/li&gt;&#xA;&lt;li&gt;Trx_id &amp;gt; max_trx_id 不可以访问这个版本（当前事务不能访问超过当前版本链的数据）&lt;/li&gt;&#xA;&lt;li&gt;Min_trx_id &amp;lt;= trx_id &amp;lt;= max_trx_id 如果trx_id在m_ids中，就可以不访问这个版本，因为里面的数据都没有commit&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;readview如何实现读已提交和可重复读&#34;&gt;&#xD;&#xA;  ReadView如何实现读已提交和可重复读？&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#readview%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e8%af%bb%e5%b7%b2%e6%8f%90%e4%ba%a4%e5%92%8c%e5%8f%af%e9%87%8d%e5%a4%8d%e8%af%bb&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;版本链是全局的，没有事务时版本链的头部是最新数据，后面是每个版本的历史数据&lt;/p&gt;&#xA;&lt;p&gt;如果有多个事务同时更新某一行数据，每个事务的更新，都会在版本链上生成一个版本&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;执行一个select前&#xA;先生成一个当前事务的ReadView，ReadView包含上述数据&lt;/li&gt;&#xA;&lt;li&gt;让ReadView在版本链从头到尾比较：(版本数据对查询的可见性)&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果该版本是当前事务提交的，那自然可以访问该数据，且该版本未提交也可以访问&lt;/li&gt;&#xA;&lt;li&gt;如果该版本不是当前事务提交，但是是已提交的数据，当然可以访问&lt;/li&gt;&#xA;&lt;li&gt;如果该版本数据是当前事务之后生成的事务生成的版本，那么肯定没有提交，不能访问&lt;/li&gt;&#xA;&lt;li&gt;如果该版本数据是当前事务生成ReadView时的未提交事务之一，那么不能访问这些未提交的数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;事务隔离级别与mvcc&#34;&gt;&#xD;&#xA;  事务隔离级别与MVCC&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8b%e5%8a%a1%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab%e4%b8%8emvcc&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;如果是读已提交：&#xA;则每次select都会生成ReadView，使得除了creator_trx_id以外的数据有所变化&lt;/p&gt;&#xA;&lt;p&gt;于是每次select都可以访问到最新的提交数据，或者是自己的修改数据&lt;/p&gt;&#xA;&lt;p&gt;访问到的最新提交数据可能变化&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;如果是可重复读：&#xA;仅在第一次select生成ReadView&lt;/p&gt;&#xA;&lt;p&gt;从而每次要么访问到自己的最新修改，要么一直是生成当时的最新提交数据，不会变化&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;如果是读未提交：&#xA;则每次直接访问最新的版本链数据，不关心是否提交，不需要MVCC&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;如果是串行化：&#xA;则通过加锁互斥访问，不需要MVCC&lt;/p&gt;</description>
    </item>
    <item>
      <title>日志文件及作用</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/mysql/logfile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/mysql/logfile/</guid>
      <description>&lt;h1 id=&#34;日志文件及作用&#34;&gt;&#xD;&#xA;  日志文件及作用&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%97%a5%e5%bf%97%e6%96%87%e4%bb%b6%e5%8f%8a%e4%bd%9c%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;errorlog-错误日志&#34;&gt;&#xD;&#xA;  error.log 错误日志：&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#errorlog-%e9%94%99%e8%af%af%e6%97%a5%e5%bf%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt;对MySQL的启动、运行、关闭过程进行了记录&#xD;&#xA;用于问题的排查，如例如权限问题、配置错误、磁盘空间不足&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;slowlog-慢查询日志&#34;&gt;&#xD;&#xA;  slow.log 慢查询日志：&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#slowlog-%e6%85%a2%e6%9f%a5%e8%af%a2%e6%97%a5%e5%bf%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt;可通过slow_query_log_file参数在配置文件中指定文件名，若未指定，默认在数据目录下，文件名为hostname-slow.log&#xD;&#xA;默认情况下不启动慢查询日志，需要手动设置&#xD;&#xA;用于定位执行时间超过设置值的SQL，以及没有使用索引的SQL&#xD;&#xA;可以通过mysqldupmslow查找和筛选慢查询日志的内容&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;查询日志&#34;&gt;&#xD;&#xA;  查询日志：&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9f%a5%e8%af%a2%e6%97%a5%e5%bf%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt;其文件名可通过general_log_file参数在配置文件中指定，若未指定，默认在数据目录下，文件名为hostname.log&#xD;&#xA;记录了所有对MySQL数据库请求的信息，不论是否得到了正确执行&#xD;&#xA;但由于会记录所有语句，开启该日志会对性能产生较大影响，所以通常只在调试或测试环境中开启&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;二进制日志binlog&#34;&gt;&#xD;&#xA;  二进制日志bin.log&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%97%a5%e5%bf%97binlog&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt;二进制日志由一系列文件组成，文件名格式为binlog.xxxxxx ，其中xxxxxx是一个 6 位的数字序号，从 000001 开始递增。其文件名前缀可通过log_bin参数在配置文件中指定&#xD;&#xA;记录了所有对MySQL数据库进行的更改&#xD;&#xA;作用：&#xD;&#xA;    数据恢复，数据库全备文件恢复&#xD;&#xA;    主从复制，通过复制和执行二进制日志，使从库和主库实时同步&#xD;&#xA;    审计判断是否有对数据库攻击&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;中继日志relay-log&#34;&gt;&#xD;&#xA;  中继日志（Relay Log）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ad%e7%bb%a7%e6%97%a5%e5%bf%97relay-log&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt;文件名格式为relay-log.xxxxxx ，其中xxxxxx是一个 6 位的数字序号，从 000001 开始递增。文件名前缀可通过relay_log参数在配置文件中指定。&#xD;&#xA;作用：&#xD;&#xA;    在主从复制架构中，从服务器从主服务器接收二进制日志内容后，会将其存储在中继日志中&#xD;&#xA;    从服务器的 SQL 线程会读取中继日志中的内容，并在本地执行相应的 SQL 语句，从而实现数据的同步&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;事务日志innodb&#34;&gt;&#xD;&#xA;  事务日志（Innodb）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8b%e5%8a%a1%e6%97%a5%e5%bf%97innodb&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;redo-log&#34;&gt;&#xD;&#xA;  Redo log:&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#redo-log&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt;默认文件名为ib_logfile0、ib_logfile1等，可通过innodb_log_files_in_group参数指定日志文件的数量，通过innodb_log_file_size参数指定每个日志文件的大小。&#xD;&#xA;用于保证事务的持久性&#xD;&#xA;MySQL中有大量缓存，数据修改时首先更新缓存，但是缓存并非马上同步到磁盘，即为脏页&#xD;&#xA;但是数据库如果宕机，则内存数据丢失，重启无法恢复&#xD;&#xA;所以每次修改内存就要写redo log，redo log顺序写入，磁盘的顺序读写速度远快于随机读写，写操作对性能影响较小&#xD;&#xA;Redo log是物理日志，记录数据页的物理修改，用于恢复提交后的物理数据页&#xD;&#xA;如果数据库意外重启，会根据redo log进行数据恢复&#xD;&#xA;如果redo log有事务提交，则提交事务修改数据。也仅能恢复到数据最后提交的状态&#xD;&#xA;可以利用 Redo Log 将未写入磁盘的数据页恢复到崩溃前的状态&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;undo-log&#34;&gt;&#xD;&#xA;  Undo log:&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#undo-log&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt;InnoDB Undo Log 没有单独的文件名，它是存储在系统表空间（ibdata1）或独立的 undo 表空间中的。可通过innodb_undo_tablespaces参数指定独立 undo 表空间的数量&#xD;&#xA;undo log是逻辑日志，每次修改数据，undolog中出现一条反操作的记录&#xD;&#xA;可以用于事务回滚，也可以根据undolog回溯到某个特定版本的数据&#xD;&#xA;用于实现事务的原子性和多版本并发控制（MVCC）&#xD;&#xA;在事务执行过程中，Undo Log 会记录数据修改前的状态，当事务需要回滚时，可以根据 Undo Log 将数据恢复到事务开始前的状态&#xD;&#xA;同时，MVCC 通过 Undo Log 提供数据的多个版本，使得不同事务可以同时访问同一数据的不同版本，提高并发性能&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Explain参数解释和查询成本分析</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/mysql/explain/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/mysql/explain/</guid>
      <description>&lt;h1 id=&#34;explain参数解释和查询成本分析&#34;&gt;&#xD;&#xA;  Explain参数解释和查询成本分析&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#explain%e5%8f%82%e6%95%b0%e8%a7%a3%e9%87%8a%e5%92%8c%e6%9f%a5%e8%af%a2%e6%88%90%e6%9c%ac%e5%88%86%e6%9e%90&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;explain&#34;&gt;&#xD;&#xA;  Explain&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#explain&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;通过执行 explain [sql] 得到执行计划&lt;/p&gt;&#xA;&lt;p&gt;如果from中包含自查虚拟，会查并生成临时表&lt;/p&gt;&#xA;&lt;p&gt;explain执行完之后执行show warnings，有时候可以直接拷贝出来直接使用，大多时候可以用于参考执行&lt;/p&gt;&#xA;&lt;h3 id=&#34;结果列分析&#34;&gt;&#xD;&#xA;  结果列分析&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%93%e6%9e%9c%e5%88%97%e5%88%86%e6%9e%90&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;h4 id=&#34;id&#34;&gt;&#xD;&#xA;  id&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#id&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;有几个select就有几个id，id按select出现的顺序增长，id大的先执行，null最后执行，相同则从上往下执行&lt;/p&gt;&#xA;&lt;h4 id=&#34;select_type&#34;&gt;&#xD;&#xA;  select_type&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#select_type&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;simple 简单查询，没有子查询和union&lt;/li&gt;&#xA;&lt;li&gt;primary 复杂查询中最外层迭代select&lt;/li&gt;&#xA;&lt;li&gt;subquery 包含在select中的子查询，不在from中&lt;/li&gt;&#xA;&lt;li&gt;dependent subquery select语句出现的子查询，依赖外部查询&lt;/li&gt;&#xA;&lt;li&gt;derived 包含在from子句的子查询，会把结果放在临时表（派生表）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;table&#34;&gt;&#xD;&#xA;  table&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#table&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;这一行的查询在访问哪个表&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;from子句有子查询时，table列是&lt;!-- raw HTML omitted --&gt;格式，表示当前查询依赖id=N的查询，会先执行id=N的查询&lt;/li&gt;&#xA;&lt;li&gt;有union时，union result的table列的值为union 1,2，1和2表示参与union的select的id&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;type&#34;&gt;&#xD;&#xA;  type&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#type&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;表示关联类型或访问类型，表示mysql决定如何查找表中的行，查找数据行记录的大概范围, 从最优到最差依次为：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;system &amp;gt; const &amp;gt; eq_ref &amp;gt; ref &amp;gt; range &amp;gt; index &amp;gt; ALL&#xA;一般来说应该最少把查询保持在range级别，最好达到ref&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;system MyIsm出现，表为空或者记录唯一时&lt;/li&gt;&#xA;&lt;li&gt;const 主键索引或唯一索引的等值查询&lt;/li&gt;&#xA;&lt;li&gt;eq_ref join的时候有驱动表和被驱动表，被驱动表走唯一或者主键索引时&lt;/li&gt;&#xA;&lt;li&gt;ref 非主键或非唯一索引的等值查询，关联查询时被驱动表的驱动键走非唯一索引&lt;/li&gt;&#xA;&lt;li&gt;range 一般索引的范围查询&lt;/li&gt;&#xA;&lt;li&gt;index 全表扫描，非聚簇索引的叶子节点&lt;/li&gt;&#xA;&lt;li&gt;All 聚簇索引的全表扫描&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;possible-keys列&#34;&gt;&#xD;&#xA;  possible keys列&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#possible-keys%e5%88%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;显示查询可能使用哪些索引来查找&lt;/p&gt;</description>
    </item>
    <item>
      <title>索引树高度计算</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/mysql/tree-high/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/mysql/tree-high/</guid>
      <description>&lt;h1 id=&#34;索引树高度计算&#34;&gt;&#xD;&#xA;  索引树高度计算&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b4%a2%e5%bc%95%e6%a0%91%e9%ab%98%e5%ba%a6%e8%ae%a1%e7%ae%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;基本原理&#34;&gt;&#xD;&#xA;  基本原理&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;Innodb是索引组织表，每个页都包含一个PAGE_LEVEL，表示当前页在索引上的高度&lt;/p&gt;&#xA;&lt;p&gt;默认叶子节点高度为0，ROOT节点PAGE_LEVEL+1就是这棵索引高度&lt;/p&gt;&#xA;&lt;p&gt;PAGE_LEVEL在每个页的64位偏移位置，占用2字节&lt;/p&gt;&#xA;&lt;p&gt;找到ROOT页位置，知道单页大小，使用hexdump在指定表空间找到第PAGE_NO页的64位偏移量的后两个字节即可&lt;/p&gt;&#xA;&lt;h2 id=&#34;找到root页信息&#34;&gt;&#xD;&#xA;  找到ROOT页信息&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%89%be%e5%88%b0root%e9%a1%b5%e4%bf%a1%e6%81%af&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;SELECT b.name, a.name, index_id, type, a.space, a.PAGE_NO&#xA;FROM information_schema.INNODB_SYS_INDEXES a,&#xA;information_schema.INNODB_SYS_TABLES b&#xA;WHERE a.table_id = b.table_id AND a.space &amp;lt;&amp;gt; 0;&lt;/p&gt;&#xA;&lt;p&gt;结果：&#xA;&lt;img src=&#34;./images/root-info.png&#34; alt=&#34;&amp;ldquo;root页信息&amp;rdquo;&#34; title=&#34;root页信息&#34;/&gt;&#xA;其中（space、PAGE_NO）指向ROOT页&lt;/p&gt;&#xA;&lt;p&gt;space是表空间，可以是系统表空间（如ibdata1文件）或独立表空间（如每个InnoDB表的.ibd文件）。表空间由多个区（extent）组成，每个区包含连续的页（page）&lt;/p&gt;&#xA;&lt;p&gt;也就是ROOT页是space的page_no页&lt;/p&gt;&#xA;&lt;h2 id=&#34;查看innodb_page_size&#34;&gt;&#xD;&#xA;  查看innodb_page_size&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9f%a5%e7%9c%8binnodb_page_size&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;show variables like &amp;#39;innodb_page_size&amp;#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结果：&#xA;&lt;img src=&#34;./images/innodb_page_size.png&#34; alt=&#34;&amp;ldquo;innodb_page_size&amp;rdquo;&#34; title=&#34;innodb_page_size&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;也就是Innodb默认的页大小16KB&lt;/p&gt;&#xA;&lt;h2 id=&#34;找到root的page_level得到索引高度&#34;&gt;&#xD;&#xA;  找到ROOT的PAGE_LEVEL，得到索引高度&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%89%be%e5%88%b0root%e7%9a%84page_level%e5%be%97%e5%88%b0%e7%b4%a2%e5%bc%95%e9%ab%98%e5%ba%a6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;首先要找到表对应的ibd文件，也就是表空间文件&lt;/p&gt;&#xA;&lt;p&gt;所在位置是MySQL的数据目录下的数据库名文件夹下&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#查找MySQL数据目录&#xD;&#xA;show variables like &amp;#39;datadir&amp;#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;./images/dir.png&#34; alt=&#34;&amp;ldquo;dir&amp;rdquo;&#34; title=&#34;dir&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;我的MySQL是用Docker起的，docker中没有安装hexdump命令，不过这个目录被挂载出来了，考虑在宿主机上分析其中的ibd文件&lt;/p&gt;&#xA;&lt;p&gt;但所在文件夹和文件权限限制了宿主机外用户访问文件夹和文件&#xA;&lt;img src=&#34;./images/docker-dir.png&#34; alt=&#34;&amp;ldquo;docker-dir&amp;rdquo;&#34; title=&#34;docker-dir&#34;/&gt;&#xA;修改权限需要到docker容器中修改该文件和对应文件夹权限&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;chmod 755 path&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;原本权限为750，禁止其他用户读写文件夹&lt;/p&gt;&#xA;&lt;p&gt;修改后在宿主机进入文件夹中，找到所需文件，在文件夹执行命令&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;hexdump -C -s 49216 -n 10 goods_info_100M.ibd&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;./images/page-info.png&#34; alt=&#34;&amp;ldquo;page-info&amp;rdquo;&#34; title=&#34;page-info&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;前两个字节是PAGE_LEVEL，所以这个索引树高度为3+1 = 4&lt;/p&gt;</description>
    </item>
    <item>
      <title>HTTP</title>
      <link>https://constructor-md.github.io/codestack/docs/basic/net/application/http/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/basic/net/application/http/</guid>
      <description>&lt;h1 id=&#34;http&#34;&gt;&#xD;&#xA;  HTTP&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#http&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;HTTP是应用层的，基于TCP的超文本传输协议&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;无状态：协议自身不对请求和响应之间的通信状态进行保存，任何两次请求之间没有依赖关系&lt;/li&gt;&#xA;&lt;li&gt;无连接：每次连接只处理一个请求&#xA;使用80作为默认端口&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;报文结构&#34;&gt;&#xD;&#xA;  报文结构&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8a%a5%e6%96%87%e7%bb%93%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;请求报文&#34;&gt;&#xD;&#xA;  请求报文&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%b7%e6%b1%82%e6%8a%a5%e6%96%87&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;&lt;img src=&#34;./images/request.png&#34; alt=&#34;请求报文&#34; title=&#34;请求报文&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;请求报文总体四个部分&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;请求行&#xA;包括请求方法、URL、协议版本，彼此使用空格分隔&lt;/li&gt;&#xA;&lt;li&gt;请求头&#xA;KV形式的辅助信息&lt;/li&gt;&#xA;&lt;li&gt;空行&#xA;分隔报头(请求行+请求头)和请求体，由回车符和换行符组成&lt;/li&gt;&#xA;&lt;li&gt;请求体&#xA;请求发送时携带的数据&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;请求行&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;方法&lt;/th&gt;&#xA;          &lt;th&gt;说明&lt;/th&gt;&#xA;          &lt;th&gt;支持的HTTP协议版本&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GET&lt;/td&gt;&#xA;          &lt;td&gt;获取资源&lt;/td&gt;&#xA;          &lt;td&gt;1.0，1.1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;POST&lt;/td&gt;&#xA;          &lt;td&gt;传输实体主体(提交信息)&lt;/td&gt;&#xA;          &lt;td&gt;1.0，1.1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;PUT&lt;/td&gt;&#xA;          &lt;td&gt;传输文件&lt;/td&gt;&#xA;          &lt;td&gt;1.0，1.1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;HEAD&lt;/td&gt;&#xA;          &lt;td&gt;获得报文首部&lt;/td&gt;&#xA;          &lt;td&gt;1.0，1.1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;DELETE&lt;/td&gt;&#xA;          &lt;td&gt;删除文件&lt;/td&gt;&#xA;          &lt;td&gt;1.0，1.1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;OPTIONS&lt;/td&gt;&#xA;          &lt;td&gt;询问支持的方法&lt;/td&gt;&#xA;          &lt;td&gt;1.1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;TRACE&lt;/td&gt;&#xA;          &lt;td&gt;追踪路径&lt;/td&gt;&#xA;          &lt;td&gt;1.1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CONNECT&lt;/td&gt;&#xA;          &lt;td&gt;要求用隧道协议连接代理&lt;/td&gt;&#xA;          &lt;td&gt;1.1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;LINK&lt;/td&gt;&#xA;          &lt;td&gt;建立和资源之间的联系&lt;/td&gt;&#xA;          &lt;td&gt;1.0&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;UNLINE&lt;/td&gt;&#xA;          &lt;td&gt;断开连接关系&lt;/td&gt;&#xA;          &lt;td&gt;1.0&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;请求头&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;请求头&lt;/th&gt;&#xA;          &lt;th&gt;含义&lt;/th&gt;&#xA;          &lt;th&gt;示例&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Cache-Control&lt;/td&gt;&#xA;          &lt;td&gt;用于控制缓存策略，设置缓存的行为，如是否允许缓存、缓存时间、缓存验证方式等&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;Cache-Control: max-age=3600&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Connection&lt;/td&gt;&#xA;          &lt;td&gt;指示客户端和服务器之间的连接选项，常见值有 &lt;code&gt;keep-alive&lt;/code&gt; 和 &lt;code&gt;close&lt;/code&gt;，分别表示保持连接和关闭连接&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;Connection: keep-alive&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Date&lt;/td&gt;&#xA;          &lt;td&gt;表示请求发送的日期和时间，采用 HTTP 日期格式，服务器可据此进行时间相关处理&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;Date: Wed, 18 Apr 2025 12:00:00 GMT&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Accept&lt;/td&gt;&#xA;          &lt;td&gt;告知服务器客户端能够接受的响应内容类型，服务器会根据此选择合适的内容格式返回&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Accept-Encoding&lt;/td&gt;&#xA;          &lt;td&gt;指定客户端能够接受的编码方式，如 &lt;code&gt;gzip&lt;/code&gt;、&lt;code&gt;deflate&lt;/code&gt; 等，服务器会对响应数据进行相应的编码压缩&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;Accept-Encoding: gzip, deflate&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Accept-Language&lt;/td&gt;&#xA;          &lt;td&gt;表示客户端偏好的语言，服务器可根据此返回对应语言的内容&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Host&lt;/td&gt;&#xA;          &lt;td&gt;指定请求的目标主机和端口号，用于区分同一服务器上的不同虚拟主机或服务&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;Host: www.example.com:8080&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Referer&lt;/td&gt;&#xA;          &lt;td&gt;标识请求发起的来源页面的 URL，服务器可以借此了解请求的上下文和来源路径&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;Referer: https://www.example.com/page1.html&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;User-Agent&lt;/td&gt;&#xA;          &lt;td&gt;包含客户端的相关信息，如浏览器类型、版本、操作系统等，服务器可根据此进行不同的适配和处理&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.5615.137 Safari/537.36&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Content-Type&lt;/td&gt;&#xA;          &lt;td&gt;用于 POST、PUT 等请求，指示请求体中数据的类型，如 &lt;code&gt;application/json&lt;/code&gt;、&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;、&lt;code&gt;multipart/form-data&lt;/code&gt; 等&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;Content-Type: application/json&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Content-Length&lt;/td&gt;&#xA;          &lt;td&gt;表示请求体的长度，以字节为单位，服务器可据此判断是否完整接收了请求数据&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;Content-Length: 1024&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;响应报文&#34;&gt;&#xD;&#xA;  响应报文&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%93%8d%e5%ba%94%e6%8a%a5%e6%96%87&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;&lt;img src=&#34;./images/response.png&#34; alt=&#34;响应报文&#34; title=&#34;响应报文&#34;/&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>TCP</title>
      <link>https://constructor-md.github.io/codestack/docs/basic/net/transport/tcp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/basic/net/transport/tcp/</guid>
      <description>&lt;h1 id=&#34;tcp&#34;&gt;&#xD;&#xA;  TCP&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#tcp&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议&lt;/p&gt;&#xA;&lt;h2 id=&#34;报文结构&#34;&gt;&#xD;&#xA;  报文结构&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8a%a5%e6%96%87%e7%bb%93%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;&lt;img src=&#34;./images/message.png&#34; alt=&#34;报文结构&#34; title=&#34;报文结构&#34;/&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;源端口：发送方使用的端口号，16位&lt;/li&gt;&#xA;&lt;li&gt;目的端口：接收方使用的端口号，16位&lt;/li&gt;&#xA;&lt;li&gt;序号：本报文段发送数据的第一个字节的编号，32位&lt;/li&gt;&#xA;&lt;li&gt;确认号：接收方期望接收到的下一个报文段的第一个字节的编号&lt;/li&gt;&#xA;&lt;li&gt;数据偏移(首部长度)：指数据段中的数据部分的起始处距离TCP报文段起始处的偏移量，也就是TCP报文的报头部分的长度，接收端根据这个知道数据（有效载荷）从何处开始 4位&lt;/li&gt;&#xA;&lt;li&gt;保留字段：TCP协议将来的发展预留的空间，目前必须全部为0，6位&lt;/li&gt;&#xA;&lt;li&gt;标志位字段：共六个标志位，每个1bit&lt;/li&gt;&#xA;&lt;li&gt;窗口大小：表示发送该TCP报文的接收窗口还可以接受多少字节的数据量，用于TCP的流量控制，16位&lt;/li&gt;&#xA;&lt;li&gt;校验和：用于确认传输的数据有无损坏。发送端基于数据内容校验生成一个数值，接收端同样生成一个数值进行对比，相同的数据有效，反之无效则丢弃数据包，16位&lt;/li&gt;&#xA;&lt;li&gt;紧急指针：仅当标志位的URG字段值位1才有意义。指出有效载荷中位紧急数据的字节数。当所有紧急数据处理完，TCP告知应用程序恢复到正常操作。即使接收方窗口大小为0，也可以发送紧急数据，因为紧急数据无需缓存，16位&lt;/li&gt;&#xA;&lt;li&gt;选项字段：长度不定，但是必须是32bit的整数倍，即4字节的整数倍。内容可变，所以使用首部长度来区分选项部分的具体长度&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;如何分离首部和载荷确认首部长度&#34;&gt;&#xD;&#xA;  如何分离首部和载荷（确认首部长度）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a6%82%e4%bd%95%e5%88%86%e7%a6%bb%e9%a6%96%e9%83%a8%e5%92%8c%e8%bd%bd%e8%8d%b7%e7%a1%ae%e8%ae%a4%e9%a6%96%e9%83%a8%e9%95%bf%e5%ba%a6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;TCP固定首部长度20字节，以及选项字段&#xA;首部长度字段为4bits，最大可表示长度为1111，即15。表示单位是4字节&#xA;所以TCP首部最长是15*4 = 60字节&#xA;固定首部为20字节，选项部分为4字节的倍数，最大为40字节&#xA;这说明了数据偏移字段标识首部长度的原理&#xA;根据首部长度，可以分离首部和载荷&lt;/p&gt;&#xA;&lt;h2 id=&#34;连接的建立和断开&#34;&gt;&#xD;&#xA;  连接的建立和断开&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%9e%e6%8e%a5%e7%9a%84%e5%bb%ba%e7%ab%8b%e5%92%8c%e6%96%ad%e5%bc%80&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;TCP连接是TCP协议在网络中建立的可靠通信链路&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;这种可靠指的是不丢包，就是网络不太好的情况下可以尽量保证数据的完整接收（发送确认和重发）&lt;/p&gt;&#xA;&lt;p&gt;由IP协议锚定双方地址，由底层协议传输数据包，由高层协议进行数据的加解密&lt;/p&gt;&#xA;&lt;p&gt;换言之，TCP的可靠通信链路中保证的是传输和接收数据包的完整性，而不是包揽了链路的实际构建、数据包防伪等过程。不要把可靠性的理解在TCP扩展太多&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;为什么要建立连接&#34;&gt;&#xD;&#xA;  为什么要建立连接&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%bb%ba%e7%ab%8b%e8%bf%9e%e6%8e%a5&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;可靠性验证：建立连接的过程实际就是通信双方验证各自的发送和接受能力是否正常，双方的信道是否通畅&lt;/li&gt;&#xA;&lt;li&gt;协商参数：如序号初始值，MSS，是否启用SACK等&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;连接的建立---三次握手&#34;&gt;&#xD;&#xA;  连接的建立 - 三次握手&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%9e%e6%8e%a5%e7%9a%84%e5%bb%ba%e7%ab%8b---%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;服务器初始化状态&#xA;服务器端进程函数顺序：socket =&amp;gt; bind =&amp;gt; listen =&amp;gt; accept&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;socket()创建套接字listenfd&lt;/li&gt;&#xA;&lt;li&gt;bind()将套接字和端口绑定&lt;/li&gt;&#xA;&lt;li&gt;listen()让listenfd成为监听套接字，后续连接通过监听套接字获取，服务器处于监听状态&lt;/li&gt;&#xA;&lt;li&gt;accept()进程阻塞，直到有客户连接请求到达才返回&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;客户端发起连接请求 - 第一次握手&#xA;客户端进程函数顺序:socket =&amp;gt; connect&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;socket()创建套接字&lt;/li&gt;&#xA;&lt;li&gt;connect()调用时操作系统自动bind()，然后客户端进程就会向服务端进行发送连接请求报文&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;连接请求报文首部的标志位SYN=1&lt;/p&gt;</description>
    </item>
    <item>
      <title>依赖注入（DI）、控制反转（IOC）和自动装配</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/spring/ioc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/spring/ioc/</guid>
      <description>&lt;h1 id=&#34;依赖注入di控制反转ioc和自动装配&#34;&gt;&#xD;&#xA;  依赖注入（DI）、控制反转（IOC）和自动装配&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5di%e6%8e%a7%e5%88%b6%e5%8f%8d%e8%bd%acioc%e5%92%8c%e8%87%aa%e5%8a%a8%e8%a3%85%e9%85%8d&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;控制反转基本概念：&#xA;将对象的创建和管理的控制权，从某个实体类，转交给Spring。&lt;/p&gt;&#xA;&lt;p&gt;依赖注入基本概念：&#xA;对象间的依赖关系将被自动注入到需要他们的对象中去。&lt;/p&gt;&#xA;&lt;p&gt;在传统模式中，类需要哪些资源就要自己去new出来，&#xA;现在则统一由Spring提供，从主动变成了被动。称为控制反转。&lt;/p&gt;&#xA;&lt;p&gt;Spring框架控制的资源全部放置在Spring底层的IOC容器中。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;控制反转可以理解为一种交给外部管理类依赖资源的设计模式&lt;/li&gt;&#xA;&lt;li&gt;依赖注入是控制反转的一种实现形式&#xA;&lt;ol&gt;&#xA;&lt;li&gt;指的是组件自身提供普通的Java方法声明依赖关系。容器全权负责组件依赖关系的装配，将根据这些声明主动将符合依赖关系的对象传递给需要的对象。&lt;/li&gt;&#xA;&lt;li&gt;为了实现控制反转的概念，Spring实现了依赖注入的机制&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;依赖注入机制的使用方式：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;属性注入形式&#xA;xml方式：使类有Set方法，并设置bean和property。Spring读取xml文件时，认为需要向bean a注入bean b。这实质上是通过，使类有set方法，从而可实现用xml文件声明属性依赖关系，从而声明依赖关系，寻求注入的方式。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;img src=&#34;./images/DI-param.png&#34; alt=&#34;属性注入&#34; title=&#34;属性注入&#34;/&gt;&lt;/p&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;构造器注入形式&#xA;xml方式：使类具备有参构造函数，并设置bean和property。实质上与上述是相似的，只是多支持了一种声明的方式。&#xA;&lt;img src=&#34;./images/DI-struct.png&#34; alt=&#34;构造器注入&#34; title=&#34;构造器注入&#34;/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Java显式配置&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过注解，描述某个类应该作为Bean被容器管理，且内部包含一些如何在上下文中创建Bean的细节。如@Configuration。&lt;/li&gt;&#xA;&lt;li&gt;通过注解，描述某个方法的返回结果应该作为Bean被容器管理，如@Bean。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;上述的依赖注入的使用方式，实际上都是在告诉Spring如何装配对象间的依赖关系。&#xA;Spring对于描述Bean如何进行装配时，提供了三种主要的装配机制：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;XML中显式配置描述&lt;/li&gt;&#xA;&lt;li&gt;Java中显式配置描述（就是通过@Configuration+@Bean描述Bean的创建）&lt;/li&gt;&#xA;&lt;li&gt;隐式的Bean发现机制和自动装配（就是通过@Component+@Autowired等描述自动扫描和注入）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;自动装配的Spring实现：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;组件扫描：通过注解配置，Spring会自动发现应用上下文中创建的Bean&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;通过@ComponentScan配置组件扫描的包&lt;/li&gt;&#xA;&lt;li&gt;通过@Component声明一个类为组件&lt;/li&gt;&#xA;&lt;li&gt;Spring将扫描包并找到组件，为这些组件创建Bean并放入容器中&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;自动装配：Spring自动满足Bean之间的依赖关系&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;在构造器上加上@Autowired，则Spring构造对象时，将传入对应的Bean。（注解式的构造器注入）&lt;/li&gt;&#xA;&lt;li&gt;在Setter或其他方法上加上@Autowired，则Spring初始化Bean后，会尽量满足Bean的依赖，就会注入指定的Bean。（注解式的属性注入）&lt;/li&gt;&#xA;&lt;li&gt;将@Autowired直接加在属性上&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;控制反转的优点：&#xA;（理解中，依赖注入和自动装配机制，都是为了让控制反转模式能够合理运行的实现）&#xA;如A需要B实现功能&#xA;按传统模式，则需要在A中new B()，这时当B需要改动时，则A与B有关的功能代码可能都需要改动。&#xA;有了控制反转，将依赖关系交给容器装配，则我们只需改动B，就可以让容器初始化一个不同的B注入到A中，尽量少地避免了上层的改动。&#xA;这其实是依赖倒置原则的实现。实现依赖倒置原则，使得高层建筑可以不关心底层建筑的实现，避免牵一发动全身。&#xA;为了实现依赖倒置原则，思路是做控制反转，方法是实现依赖注入，为了实现依赖注入，做了个IOC容器去管理Bean的生成和装配等。&#xA;降低了组件间的耦合度。&lt;/p&gt;&#xA;&lt;p&gt;在Spring项目中的影响逻辑：&#xA;由于依赖倒置原则具有修改底层建筑，尽量少地影响上层建筑地好处。&#xA;Spring为了实现依赖倒置原则，构想了控制反转的模式，即将对象的创建、装配、生命周期管理等，交给IOC容器来进行，相比让对象自己去new，使得组件间耦合度降低&#xA;IOC容器管理Bean，首先是在启动时，通过读取XML、Java注解等方式，理解声明的Bean和装配方式，生成Bean并注册到容器中。进行后续管理。&#xA;组件的耦合度降低页实现了Controller、Service、DAO软件各层之间的解耦&#xA;IOC容器创建Bean提供了单例模式的支持，使得开发人员不需要自己实现&#xA;切面机制受IOC的影响暂定&#xA;组件间的解耦使得Spring使用第三方组件时可以实现无痛的切换底层实现，优势仅需修改一些配置，即可使得实例化地Bean是另一套实现，则被注入地是另一套实现，只需做好底层接口即可。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
