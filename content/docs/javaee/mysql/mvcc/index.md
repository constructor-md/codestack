---
title: MVCC 多版本并发控制
draft: false
weight: 8
---


# MVCC 多版本并发控制


## 版本链
数据库中，以最新记录和undolog中的历史记录形成了版本链

版本链中每个版本，除了具体行数据之外，还有该版本的事务ID、和回滚指针，每一行记录都有这两个隐藏列

每个版本的回滚指针指向上一个版本

## ReadView 快照数据
作用：让数据库知道在具体查询的时候，应该去查询哪个版本的数据

数据结构：代码里的一个对象
- M_ids: 生成ReadView时当前系统中活跃的读写事务的事务id列表（未提交）
- Min_trax_id: 生成ReadView时当前系统中活跃的读写事务的最小事务id m_ids的最小值（最老的一个未提交）
- Max_trx_id: 生成ReadView时系统应该分配给下一个事务的id值（未生成即将生成）
- Creator_trx_id: 生成该ReadView的事务的id（创建者）

ReadView如何判断版本链中哪个版本可用？
- Trx_id == creator_trx_id 可以访问这个版本（创建者可以访问）
- Trx_id < min_trx_id 可以访问这个版本（可以访问已提交的数据）
- Trx_id > max_trx_id 不可以访问这个版本（当前事务不能访问超过当前版本链的数据）
- Min_trx_id <= trx_id <= max_trx_id 如果trx_id在m_ids中，就可以不访问这个版本，因为里面的数据都没有commit

## ReadView如何实现读已提交和可重复读？
版本链是全局的，没有事务时版本链的头部是最新数据，后面是每个版本的历史数据

如果有多个事务同时更新某一行数据，每个事务的更新，都会在版本链上生成一个版本

1. 执行一个select前
先生成一个当前事务的ReadView，ReadView包含上述数据
2. 让ReadView在版本链从头到尾比较：(版本数据对查询的可见性)
- 如果该版本是当前事务提交的，那自然可以访问该数据，且该版本未提交也可以访问
- 如果该版本不是当前事务提交，但是是已提交的数据，当然可以访问
- 如果该版本数据是当前事务之后生成的事务生成的版本，那么肯定没有提交，不能访问
- 如果该版本数据是当前事务生成ReadView时的未提交事务之一，那么不能访问这些未提交的数据
## 事务隔离级别与MVCC
- 如果是读已提交：
    则每次select都会生成ReadView，使得除了creator_trx_id以外的数据有所变化

    于是每次select都可以访问到最新的提交数据，或者是自己的修改数据

    访问到的最新提交数据可能变化
    
- 如果是可重复读：
    仅在第一次select生成ReadView

    从而每次要么访问到自己的最新修改，要么一直是生成当时的最新提交数据，不会变化

- 如果是读未提交：
    则每次直接访问最新的版本链数据，不关心是否提交，不需要MVCC
    
- 如果是串行化：
    则通过加锁互斥访问，不需要MVCC
    

> 幻读问题的解决：
>
>    可明确的是：仅在快照读的情况下可以解决幻读，当前读不能解决幻读
>
>   幻读指的是两次查询前后，因为中间有事务提交，导致查询得到的数据量不符合









