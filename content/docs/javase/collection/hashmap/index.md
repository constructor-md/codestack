---
title: HashMap
draft: false
weight: 1
---

# HashMap
## 数据结构
- JDK1.7之前，采用数组+链表
- JDK1.8之后，数组+链表+红黑树
当链表长度大于阈值或者红黑树的边界值，默认为8，且数组长度大于64时，该索引位置的数据改为红黑树存储  
如果数组长度不够64，则执行扩容。数组长度较小时换为红黑树，反而会降低效率。因为红黑树需要左旋右旋变色等操作来保持平衡  

## 哈希表底层的hash算法
采用key的hashcode值，结合数组长度进行无符号右移，按位异或，按位与计算出索引  
还可以采用平方取中，取余数，伪随机数法。但位运算效率较高  
    
## 哈希表的存储和查询
存储时，根据hash算法计算出索引位置，找到指定位置存储  
以String为例，如果位置上已经有元素，则equals判断元素是否相等，相等则替换    
不相等则在该位置形成链表，数据变为链表上的一个节点。以解决哈希碰撞问题  
    
## 哈希扩容
当元素个数超过数组大小*负载因子（默认0.75）时进行扩容，扩大一倍  
扩容时需要rehash，但是方式比较巧妙，由于每次扩容都是翻倍，所以rehash相当于将原来的位置+旧容量就得到新的位置，没有再计算hash值  
但是新的键值进入仍进行了hash  
    
    
## 常见hash算法的原理：
1. 平方取中法：取关键字平方后中间几位作为散列地址
2. 直接寻址法：取关键字或关键字的某个线性函数值作为散列地址
3. 数字分析法：分析数据，如果是日期，发现年月日前几位数字大致相同，出现冲突几率大。你那月日的后几位月份和具体日期差别大，考虑用后面则冲突几率降低。即找规律用低碰撞的数据构造冲突几率低的散列地址
4. 折叠法：关键字分割成位数相同的几部分，最后一部分位数可以不同。取这几部分的叠加和（去除进位）作为散列地址
5. 随机数法：选择一个随机函数，取关键字的随机值作为散列地址，用于关键字长度不同的场合
6. 除留余数法：取关键字某个不大于散列表表长m的数p除后得到余数作为散列地址。p一般取素数或m，如果p选的不好容易产生随机值

# 处理冲突的方法
1. 开放寻址法
2. 拉链法
3. 再散列法
4. 公共溢出区














