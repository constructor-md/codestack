[{"id":0,"href":"/codestack/docs/basic/","title":"计算机基础","section":"Docs","content":"\r计算机基础\r#\r"},{"id":1,"href":"/codestack/docs/javaee/","title":"JavaEE","section":"Docs","content":"\rJavaEE\r#\r"},{"id":2,"href":"/codestack/docs/javaee/spring/","title":"Spring","section":"JavaEE","content":"\rSpring\r#\r"},{"id":3,"href":"/codestack/docs/basic/net/transport/tcp/","title":"TCP","section":"传输层","content":"\rTCP\r#\rTCP是一种面向连接的、可靠的、基于字节流的传输层通信协议\n报文结构\r#\r源端口：发送方使用的端口号，16位 目的端口：接收方使用的端口号，16位 序号：本报文段发送数据的第一个字节的编号，32位 确认号：接收方期望接收到的下一个报文段的第一个字节的编号 数据偏移(首部长度)：指数据段中的数据部分的起始处距离TCP报文段起始处的偏移量，也就是TCP报文的报头部分的长度，接收端根据这个知道数据（有效载荷）从何处开始 4位 保留字段：TCP协议将来的发展预留的空间，目前必须全部为0，6位 标志位字段：共六个标志位，每个1bit 窗口大小：表示发送该TCP报文的接收窗口还可以接受多少字节的数据量，用于TCP的流量控制，16位 校验和：用于确认传输的数据有无损坏。发送端基于数据内容校验生成一个数值，接收端同样生成一个数值进行对比，相同的数据有效，反之无效则丢弃数据包，16位 紧急指针：仅当标志位的URG字段值位1才有意义。指出有效载荷中位紧急数据的字节数。当所有紧急数据处理完，TCP告知应用程序恢复到正常操作。即使接收方窗口大小为0，也可以发送紧急数据，因为紧急数据无需缓存，16位 选项字段：长度不定，但是必须是32bit的整数倍，即4字节的整数倍。内容可变，所以使用首部长度来区分选项部分的具体长度 各种传输流程的过程\r#\r分离首部和载荷（确认首部长度）\r#\rTCP固定首部长度20字节，以及选项字段 首部长度字段为4bits，最大可表示长度为1111，即15。表示单位是4字节 所以TCP首部最长是15*4 = 60字节 固定首部为20字节，选项部分为4字节的倍数，最大为40字节 这说明了数据偏移字段标识首部长度的原理 根据首部长度，可以分离首部和载荷\n连接的建立和断开\r#\rTCP连接是TCP协议在网络中建立的可靠通信链路\n这种可靠指的是不丢包，就是网络不太好的情况下可以尽量保证数据的完整接收（发送确认和重发） 由IP协议锚定双方地址，由底层协议传输数据包，由高层协议进行数据的加解密 换言之，TCP的可靠通信链路中保证的是传输和接收数据包的完整性，而不是包揽了链路的实际构建、数据包防伪等过程。不要把可靠性的理解在TCP扩展太多\n为什么要建立连接\r#\r可靠性验证：建立连接的过程实际就是通信双方验证各自的发送和接受能力是否正常，双方的信道是否通畅 协商参数：如序号初始值，MSS，是否启用SACK等 连接的建立 - 三次握手\r#\r服务器初始化状态 服务器端进程函数顺序：socket =\u0026gt; bind =\u0026gt; listen =\u0026gt; accept socket()创建套接字listenfd bind()将套接字和端口绑定 listen()让listenfd成为监听套接字，后续连接通过监听套接字获取，服务器处于监听状态 accept()进程阻塞，直到有客户连接请求到达才返回 客户端发起连接请求 - 第一次握手 客户端进程函数顺序:socket =\u0026gt; connect socket()创建套接字 connect()调用时操作系统自动bind()，然后客户端进程就会向服务端进行发送连接请求报文 连接请求报文首部的标志位SYN=1 同时选定一个初始序号SEQ=x，x是随机产生的整数 TCP规定SYN=1的报文段不可以携带数据，但消耗一个序号 此时客户端进程进入SYN-SENT(同步报文已发送状态)\n服务器同意建立连接，回复确认 - 第二次握手 服务器端进程收到连接请求报文，同意建立连接 从listenfd监听套接字获取客户端信息 服务器端操作系统向客户端发送SYN报文段进行确认 连接确认报文首部标志位SYN=1，ACK=1，确认号ack=x+1 同时为自己选择一个初始序号seq=y 同样不能携带数据，消耗一个序号 TCP服务器进入SYN-RCVD(同步报文已收到)状态\n客户端确认连接已经被确认，发送确认连接信息 - 第三次握手 客户端进程收到服务器的确认报文，向服务器发送确认报文表示自己收到 确认报文首部ACK=1，确认号ack=y+1，序号seq=x+1 可以携带数据，不携带数据则不消耗序号 客户端认为连接建立成功，进入ESTABLISHED(已建立连接)状态，准备发送数据 服务器收到确认报文，进入ESTABLISHED(已建立连接)状态，准备接受数据\n形象理解和问题\r#\r三次握手的形象理解\r#\r客户端用seq=x标识自己，发送SYN=1的连接请求报文，告诉服务器我想建立连接 服务器用seq=y标识自己，发送ACK=1 SYN=1 确认号ack=x+1的确认报文，告诉客户端我是y，同意了序号x的连接请求 客户端发送确认连接报文ACK=1，确认号ack=y+1，告诉服务器这是序号x的连接确认报文(+1)，而且我收到了seq=y的连接同意信息，我认为我们之间的连接已经建立 服务器收到确认报文，认为连接已经建立 初始序列号SEQ为什么要随机\r#\rseq序号表示的是发送的TCP报文数据部分的起始字节位置，服务器/客户端可以通过序号正确读取数据。如果不是随机分配起始序列号，那么黑客就会很容易获取客户端与服务器之间TCP通信的初始序列号，然后通过伪造序列号让通信主机读取到携带病毒的TCP报文，发起网络攻击\n服务器没有收到客户端的确认报文怎么办\r#\r操作系统会给每个处于SYN-RCVD状态的服务器进程设定一个计时器，如果超过一定时间还没有收到客户端第三次握手的ACK确认报文，将会重新发送第二次握手的确认报文，直到重发达到一定次数才会放弃\n为什么不能两次握手\r#\r两次握手意味着，服务器来确认连接的建立\n如果确认报文丢失，客户端不知道服务器确认连接已经建立，就不会发送数据，服务器会维护不成功的TCP连接 容易遭受SYN洪水攻击，攻击者发送大量的SYN请求连接报文，服务器对每个报文都建立连接，消耗大量资源 可能有已失效的连接报文传输到服务器，服务器维护失效连接 失效连接的产生原因和两次握手的后果 客户端A发送给服务器B连接报文，但报文在某个网路节点滞留，迟迟不到达服务器 客户端A等待服务器B确认报文太久，以至于客户端认为刚才的连接报文失效，不再等待确认报文 服务器B突然收到连接报文，并确认连接发回确认报文 客户端没有在等待确认报文，就不会处理确认报文，也不会向服务器发送数据，于是服务器维护的是一个无效连接\n只要握手次数是偶数次，就会把连接的确认带来的成本转移给服务器\n为什么必须是三次握手\r#\r奇数次握手，客户端先建立连接 防止已失效的连接报文突然传到服务器，导致错误 三次握手时已失效的连接报文突然传到服务器，服务器发回确认报文 客户端无回复，服务器也不会认为连接确认，不会做接受数据准备等，连接仍然未被建立\n三次是验证双方信道通畅，发送接收能力正常的最小成本 怎么处理SYN洪水攻击\r#\rSYN Flood是互联网上最原始、最经典的DDoS（Distributed Denial of Service）攻击之一\n数据传输一般过程\r#\r#\r三次握手和四次挥手\r#\rTCP协议建立连接时，进行三次握手：\n客户端向服务端发送SYN，同步序列号SEQ 服务端接收到SYN后，返回SYN，内容为自己的同步序列号；ACK，内容为对方的同步序列号+1 客户端收到SYN、ACK后，再给服务端发送一个ACK为服务端同步序列号+1，自己的同步序列号+1 断开TCP连接时，进行四次挥手：\n客户端向服务端发送FIN \u0026ndash; 我要断开了 服务端收到FIN，向客户端发送ACK \u0026ndash; 知道了，你可以不发送数据，但我这还有数据要处理 服务端处理完数据，向客户端发送FIN，表示服务端可以断开连接 客户端收到服务端FIN，给服务端发送ACK，表示客户端也将断开连接 为什么是三次握手？\n防止重复链接。防止旧的重复连接引起连接混乱。 网络复杂或状况差的情况下，发送方可能发起多个连接建立的请求。如果只有两次握手，接收方只能选择接受或拒绝，但无法确定该次请求是否正常。 如果是三次握手，客户端接受服务端返回的内容，可以判断当前连接是否是历史连接，是历史连接则发送终止报文。不是则返回内容建立连接 客户端可以检验服务端收到的连接请求是否是当前的 同步初始化序列号 TCP的重要特征是可靠性，它使用一个序列号来保证自己在不稳定的网络环境来构建稳定的数据连接，序列号的u哦用时方知数据包重复发送，解决数据包接收的顺序颠倒问题。 建立TCP连接时需要发送同步初始化一个序列号来保证稳定性。第一步发送一个初始序列号，第二部检验初始序列号是否被服务端成功接收，第三步再发送一个ACK报告成功，则两边拥有一个可靠的初始序列号。 为什么是四次挥手？\nTCP是全双工通信的。第一次挥手仅代表客户端不会再发送数据报文，不代表客户端不会接收 第二次挥手，服务端可能还有数据报文要发送。只能回复一个知道你想断开的消息，但是不会立马认为连接断开。 第三次挥手，服务端处理完要发送的报文，发送给客户端结束报文。这样保证了数据通信正常完成。 第四次挥手，如果主动方发送了ACK确认连接中断，被动方可以释放连接。意味着刚才数据已经被收到，最后一次工作结束。 "},{"id":4,"href":"/codestack/docs/basic/net/transport/","title":"传输层","section":"计算机网络","content":"\r传输层 Transport Layer\r#\r"},{"id":5,"href":"/codestack/docs/javaee/spring/ioc/","title":"依赖注入（DI）、控制反转（IOC）和自动装配","section":"Spring","content":"\r依赖注入（DI）、控制反转（IOC）和自动装配\r#\r控制反转基本概念： 将对象的创建和管理的控制权，从某个实体类，转交给Spring。\n依赖注入基本概念： 对象间的依赖关系将被自动注入到需要他们的对象中去。\n在传统模式中，类需要哪些资源就要自己去new出来， 现在则统一由Spring提供，从主动变成了被动。称为控制反转。\nSpring框架控制的资源全部放置在Spring底层的IOC容器中。\n控制反转可以理解为一种交给外部管理类依赖资源的设计模式 依赖注入是控制反转的一种实现形式 指的是组件自身提供普通的Java方法声明依赖关系。容器全权负责组件依赖关系的装配，将根据这些声明主动将符合依赖关系的对象传递给需要的对象。 为了实现控制反转的概念，Spring实现了依赖注入的机制 依赖注入机制的使用方式：\n属性注入形式 xml方式：使类有Set方法，并设置bean和property。Spring读取xml文件时，认为需要向bean a注入bean b。这实质上是通过，使类有set方法，从而可实现用xml文件声明属性依赖关系，从而声明依赖关系，寻求注入的方式。 构造器注入形式 xml方式：使类具备有参构造函数，并设置bean和property。实质上与上述是相似的，只是多支持了一种声明的方式。 Java显式配置\n通过注解，描述某个类应该作为Bean被容器管理，且内部包含一些如何在上下文中创建Bean的细节。如@Configuration。 通过注解，描述某个方法的返回结果应该作为Bean被容器管理，如@Bean。 上述的依赖注入的使用方式，实际上都是在告诉Spring如何装配对象间的依赖关系。 Spring对于描述Bean如何进行装配时，提供了三种主要的装配机制：\nXML中显式配置描述 Java中显式配置描述（就是通过@Configuration+@Bean描述Bean的创建） 隐式的Bean发现机制和自动装配（就是通过@Component+@Autowired等描述自动扫描和注入） 自动装配的Spring实现：\n组件扫描：通过注解配置，Spring会自动发现应用上下文中创建的Bean\n通过@ComponentScan配置组件扫描的包 通过@Component声明一个类为组件 Spring将扫描包并找到组件，为这些组件创建Bean并放入容器中 自动装配：Spring自动满足Bean之间的依赖关系\n在构造器上加上@Autowired，则Spring构造对象时，将传入对应的Bean。（注解式的构造器注入） 在Setter或其他方法上加上@Autowired，则Spring初始化Bean后，会尽量满足Bean的依赖，就会注入指定的Bean。（注解式的属性注入） 将@Autowired直接加在属性上 控制反转的优点： （理解中，依赖注入和自动装配机制，都是为了让控制反转模式能够合理运行的实现） 如A需要B实现功能 按传统模式，则需要在A中new B()，这时当B需要改动时，则A与B有关的功能代码可能都需要改动。 有了控制反转，将依赖关系交给容器装配，则我们只需改动B，就可以让容器初始化一个不同的B注入到A中，尽量少地避免了上层的改动。 这其实是依赖倒置原则的实现。实现依赖倒置原则，使得高层建筑可以不关心底层建筑的实现，避免牵一发动全身。 为了实现依赖倒置原则，思路是做控制反转，方法是实现依赖注入，为了实现依赖注入，做了个IOC容器去管理Bean的生成和装配等。 降低了组件间的耦合度。\n在Spring项目中的影响逻辑： 由于依赖倒置原则具有修改底层建筑，尽量少地影响上层建筑地好处。 Spring为了实现依赖倒置原则，构想了控制反转的模式，即将对象的创建、装配、生命周期管理等，交给IOC容器来进行，相比让对象自己去new，使得组件间耦合度降低 IOC容器管理Bean，首先是在启动时，通过读取XML、Java注解等方式，理解声明的Bean和装配方式，生成Bean并注册到容器中。进行后续管理。 组件的耦合度降低页实现了Controller、Service、DAO软件各层之间的解耦 IOC容器创建Bean提供了单例模式的支持，使得开发人员不需要自己实现 切面机制受IOC的影响暂定 组件间的解耦使得Spring使用第三方组件时可以实现无痛的切换底层实现，优势仅需修改一些配置，即可使得实例化地Bean是另一套实现，则被注入地是另一套实现，只需做好底层接口即可。\n"},{"id":6,"href":"/codestack/docs/basic/net/","title":"计算机网络","section":"计算机基础","content":"\r计算机网络\r#\r"}]