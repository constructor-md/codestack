<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>多线程 on CodeStack</title>
    <link>https://constructor-md.github.io/codestack/docs/javase/multi-thread/</link>
    <description>Recent content in 多线程 on CodeStack</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <atom:link href="https://constructor-md.github.io/codestack/docs/javase/multi-thread/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>线程的创建和使用</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/multi-thread/thread-create/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/multi-thread/thread-create/</guid>
      <description>&lt;h1 id=&#34;线程的创建和使用&#34;&gt;&#xD;&#xA;  线程的创建和使用&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e7%9a%84%e5%88%9b%e5%bb%ba%e5%92%8c%e4%bd%bf%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;可以直接new Thread()创建一个线程&lt;br&gt;&#xA;要想让线程执行某个任务，创建线程时可以传入具体的一个Runnable对象，内含实现方法&lt;br&gt;&#xA;最后调用线程的start方法开始执行&lt;/p&gt;&#xA;&lt;p&gt;设置任务的方式：&lt;/p&gt;&#xA;&lt;h2 id=&#34;实现runnable接口&#34;&gt;&#xD;&#xA;  实现Runnable接口&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%9e%e7%8e%b0runnable%e6%8e%a5%e5%8f%a3&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;内部实现run方法，创建线程时作为实例化参数传递进去，则start线程后会执行run方法&lt;br&gt;&#xA;无法获取返回值，run方法是void的，且不支持传递参数进去&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public class RunnableExample {&#xD;&#xA;    public static void main(String[] args) {&#xD;&#xA;        // 创建Runnable接口的实现类&#xD;&#xA;        Runnable task = new Runnable() {&#xD;&#xA;            @Override&#xD;&#xA;            public void run() {&#xD;&#xA;                System.out.println(&amp;#34;通过实现Runnable接口创建的线程正在执行任务&amp;#34;);&#xD;&#xA;                try {&#xD;&#xA;                    Thread.sleep(1000);&#xD;&#xA;                } catch (InterruptedException e) {&#xD;&#xA;                    e.printStackTrace();&#xD;&#xA;                }&#xD;&#xA;                System.out.println(&amp;#34;任务执行完毕&amp;#34;);&#xD;&#xA;            }&#xD;&#xA;        };&#xD;&#xA;&#xD;&#xA;        // 创建线程并传入Runnable实例&#xD;&#xA;        Thread thread = new Thread(task);&#xD;&#xA;        // 启动线程&#xD;&#xA;        thread.start();&#xD;&#xA;    }&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;实现callable接口&#34;&gt;&#xD;&#xA;  实现Callable接口&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%9e%e7%8e%b0callable%e6%8e%a5%e5%8f%a3&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;这是一个泛型接口，实现其中的call方法，方法的返回值即接口指定的泛型&lt;br&gt;&#xA;实现类放进一个FutureTask对象中，将FutureTask对象传入Thread构造方法&lt;br&gt;&#xA;执行完毕后，通过FutureTask对象的get方法可以获取返回值&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import java.util.concurrent.*;&#xD;&#xA;&#xD;&#xA;public class CallableExample {&#xD;&#xA;    public static void main(String[] args) {&#xD;&#xA;        // 创建Callable接口的实现类&#xD;&#xA;        Callable&amp;lt;String&amp;gt; callableTask = new Callable&amp;lt;String&amp;gt;() {&#xD;&#xA;            @Override&#xD;&#xA;            public String call() throws Exception {&#xD;&#xA;                System.out.println(&amp;#34;通过实现Callable接口创建的线程正在执行任务&amp;#34;);&#xD;&#xA;                Thread.sleep(2000);&#xD;&#xA;                return &amp;#34;任务执行结果：成功&amp;#34;;&#xD;&#xA;            }&#xD;&#xA;        };&#xD;&#xA;&#xD;&#xA;        // 将Callable包装成FutureTask&#xD;&#xA;        FutureTask&amp;lt;String&amp;gt; futureTask = new FutureTask&amp;lt;&amp;gt;(callableTask);&#xD;&#xA;        // 创建线程并传入FutureTask&#xD;&#xA;        Thread thread = new Thread(futureTask);&#xD;&#xA;        // 启动线程&#xD;&#xA;        thread.start();&#xD;&#xA;&#xD;&#xA;        try {&#xD;&#xA;            // 获取任务执行结果（会阻塞直到任务完成）&#xD;&#xA;            String result = futureTask.get();&#xD;&#xA;            System.out.println(&amp;#34;获取到的返回值：&amp;#34; + result);&#xD;&#xA;        } catch (InterruptedException | ExecutionException e) {&#xD;&#xA;            e.printStackTrace();&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;继承thread类&#34;&gt;&#xD;&#xA;  继承Thread类&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%a7%e6%89%bfthread%e7%b1%bb&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;因为Thread类实现了Runnable接口，我们可以继承Thread类实现run方法，实例化我们实现的子类，然后执行start，即可运行其中的方法&lt;br&gt;&#xA;但是继承整个Thread类开销过大，一般不使用。&lt;br&gt;&#xA;且Java不支持多重继承，继承了Thread接口无法继承其他类，但是接口则可以实现多个，所以使用接口实现传递方法比较好。&lt;/p&gt;</description>
    </item>
    <item>
      <title>线程池的创建和运行逻辑</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/multi-thread/thread-pool/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/multi-thread/thread-pool/</guid>
      <description>&lt;h1 id=&#34;线程池的创建和运行逻辑&#34;&gt;&#xD;&#xA;  线程池的创建和运行逻辑&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%9a%84%e5%88%9b%e5%bb%ba%e5%92%8c%e8%bf%90%e8%a1%8c%e9%80%bb%e8%be%91&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;threadpoolexecutor&#34;&gt;&#xD;&#xA;  ThreadPoolExecutor&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#threadpoolexecutor&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ThreadPoolExecutor executor = new ThreadPoolExecutor(&#xD;&#xA;            2,                   // 核心线程数&#xD;&#xA;            5,                   // 最大线程数&#xD;&#xA;            60,                  // 空闲线程存活时间&#xD;&#xA;            TimeUnit.SECONDS,&#xD;&#xA;            new LinkedBlockingQueue&amp;lt;&amp;gt;(10), // 任务队列&#xD;&#xA;            Executors.defaultThreadFactory(), // 线程工厂&#xD;&#xA;            new ThreadPoolExecutor.CallerRunsPolicy() // 拒绝策略&#xD;&#xA;        );&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;主要参数&#34;&gt;&#xD;&#xA;  主要参数&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%bb%e8%a6%81%e5%8f%82%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;线程池内部使用队列+线程实现&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;coolPoolSize:常驻核心线程数&lt;/li&gt;&#xA;&lt;li&gt;maxPoolSize:能够容纳同时执行的最大线程数&lt;/li&gt;&#xA;&lt;li&gt;keepAliveTime:多余的空闲线程的存活时间&lt;br&gt;&#xA;当线程池数量超过corePoolSize，空闲时间达到keepAliveTime，线程会被销毁到只剩下corePoolSize为止&lt;/li&gt;&#xA;&lt;li&gt;handler：拒绝策略，当线程池超过max时，如何拒绝请求执行的runnable&lt;/li&gt;&#xA;&lt;li&gt;workQueue:任务队列，提交但尚未被执行的任务&lt;/li&gt;&#xA;&lt;li&gt;线程工厂：线程工厂生产线程时可以指定线程的命名规则，可以设置线程分组，设置线程优先级等&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;使用线程池执行任务时：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;如果线程池的数量小于core，即使线程都空闲，也创建新线程处理任务&lt;/li&gt;&#xA;&lt;li&gt;线程池数量等于core，缓冲队列workQueue未满，任务放入任务队列等待&lt;/li&gt;&#xA;&lt;li&gt;大于core，队列满，数量小于max，创建新线程处理任务&lt;/li&gt;&#xA;&lt;li&gt;大于core，队列满，数量等于max，使用拒绝策略拒绝&lt;/li&gt;&#xA;&lt;li&gt;大于 core，空闲时间超过keep，线程被销毁到等于core&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;根据机器和应用设置线程数&#34;&gt;&#xD;&#xA;  根据机器和应用设置线程数&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%a0%b9%e6%8d%ae%e6%9c%ba%e5%99%a8%e5%92%8c%e5%ba%94%e7%94%a8%e8%ae%be%e7%bd%ae%e7%ba%bf%e7%a8%8b%e6%95%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 获取CPU核数&#xD;&#xA;int cpuCores = Runtime.getRuntime().availableProcessors();&#xD;&#xA;# 计算密集型（主要消耗CPU）：线程数 = CPU核数 + 1&#xD;&#xA;int corePoolSize = cpuCores + 1;&#xD;&#xA;int maxPoolSize = cpuCores + 1;&#xD;&#xA;# IO密集型（多IO等待）：线程数 = 2 * CPU核数&#xD;&#xA;int corePoolSize = 2 * cpuCores;&#xD;&#xA;int maxPoolSize = 2 * cpuCores;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;拒绝策略&#34;&gt;&#xD;&#xA;  拒绝策略&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8b%92%e7%bb%9d%e7%ad%96%e7%95%a5&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;AbortPolicy&lt;br&gt;&#xA;拒绝任务直接抛出异常RejectedExecution(RuntimeException)，让调用者感知，根据业务选择重试或放弃&lt;/li&gt;&#xA;&lt;li&gt;DiscardPolicy&lt;br&gt;&#xA;新任务提交后拒绝，不给通知。调用者不知道任务会被丢弃可能造成数据丢失&lt;/li&gt;&#xA;&lt;li&gt;DiscardOldestPolicy&lt;br&gt;&#xA;丢弃任务队列的头节点（通常是存活时间最久的任务），腾出扣减给新提交的任务，也有数据丢失风险&lt;/li&gt;&#xA;&lt;li&gt;CallerRunsPolicy&lt;br&gt;&#xA;把任务交给提交任务的线程执行。被提交的任务不会被丢弃，不会有业务损失；且提交任务的线程被占用，不会快速提交其他任务，减缓了任务提交的速度。线程池有空余时间处理其他任务，腾出空间&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;任务队列&#34;&gt;&#xD;&#xA;  任务队列&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%bb%e5%8a%a1%e9%98%9f%e5%88%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;SynchronousQueue&lt;br&gt;&#xA;直接提交形式的任务队列&lt;br&gt;&#xA;队列中不会有缓存的任务，每个任务已提交就会交给线程执行，如果线程数量达到最大值自然拒绝&lt;/li&gt;&#xA;&lt;li&gt;ArrayBlockingQueue&lt;br&gt;&#xA;有界任务队列，可以指定队列大小&#xA;符合一般的线程池执行逻辑，任务到来先创建线程，达到corePoolSize则写入队列，队列满则继续创建线程消费任务，达到max则执行拒绝策略&lt;/li&gt;&#xA;&lt;li&gt;LinkedBlockingQueue&lt;br&gt;&#xA;无界任务队列，不能指定队列大小，除非系统资源耗尽，否则不存在入队失败的情况。&lt;br&gt;&#xA;线程数达到corePoolSize不再增加，而是直接写入队列&lt;/li&gt;&#xA;&lt;li&gt;PriorityBlockingQueue&lt;br&gt;&#xA;优先任务队列，无界队列&lt;br&gt;&#xA;前面几种队列都是先进先出，这种是后进先出，主张先完成最新提交的任务&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;executors&#34;&gt;&#xD;&#xA;  Executors&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#executors&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;executorsnewfixedthreadpool&#34;&gt;&#xD;&#xA;  Executors.newFixedThreadPool&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#executorsnewfixedthreadpool&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ExecutorService executor = Executors.newFixedThreadPool(3);&#xD;&#xA;executor.submit(() -&amp;gt; {...});&#xD;&#xA;&#xD;&#xA;# Java实现&#xD;&#xA;public static ExecutorService newFixedThreadPool(int nThreads) {&#xD;&#xA;    return new ThreadPoolExecutor(nThreads, nThreads,&#xD;&#xA;                                  0L, TimeUnit.MILLISECONDS,&#xD;&#xA;                                  new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;创建固定数量的线程池：核心线程数和最大线程数固定相等&lt;/li&gt;&#xA;&lt;li&gt;控制可并发的线程数，空闲线程会在队列中等待&lt;/li&gt;&#xA;&lt;li&gt;空闲线程不会被回收。&lt;/li&gt;&#xA;&lt;li&gt;任务队列无界（LinkedBlockingQueue），可能导致 OOM&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;executorsnewcachedthreadpool&#34;&gt;&#xD;&#xA;  Executors.newCachedThreadPool&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#executorsnewcachedthreadpool&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ExecutorService executor = Executors.newCachedThreadPool();&#xD;&#xA;&#xD;&#xA;# Java实现&#xD;&#xA;public static ExecutorService newCachedThreadPool() {&#xD;&#xA;    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,&#xD;&#xA;                                  60L, TimeUnit.SECONDS,&#xD;&#xA;                                  new SynchronousQueue&amp;lt;Runnable&amp;gt;());&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;核心线程数为 0，最大线程数为Integer.MAX_VALUE。&lt;/li&gt;&#xA;&lt;li&gt;空闲线程存活 60 秒，自动回收。&lt;/li&gt;&#xA;&lt;li&gt;适合短时间内大量任务的场景，可能导致资源耗尽&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;executorsnewsinglethreadexecutor&#34;&gt;&#xD;&#xA;  Executors.newSingleThreadExecutor&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#executorsnewsinglethreadexecutor&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ExecutorService executor = Executors.newSingleThreadExecutor();&#xD;&#xA;&#xD;&#xA;# Java实现&#xD;&#xA;public static ExecutorService newSingleThreadExecutor() {&#xD;&#xA;    return new FinalizableDelegatedExecutorService&#xD;&#xA;        (new ThreadPoolExecutor(1, 1,&#xD;&#xA;                                0L, TimeUnit.MILLISECONDS,&#xD;&#xA;                                new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;()));&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;创建单线程线程池&lt;/li&gt;&#xA;&lt;li&gt;始终只有一个工作线程。&lt;/li&gt;&#xA;&lt;li&gt;任务按提交顺序串行执行。&lt;/li&gt;&#xA;&lt;li&gt;保证所有任务按顺序执行，避免多线程并发问题&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;executorsnewscheduledthreadpool&#34;&gt;&#xD;&#xA;  Executors.newScheduledThreadPool&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#executorsnewscheduledthreadpool&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);&#xD;&#xA;&#xD;&#xA;# Java实现&#xD;&#xA;public ScheduledThreadPoolExecutor(int corePoolSize) {&#xD;&#xA;    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,&#xD;&#xA;          new DelayedWorkQueue());&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;# 使用&#xD;&#xA;// a. scheduleAtFixedRate - 固定频率执行（任务开始时间间隔固定）&#xD;&#xA;executor.scheduleAtFixedRate(&#xD;&#xA;    () -&amp;gt; System.out.println(&amp;#34;固定频率任务：&amp;#34; + System.currentTimeMillis()),&#xD;&#xA;    0,         // 初始延迟&#xD;&#xA;    2,         // 周期&#xD;&#xA;    TimeUnit.SECONDS&#xD;&#xA;);&#xD;&#xA;&#xD;&#xA;// b. scheduleWithFixedDelay - 固定延迟执行（任务结束时间与下次开始时间间隔固定）&#xD;&#xA;executor.scheduleWithFixedDelay(&#xD;&#xA;    () -&amp;gt; {&#xD;&#xA;        try {&#xD;&#xA;            Thread.sleep(1500); // 模拟任务耗时&#xD;&#xA;        } catch (InterruptedException e) {&#xD;&#xA;            e.printStackTrace();&#xD;&#xA;        }&#xD;&#xA;        System.out.println(&amp;#34;固定延迟任务：&amp;#34; + System.currentTimeMillis());&#xD;&#xA;    },&#xD;&#xA;    0,         // 初始延迟&#xD;&#xA;    1,         // 延迟时间&#xD;&#xA;    TimeUnit.SECONDS&#xD;&#xA;);&#xD;&#xA;&#xD;&#xA;// c. schedule - 延迟执行一次&#xD;&#xA;executor.schedule(&#xD;&#xA;    () -&amp;gt; System.out.println(&amp;#34;仅执行一次的延迟任务&amp;#34;),&#xD;&#xA;    5,         // 延迟时间&#xD;&#xA;    TimeUnit.SECONDS&#xD;&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;执行定时任务的线程池：支持定时或周期性任务执行&lt;/li&gt;&#xA;&lt;li&gt;scheduleAtFixedReat 固定频率开始任务，以上一次任务的开始时间和这次任务的开始时间间隔固定&lt;/li&gt;&#xA;&lt;li&gt;scheduleWithFixedDelay 固定延迟开始任务，以上一次任务的结束时间和这次任务的开始时间之间固定延迟&lt;/li&gt;&#xA;&lt;li&gt;sechedule 延迟一段时间执行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;executorsnewsinglethreadscheduledexecutor&#34;&gt;&#xD;&#xA;  Executors.newSingleThreadScheduledExecutor&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#executorsnewsinglethreadscheduledexecutor&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();&#xD;&#xA;&#xD;&#xA;# Java实现&#xD;&#xA;public ScheduledThreadPoolExecutor(int corePoolSize) {&#xD;&#xA;    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,&#xD;&#xA;          new DelayedWorkQueue());&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;单线程的定时任务线程池，单线程保证任务按顺序执行&lt;/li&gt;&#xA;&lt;li&gt;适合需要定时执行的顺序任务（如每日数据备份）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;executorsnewworkstealingpool&#34;&gt;&#xD;&#xA;  Executors.newWorkStealingPool&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#executorsnewworkstealingpool&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ExecutorService executor = Executors.newWorkStealingPool();&#xD;&#xA;&#xD;&#xA;# Java实现&#xD;&#xA;public static ExecutorService newWorkStealingPool() {&#xD;&#xA;    return new ForkJoinPool&#xD;&#xA;        (Runtime.getRuntime().availableProcessors(),&#xD;&#xA;         ForkJoinPool.defaultForkJoinWorkerThreadFactory,&#xD;&#xA;         null, true);&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;根据当前CPU情况生成线程池，适用计算密集型应用&lt;/p&gt;</description>
    </item>
    <item>
      <title>线程中断</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/multi-thread/thread-interrupt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/multi-thread/thread-interrupt/</guid>
      <description>&lt;h1 id=&#34;线程中断&#34;&gt;&#xD;&#xA;  线程中断&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e4%b8%ad%e6%96%ad&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;如何中断线程&#34;&gt;&#xD;&#xA;  如何中断线程？&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a6%82%e4%bd%95%e4%b8%ad%e6%96%ad%e7%ba%bf%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;调用线程对象的interrupt方法中断指定线程&lt;/p&gt;&#xA;&lt;h2 id=&#34;如何判断当前线程是否被中断&#34;&gt;&#xD;&#xA;  如何判断当前线程是否被中断？&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a6%82%e4%bd%95%e5%88%a4%e6%96%ad%e5%bd%93%e5%89%8d%e7%ba%bf%e7%a8%8b%e6%98%af%e5%90%a6%e8%a2%ab%e4%b8%ad%e6%96%ad&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;调用线程对象的isInterrupted方法&lt;/p&gt;&#xA;&lt;h2 id=&#34;线程中断线程就停止了吗&#34;&gt;&#xD;&#xA;  线程中断线程就停止了吗？&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e4%b8%ad%e6%96%ad%e7%ba%bf%e7%a8%8b%e5%b0%b1%e5%81%9c%e6%ad%a2%e4%ba%86%e5%90%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;程序中，我们不能随便中断一个线程，因为十分不安全，因为我们不知道线程当前处于何种状态&lt;br&gt;&#xA;强行中断可能会导致锁不能释放、操作数据库可能导致事务无法提交等&lt;br&gt;&#xA;Java中将线程的Stop方法设置为过时，禁止使用。&lt;br&gt;&#xA;当我们执行线程的interrupt方法时，本质不是中断线程，而是设置一个标志位&lt;br&gt;&#xA;当一个线程的interrupt方法被调用：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;如果线程当前阻塞，如io、wait，会立马退出阻塞，并抛出Interruption异常，我们通过捕获Interruption异常，做一定处理，然后让线程结束方法退出&lt;/li&gt;&#xA;&lt;li&gt;如果线程在运行中，则不受影响继续运行。仅仅是线程的中断标记被设置为true，需要线程自己在适当的位置检查isInterrupted方法来查看自己是否被中断，并作退出操作&lt;/li&gt;&#xA;&lt;li&gt;值得一提的是，Thread.isInterrupted() 判断中断异常后，中断标志位会变为false，相当于中断标志位被清空。如果后面还想判断执行停止，此时需要手动再次中断或者设置标志位&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# Java实现 Thread类&#xD;&#xA;public static boolean interrupted() {&#xD;&#xA;    return currentThread().isInterrupted(true);&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;public boolean isInterrupted() {&#xD;&#xA;    return isInterrupted(false);&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;private native boolean isInterrupted(boolean ClearInterrupted);&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;如果一个任务创建了线程池来执行子任务需要中断主任务和子任务&#34;&gt;&#xD;&#xA;  如果一个任务创建了线程池来执行子任务，需要中断主任务和子任务&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a6%82%e6%9e%9c%e4%b8%80%e4%b8%aa%e4%bb%bb%e5%8a%a1%e5%88%9b%e5%bb%ba%e4%ba%86%e7%ba%bf%e7%a8%8b%e6%b1%a0%e6%9d%a5%e6%89%a7%e8%a1%8c%e5%ad%90%e4%bb%bb%e5%8a%a1%e9%9c%80%e8%a6%81%e4%b8%ad%e6%96%ad%e4%b8%bb%e4%bb%bb%e5%8a%a1%e5%92%8c%e5%ad%90%e4%bb%bb%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;则在主任务的中断操作中，调用线程池的中断方法停止线程池&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;shutdown方法&lt;br&gt;&#xA;拒接新任务，新任务提交时执行拒绝策略。&lt;br&gt;&#xA;但是队列中的任务仍会继续执行直到完毕，中断空闲线程&lt;/li&gt;&#xA;&lt;li&gt;shutdownNow方法&lt;br&gt;&#xA;拒接新任务，新任务提交执行拒绝策略。 &lt;br&gt;&#xA;调用所有线程的interrupt方法进行终端，子任务需要自己执行结束任务。&lt;br&gt;&#xA;任务队列中的任务不会继续执行，并返回被抛弃的任务List&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>Java中线程的实现</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/multi-thread/java-thread/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/multi-thread/java-thread/</guid>
      <description>&lt;h1 id=&#34;java中线程的实现&#34;&gt;&#xD;&#xA;  Java中线程的实现&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#java%e4%b8%ad%e7%ba%bf%e7%a8%8b%e7%9a%84%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;线程与进程&#34;&gt;&#xD;&#xA;  线程与进程&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e4%b8%8e%e8%bf%9b%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;线程是比进程更加轻量级的调度执行单位，引入线程可以将进程的资源分配和执行调度分开，各个线程共享进程的资源，又可以独立调度&lt;br&gt;&#xA;线程是Java中处理器资源调度的最基本单位&lt;/p&gt;&#xA;&lt;h2 id=&#34;java线程的实现&#34;&gt;&#xD;&#xA;  Java线程的实现&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#java%e7%ba%bf%e7%a8%8b%e7%9a%84%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;Thread对象内的许多关键方法都被声明为native&lt;br&gt;&#xA;native方法意味着这个方法没有使用或无法使用平台无关的手段来实现，即，Java线程的实现依赖于平台对线程的实现&#xA;以HotSpot为例，每一个Java线程都是直接映射到一个操作系统原生线程来实现，中间没有额外的间接结构&lt;br&gt;&#xA;HotSpot自身不会干涉线程调度，只能设置优先级给操作系统提供调度建议，全权交给操作系统处理&lt;br&gt;&#xA;什么时候冻结/唤醒/停止线程、该给线程分配多少处理器执行时间、线程分配给哪个处理器执行，都是操作系统完成，操作系统全权决定&lt;/p&gt;&#xA;&lt;h2 id=&#34;java线程调度&#34;&gt;&#xD;&#xA;  Java线程调度：&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#java%e7%ba%bf%e7%a8%8b%e8%b0%83%e5%ba%a6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;线程调度指Java为线程分配处理器使用权的过程。&#xA;两种调度方式：协同式调度、抢占式调度&lt;br&gt;&#xA;Java使用的线程调度方式为抢占式调度&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;每个线程都是由系统分配执行时间，线程的切换线程自己不能决定。不会出现一个线程导致整个进程或系统阻塞的问题。&lt;/li&gt;&#xA;&lt;li&gt;Thread::yield方法主动让出执行时间，但是不能主动获取执行时间&lt;/li&gt;&#xA;&lt;li&gt;Java只能建议操作系统给一些线程分配多一点执行时间，另一些少一点。通过设置优先级来完成&lt;/li&gt;&#xA;&lt;li&gt;Java一共设置了十个级别的优先级，两个线程同时处于Ready状态时，优先级高的容易被同选择执行&lt;/li&gt;&#xA;&lt;li&gt;操作系统仍是全权掌握决定权，甚至可以更改优先级。我们无法在程序中准确判断一组状态都为Ready的线程哪一个会先执行。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;java线程状态转换&#34;&gt;&#xD;&#xA;  Java线程状态转换&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#java%e7%ba%bf%e7%a8%8b%e7%8a%b6%e6%80%81%e8%bd%ac%e6%8d%a2&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;Java语言定义了线程的六种状态：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;新建&lt;br&gt;&#xA;创建后尚未start的线程&lt;/li&gt;&#xA;&lt;li&gt;运行&lt;br&gt;&#xA;线程有可能在执行，有可能在等待操作系统分配执行时间&lt;/li&gt;&#xA;&lt;li&gt;无限期等待&lt;br&gt;&#xA;该状态的线程不会被分配处理器执行时间，必须等待其他线程显式唤醒&lt;br&gt;&#xA;如Thread.Join()，object.wait()的不设置Timeout的方法&lt;br&gt;&#xA;唤醒方法如notify()&lt;/li&gt;&#xA;&lt;li&gt;限期等待&lt;br&gt;&#xA;等待期间不会被分配处理器调度时间，但是不需要其他线程显式唤醒，一定时间后系统会自动唤醒&lt;br&gt;&#xA;如sleep，有参的wait、join等方法&lt;/li&gt;&#xA;&lt;li&gt;阻塞&lt;br&gt;&#xA;阻塞状态是在等待获取一个排他锁，将在另一个线程放弃一个排他锁时发生&lt;br&gt;&#xA;等待则是等待唤醒动作的出现&lt;/li&gt;&#xA;&lt;li&gt;结束&lt;br&gt;&#xA;已终止的线程状态，线程结束执行&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;wait和notifynotifyall&#34;&gt;&#xD;&#xA;  wait和notify/notifyAll&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#wait%e5%92%8cnotifynotifyall&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;wait和notify/notifyAll方法是Object对象的实例方法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 对象锁&#xD;&#xA;private static final Object lock = new Object();&#xD;&#xA;private static int count = 0;&#xD;&#xA;&#xD;&#xA;// 生产者&#xD;&#xA;public static void producer() {&#xD;&#xA;    synchronized (lock) {&#xD;&#xA;        count++;&#xD;&#xA;        System.out.println(&amp;#34;生产数据，count=&amp;#34; + count);&#xD;&#xA;        lock.notify(); // 唤醒消费者&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;// 消费者&#xD;&#xA;public static void consumer() {&#xD;&#xA;    synchronized (lock) {&#xD;&#xA;        while (count == 0) {&#xD;&#xA;            try {&#xD;&#xA;                System.out.println(&amp;#34;等待数据...&amp;#34;);&#xD;&#xA;                lock.wait(); // 释放锁并等待&#xD;&#xA;            } catch (InterruptedException e) {&#xD;&#xA;                e.printStackTrace();&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        count--;&#xD;&#xA;        System.out.println(&amp;#34;消费数据，count=&amp;#34; + count);&#xD;&#xA;    }&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;wait方法必须在sychronized同步代码块下使用，否则会报错&lt;/li&gt;&#xA;&lt;li&gt;wait() 让线程释放锁并进入等待状态，需通过 同一对象的 notify()/notifyAll() 唤醒。&lt;/li&gt;&#xA;&lt;li&gt;notify() 只能唤醒在该对象锁上等待的线程，且唤醒后线程需重新竞争锁&lt;/li&gt;&#xA;&lt;li&gt;wait()和notify()/notifyAll()必须成对出现&#xA;没有 notify()，wait() 线程会一直阻塞；&lt;br&gt;&#xA;没有 wait()，notify() 会被忽略（无等待线程时调用 notify() 无副作用）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;threadsleeplong-millis&#34;&gt;&#xD;&#xA;  Thread.sleep(long millis)&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#threadsleeplong-millis&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Thread类的静态方法&lt;/li&gt;&#xA;&lt;li&gt;让线程等待一段时间后继续执行，不需要显式环境&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;try {&#xD;&#xA;    Thread.sleep(1000);&#xD;&#xA;} catch (InterruptedException e) {&#xD;&#xA;    e.printStackTrace();&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;threadjoin&#34;&gt;&#xD;&#xA;  thread.join()&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#threadjoin&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Thread对象的实例方法&lt;/li&gt;&#xA;&lt;li&gt;等待线程执行结束&lt;/li&gt;&#xA;&lt;li&gt;让主线程等待该线程执行完毕后再继续执行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Thread thread = new Thread(() -&amp;gt; {&#xD;&#xA;    try {&#xD;&#xA;        Thread.sleep(2000);&#xD;&#xA;        System.out.println(&amp;#34;子线程执行完毕&amp;#34;);&#xD;&#xA;    } catch (InterruptedException e) {&#xD;&#xA;        e.printStackTrace();&#xD;&#xA;    }&#xD;&#xA;});&#xD;&#xA;&#xD;&#xA;thread.start();&#xD;&#xA;System.out.println(&amp;#34;主线程等待子线程结束...&amp;#34;);&#xD;&#xA;thread.join(); // 主线程阻塞，直到子线程结束&#xD;&#xA;System.out.println(&amp;#34;主线程继续执行&amp;#34;);&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;threadyield&#34;&gt;&#xD;&#xA;  Thread.yield()&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#threadyield&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Thread 类的静态方法&lt;/li&gt;&#xA;&lt;li&gt;主动让出当前线程的CPU资源，让当前线程从 运行状态 转为 就绪状态，允许其他同优先级线程抢占 CPU&#xA;不释放锁，也不阻塞线程，仅提示调度器重新分配资源。&lt;br&gt;&#xA;无法保证一定生效（调度器可能忽略 yield() 请求）&lt;/li&gt;&#xA;&lt;li&gt;可以用于测试线程优先级等（强制触发线程上下文切换）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Thread highPriorityThread = new Thread(() -&amp;gt; {&#xD;&#xA;    for (int i = 0; i &amp;lt; 3; i++) {&#xD;&#xA;        System.out.println(&amp;#34;高优先级线程执行：&amp;#34; + i);&#xD;&#xA;        Thread.yield(); // 主动让出 CPU，观察低优先级线程是否能执行&#xD;&#xA;    }&#xD;&#xA;});&#xD;&#xA;highPriorityThread.setPriority(Thread.MAX_PRIORITY);&#xD;&#xA;&#xD;&#xA;Thread lowPriorityThread = new Thread(() -&amp;gt; {&#xD;&#xA;    for (int i = 0; i &amp;lt; 3; i++) {&#xD;&#xA;        System.out.println(&amp;#34;低优先级线程执行：&amp;#34; + i);&#xD;&#xA;    }&#xD;&#xA;});&#xD;&#xA;lowPriorityThread.setPriority(Thread.MIN_PRIORITY);&#xD;&#xA;&#xD;&#xA;highPriorityThread.start();&#xD;&#xA;lowPriorityThread.start();&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;可以降低后台不重要线程（比如异步日志）的CPU占用&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public class LogTask implements Runnable {&#xD;&#xA;    @Override&#xD;&#xA;    public void run() {&#xD;&#xA;        while (!Thread.currentThread().isInterrupted()) {&#xD;&#xA;            // 执行轻量级任务（如日志记录）&#xD;&#xA;            logInfo();&#xD;&#xA;            Thread.yield(); // 让出 CPU，减少资源占用&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;可以降低线程空转的影响&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;while (conditionNotMet()) {&#xD;&#xA;    Thread.yield(); // 让出 CPU，避免忙等待&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>ThreadLocal</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/multi-thread/threadlocal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/multi-thread/threadlocal/</guid>
      <description>&lt;h1 id=&#34;threadlocal&#34;&gt;&#xD;&#xA;  ThreadLocal&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#threadlocal&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;ThreadLocal是线程自己的私有变量副本，仅属于当前线程&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;每个线程Thread对象中都带有一个ThreadLocalMap对象，我们可以创建一个ThreadLocal作为该Map的Key，然后在Value中存储想要的值&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;每一个ThreadLocal对象都有独一无二的ThreadLocalHashCode值&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;ThreadLocal set的时候，实际上是拿到Thread里面的ThreadLocalMap来进行Set&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;ThreadLocal对象使用完毕后，应该进行回收，手动调用ThreadLocal的remove方法&lt;br&gt;&#xA;避免线程不被回收时（如线程池），ThreadLocalMap中的对象不被回收，从而出现内存泄漏&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;经典使用场景&#34;&gt;&#xD;&#xA;  经典使用场景&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%8f%e5%85%b8%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;在多个层级的方法中传递某个参数&lt;br&gt;&#xA;为了避免在方法参数列表上每个都加上这些参数带来的冗余&lt;br&gt;&#xA;写入ThreadLocalMap中存储&lt;br&gt;&#xA;如连接管理，某个连接对象要在不同的方法间传递，但同时线程之间又不共享连接&lt;br&gt;&#xA;（减少同一个线程内多个函数或者组件之间公共变量的传递的复杂度）&lt;/p&gt;&#xA;&lt;h2 id=&#34;可能出现内存泄露的原因&#34;&gt;&#xD;&#xA;  可能出现内存泄露的原因&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%af%e8%83%bd%e5%87%ba%e7%8e%b0%e5%86%85%e5%ad%98%e6%b3%84%e9%9c%b2%e7%9a%84%e5%8e%9f%e5%9b%a0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;内存泄漏指的是程序中已经动态分配的堆内存由于某种原因未释放或无法释放，造成系统内存浪费，最终导致程序运行速度变慢等严重后果&lt;br&gt;&#xA;如果有一个对象，在将来再也不会被使用，但是就是没有被回收，那么认为该对象属于内存泄漏&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;ThreadLocalMap的生命周期与Thread一样长，如果Thread执行完某个业务后，不删除对应ThreadLocal，且线程不被销毁（线程池线程），内部保持着的内容显然对系统是无意义的，这就是一种内存泄漏。&lt;/li&gt;&#xA;&lt;li&gt;一些ThreadLocal错误使用导致内存泄露的场景：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;ThreadLocal定义为局部变量，线程执行完后没有remove，线程未被销毁。则ThreadLocal对象的强引用消失，仅剩ThreadLocalMap中的弱引用Key，GC仍然会把对象回收。此时ThreadLocalMap就有一个Entry的key为null，不会被别人访问，也不会被GC回收。出现内存泄露。&lt;/li&gt;&#xA;&lt;li&gt;ThreadLocal定义为类变量，但是我们为了防止业务上的问题，在不理解ThreadLocal原理的情况下，每次都进入方法前去重新实例化ThreadLocal，业务结束后错误地将ThreadLocal设为null想以此避免业务上的问题，则以前的一些ThreadLocal对象强引用消失，出现上一个问题的内存泄漏。&lt;/li&gt;&#xA;&lt;li&gt;ThreadLocal定义为类变量，一个线程执行完毕后没有remove，且线程未被销毁。后续该线程再也没有被用来执行该业务，以至于内部的ThreadLocal根本没有被访问的机会，这也是一种内存泄漏。&lt;/li&gt;&#xA;&lt;li&gt;在ThreadLocalMap中如果有Entry的key为null时，会在下一次调用set\get\remove方法时进行清理。但是如果后续我们再也没有访问过这个ThreadLocalMap，那自然出现上一个问题的内存泄漏。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;为什么threadlocalmap要使用弱引用key&#34;&gt;&#xD;&#xA;  为什么ThreadLocalMap要使用弱引用key？&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88threadlocalmap%e8%a6%81%e4%bd%bf%e7%94%a8%e5%bc%b1%e5%bc%95%e7%94%a8key&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果key为强引用，如果我们用完不去手动删除，ThreadLocal对象由于强引用不会被回收，则Entry会内存泄露&lt;/li&gt;&#xA;&lt;li&gt;如果Key为弱引用，我们不去手动删除，ThreadLocal没有其他强引用的情况下，GC回收掉ThreadLocal，ThreadLocalMap有机会在下一次访问清理无用的ThreadLocal，尽量避免内存泄露&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;内存泄露是因为ThreadLocalMap和Thread生命周期一致，如果不去手动删除，ThreadLocal很可能是无意义的内容，这是一种内存泄漏&lt;br&gt;&#xA;弱引用是用来尽量减少内存泄露的一种举措，但不够完善，仍有内存泄露的可能，即后续没有访问哪些方法导致Entry不被清理，而不是内存泄漏的产生原因&lt;br&gt;&#xA;内存泄露的产生原因是我们的错误使用方法。&lt;/p&gt;&#xA;&lt;h2 id=&#34;最佳实践&#34;&gt;&#xD;&#xA;  最佳实践&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;ThreadLocal定义为静态不可变常量&lt;br&gt;&#xA;使用完对应的value后，调用ThreadLocal.remove清理&lt;/p&gt;</description>
    </item>
    <item>
      <title>AQS</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/multi-thread/aqs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/multi-thread/aqs/</guid>
      <description>&lt;h1 id=&#34;aqs&#34;&gt;&#xD;&#xA;  AQS&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aqs&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;AQS：AbstractQueuedSynchronized类&lt;br&gt;&#xA;JUC包中的ReentrantLock、Semaphroe、ReentrantReadWriteLock、CountDownLatch等几乎所有类都依赖于AQS实现&lt;/p&gt;&#xA;&lt;h2 id=&#34;重要属性&#34;&gt;&#xD;&#xA;  重要属性&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%87%8d%e8%a6%81%e5%b1%9e%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;AQS有两个重要属性：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;以Node为节点实现的双向链表、先进先出队列，节点内包装线程&lt;/li&gt;&#xA;&lt;li&gt;STATE标志，通过CAS改变其值，象征锁资源&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;部分逻辑&#34;&gt;&#xD;&#xA;  部分逻辑&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%83%a8%e5%88%86%e9%80%bb%e8%be%91&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;线程抢占资源，就是尝试设置STATE标志位的值，ReentrantLock就是将其设置为1，如果重入则不断自增&lt;br&gt;&#xA;如果STATE &amp;gt; 0则该资源被占用，即锁定，其他线程不能获得锁&lt;/p&gt;&#xA;&lt;p&gt;线程抢占资源失败，则进入等锁队列中，等待头节点释放锁后唤醒后继节点得锁（公平锁），或唤醒所有节点抢锁（非公平锁）&lt;/p&gt;&#xA;&lt;p&gt;AQS是一个抽象类，继承AQS自己实现的同步器，只需要根据同步器需要满足得性质取实现线程获取和修改同步状态变量的方式，队列的维护已经被顶层实现好。&lt;br&gt;&#xA;仅需要实现父类的一些抽象方法，方法内部设置同步状态变量即可&lt;/p&gt;&#xA;&lt;p&gt;AQS独占锁：&lt;br&gt;&#xA;ReentrantLock、ReentrantWriteLock等&lt;br&gt;&#xA;AQS共享锁：&lt;br&gt;&#xA;ReentrantReadLock、Semaphore、ConutDownLatch等&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java的线程安全实现</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/multi-thread/java-thread-safe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/multi-thread/java-thread-safe/</guid>
      <description>&lt;h1 id=&#34;java的线程安全实现&#34;&gt;&#xD;&#xA;  Java的线程安全实现&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#java%e7%9a%84%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;线程安全的定义&#34;&gt;&#xD;&#xA;  线程安全的定义&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%9a%84%e5%ae%9a%e4%b9%89&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;多个线程同时访问一个对象/方法时，如果不用考虑这些线程运行时环境下的调度和交替进行，也不需要进行额外的同步，或者调用方进行任何其他协调&lt;br&gt;&#xA;调用该对象/方法的行为都能获得正确的结果，则该对象线程安全&lt;/p&gt;&#xA;&lt;h2 id=&#34;线程安全的实现方法&#34;&gt;&#xD;&#xA;  线程安全的实现方法&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%9a%84%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;互斥同步&#34;&gt;&#xD;&#xA;  互斥同步&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%92%e6%96%a5%e5%90%8c%e6%ad%a5&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;同步指：保证并发访问时，共享资源同一时刻只能被一个线程访问&lt;/li&gt;&#xA;&lt;li&gt;互斥是实现同步的一种手段。常见的互斥实现方式有：临界区、互斥量和信号量&lt;/li&gt;&#xA;&lt;li&gt;Java中的基本互斥手段为Synchronized关键字&lt;/li&gt;&#xA;&lt;li&gt;除此之外还有java.util.concurrent.locks包下的Lock接口&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;synchronized&#34;&gt;&#xD;&#xA;  Synchronized&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#synchronized&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;这是一种块结构的同步语法&lt;/li&gt;&#xA;&lt;li&gt;javac编译后，会在同步块的前后分别形成monitorenter和monitorexit两个字节码指令。两个指令都需要指定一个refrence类型的参数指定需要锁定和解锁的对象&lt;/li&gt;&#xA;&lt;li&gt;如果指定了一个对象，则以该对象的引用作为reference；如果没有明确指定，则根据修饰的方法类型（实例方法或类方法），来决定取代码所在对象实例还是取类型对应的Class对象作为锁&lt;/li&gt;&#xA;&lt;li&gt;JVM规范规定，执行monitorenter指令时，首先要尝试获取对象锁，如果没有被锁定或者当前线程已经持有，则锁计数器+1，执行monitorexit时，锁计数器-1；一旦计数器值为0，则锁被释放。&lt;/li&gt;&#xA;&lt;li&gt;如果当前线程获取锁失败，则进入阻塞状态，直到锁被释放&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;注意点：&lt;br&gt;&#xA;synchronized锁可重入&lt;br&gt;&#xA;synchronized同步块执行完毕并释放锁前，无条件阻塞后面的线程进入，意味着无法像处理某些数据库中的锁一样，强制已获取锁的线程释放锁，也无法让等锁线程中断等待和超时退出&lt;br&gt;&#xA;持有锁是重量级操作，由于Java的线程是内核线程实现，切换县城需要操作系统帮忙，涉及到内核态和用户态的转换，耗费很多处理器时间。虚拟机对synchronized进行了一些优化。优化后性能基本能和ReentrantLock持平&lt;/p&gt;&#xA;&lt;h3 id=&#34;非阻塞同步&#34;&gt;&#xD;&#xA;  非阻塞同步&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%9d%9e%e9%98%bb%e5%a1%9e%e5%90%8c%e6%ad%a5&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;互斥同步属于悲观的并发策略，总是认为只要不做正确的同步措施就一定会出问题，无论数据实际上是否发生竞争，都会加锁。有着线程切换、维护锁计数器的开销&lt;br&gt;&#xA;随着硬件指令集的发展，可以做到基于冲突检测的乐观并发策略。&lt;br&gt;&#xA;基本思想是：先执行操作，如果没有其他线程竞争，则操作成功，如果有冲突，则做其他补偿措施，通常措施是不断重试，直到没有竞争操作成功。&#xA;这种同步操作成为非阻塞同步，代码可称为无锁代码&lt;br&gt;&#xA;之所以必须依赖硬件指令集的发展，是要求操作和冲突检测的两个步骤具备原子性&lt;br&gt;&#xA;如果以来互斥同步保证原子性则失去意义，只能依靠硬件实现&lt;br&gt;&#xA;通过硬件来保证多次操作的行为只通过一条处理器指令就能完成。&lt;br&gt;&#xA;Java中使用的指令为CAS，比较并交换&lt;/p&gt;&#xA;&lt;h4 id=&#34;cas指令&#34;&gt;&#xD;&#xA;  CAS指令&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cas%e6%8c%87%e4%bb%a4&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;CAS：compare and swap&lt;br&gt;&#xA;能在不使用锁的情况下，非阻塞地实现多线程安全&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;需要三个操作数：内存地址V，旧的预期值A，准备设置的新值B&lt;/li&gt;&#xA;&lt;li&gt;执行时，当且仅当V符合A，才用B更新V，否则不执行更新。这是一个原子操作&lt;/li&gt;&#xA;&lt;li&gt;该操作由sun.misc.Unsafe类的compareAndSwapInt()和compareAndSwapLong等几个方法包装提供，编译结果是一条平台相关的处理器CAS指令&lt;/li&gt;&#xA;&lt;li&gt;设计上Unsafe类是不提供给用户程序调用的类，限制了只有启动类加载器加载的Class才能访问它，因此JDK9之前只有Java类库可以使用CAS&lt;/li&gt;&#xA;&lt;li&gt;J.U.C包中的整数原子类使用了CAS操作实现，如果用户程序需要使用，要么通过反射突破Unsafe的访问限制，要么通过Java类库API间接使用&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;注意点：&lt;br&gt;&#xA;CAS无法覆盖互斥同步的所有使用场景，有一个逻辑漏洞（ABA问题）：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;如果V读取时是A，准备赋值时也是A，不能说明它的值没有被其他线程改过。比如被赋值为B又改回来，会误认为没有被改过。&lt;/li&gt;&#xA;&lt;li&gt;为了解决这个问题，JUC包提供了带引用标记的AtomicStampedReference源自引用类，通过控制变量的版本来保证CAS的正确性，但是比较鸡肋，如果想解决ABA问题，可以使用传统互斥同步可能更高效&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>CountDownLatch</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/multi-thread/CountDownLatch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/multi-thread/CountDownLatch/</guid>
      <description>&lt;h1 id=&#34;countdownlatch&#34;&gt;&#xD;&#xA;  CountDownLatch&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#countdownlatch&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;使用&#34;&gt;&#xD;&#xA;  使用&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;new一个CountDownLatch，需要指定计数器值，表示需要等待执行完毕的线程数量&lt;/p&gt;&#xA;&lt;p&gt;开启多个线程执行任务，并调用CountDownLatch对象的await方法，开始等待任务执行&lt;br&gt;&#xA;每个线程的任务执行完后，都要调用CountDownLatch对象的countDown方法&lt;/p&gt;&#xA;&lt;p&gt;当调用countDown方法的线程数达到计数器值时，多线程任务执行完毕，await方法的等待状态被取消，外层逻辑继续向下执行&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;CountDownLatch latch = new CountDownLatch(3);&#xD;&#xA;&#xD;&#xA;// 创建并启动 3 个工作线程&#xD;&#xA;for (int i = 0; i &amp;lt; 3; i++) {&#xD;&#xA;    final int taskId = i;&#xD;&#xA;    new Thread(() -&amp;gt; {&#xD;&#xA;        try {&#xD;&#xA;            System.out.println(&amp;#34;任务&amp;#34; + taskId + &amp;#34;开始执行&amp;#34;);&#xD;&#xA;            // 执行...&#xD;&#xA;            System.out.println(&amp;#34;任务&amp;#34; + taskId + &amp;#34;完成&amp;#34;);&#xD;&#xA;        } catch (Exception e) {&#xD;&#xA;            // ...&#xD;&#xA;        } finally {&#xD;&#xA;            // 任务完成后，计数器减 1&#xD;&#xA;            latch.countDown();&#xD;&#xA;        }&#xD;&#xA;    }).start();&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;// 主线程等待，直到计数器变为 0&#xD;&#xA;System.out.println(&amp;#34;主线程等待所有任务完成...&amp;#34;);&#xD;&#xA;latch.await();&#xD;&#xA;System.out.println(&amp;#34;所有任务已完成，主线程继续执行&amp;#34;);&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;原理&#34;&gt;&#xD;&#xA;  原理&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;CountDownLatch基于AbstractQueuedSynchronized（AQS）实现&lt;br&gt;&#xA;await方法被调用时，主线程进入等锁队列&lt;br&gt;&#xA;countDown方法被调用时，CountDownLatch对象内部计数器-1&lt;br&gt;&#xA;CountDownLatch对象内部计数器为0时，主线程被唤醒，继续执行任务&lt;/p&gt;</description>
    </item>
    <item>
      <title>ReentrantLock</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/multi-thread/ReentrantLock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/multi-thread/ReentrantLock/</guid>
      <description>&lt;h1 id=&#34;reentrantlock&#34;&gt;&#xD;&#xA;  ReentrantLock&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#reentrantlock&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;介绍&#34;&gt;&#xD;&#xA;  介绍&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;JDK5时，没有synchronized优化，该关键字加锁是个比较重的操作&lt;br&gt;&#xA;J.U.C.locks.Lock接口提供了基于类的全新互斥手段，后续扩展出了不同调度算法、不同特征、不同性能不同于一的各种锁&lt;/p&gt;&#xA;&lt;p&gt;重入锁（ReentrantLock）是Lock的最常见实现，是可重入的&lt;br&gt;&#xA;基本用法和synchronized相似，相比synchronized主要增加了三个高级功能：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;等待可中断&lt;br&gt;&#xA;持锁线程长期不释放锁，正在等待的线程可以放弃等待，改为处理其他事情&lt;/li&gt;&#xA;&lt;li&gt;公平锁&lt;br&gt;&#xA;多个线程等待同个锁时，必须按照申请所得时间顺序来依次获得锁&lt;br&gt;&#xA;非公平锁在锁什邡市，任何等锁线程都能有机会获得锁&lt;br&gt;&#xA;synchronized是非公平的，ReentrantLock默认也是非公平，但是可以通过布尔参数改为公平锁&lt;br&gt;&#xA;使用公平锁后ReentrantLock性能急剧下降，影响吞吐量&lt;/li&gt;&#xA;&lt;li&gt;锁绑定多个条件&lt;br&gt;&#xA;一个ReentrantLock可以绑定多个Condition对象&lt;br&gt;&#xA;synchronized中，锁对象的wait、notify或notifyAll方法配合可以实现一个隐含条件，但是如果要和多于一个的条件关联，则必须额外添加锁&lt;br&gt;&#xA;但ReentrantLock则多次调用newCondition即可&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;锁释放&#34;&gt;&#xD;&#xA;  锁释放&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%94%81%e9%87%8a%e6%94%be&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;使用Lock需要保证在Finally块中释放锁，否则抛出异常后可能永远不会释放锁&lt;br&gt;&#xA;synchronized则由虚拟机保证锁的正常释放&lt;/p&gt;&#xA;&lt;h2 id=&#34;基本实现原理&#34;&gt;&#xD;&#xA;  基本实现原理&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e6%9c%ac%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;Lock接口的实现内部封装了一个AQS同步队列&lt;br&gt;&#xA;AQS同步队列支持先进先出，数据结构为双向链表，维护头尾指针，方便从任意一个位置访问前后节点&lt;br&gt;&#xA;线程如果得锁失败，就会被封装成Node进入等锁队列&lt;br&gt;&#xA;当获取锁的线程释放锁，就从队列中取出一个节点唤醒线程&lt;/p&gt;&#xA;&lt;p&gt;一个线程得锁失败，则加入队列尾，通过尾结点指针对接队列尾&lt;br&gt;&#xA;通过CAS将tail指向新的尾节点&lt;br&gt;&#xA;一个线程释放锁，唤醒后继节点，后继节点得锁成功后，会把自己设为队列头节点&lt;br&gt;&#xA;设置头节点不需要用CAS，因为设置头节点是获取锁的线程来完成&lt;br&gt;&#xA;同步锁只能由一个线程获取，所以不需要CAS保证&lt;/p&gt;&#xA;&lt;p&gt;ReentraintLock锁对象，通过CAS进行加锁，如果加锁失败，则走锁竞争的逻辑&lt;br&gt;&#xA;加锁成功则走加锁成功逻辑&lt;/p&gt;&#xA;&lt;p&gt;加锁成功后，会设置state属性值，支持可重入，同个每次加锁state值加一，解锁则减一，如果state值大一0，说明此时有线程持有锁，=0则是五锁状态&lt;/p&gt;&#xA;&lt;h2 id=&#34;公平非公平锁&#34;&gt;&#xD;&#xA;  公平/非公平锁&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%ac%e5%b9%b3%e9%9d%9e%e5%85%ac%e5%b9%b3%e9%94%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;公平锁就是锁释放后唤醒后继节点获得锁 &lt;br&gt;&#xA;非公平锁就是唤醒全部线程，让他们都CAS一下，谁成功谁就得锁，不成功就进入队列等待下一次&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
