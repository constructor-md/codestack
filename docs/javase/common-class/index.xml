<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>常用类 on CodeStack</title>
    <link>https://constructor-md.github.io/codestack/docs/javase/common-class/</link>
    <description>Recent content in 常用类 on CodeStack</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <atom:link href="https://constructor-md.github.io/codestack/docs/javase/common-class/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>基本数据类型</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/common-class/basic-data/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/common-class/basic-data/</guid>
      <description>&lt;h1 id=&#34;基本数据类型&#34;&gt;&#xD;&#xA;  基本数据类型&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;整型&#34;&gt;&#xD;&#xA;  整型：&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b4%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Byte 8位 1字节&lt;/li&gt;&#xA;&lt;li&gt;Short 16位 2字节&lt;/li&gt;&#xA;&lt;li&gt;Int 32位 4字节&lt;/li&gt;&#xA;&lt;li&gt;Long 64位 8字节&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;浮点型&#34;&gt;&#xD;&#xA;  浮点型&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b5%ae%e7%82%b9%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Float 32位&lt;/li&gt;&#xA;&lt;li&gt;Double 64位&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;字符型&#34;&gt;&#xD;&#xA;  字符型&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ad%97%e7%ac%a6%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Char 16位Unicode&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;布尔型&#34;&gt;&#xD;&#xA;  布尔型&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b8%83%e5%b0%94%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Boolean 32位&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;可以自动从短类型转为长类型&lt;br&gt;&#xA;如果把大整数转成小数类型，会有精度丢失&lt;br&gt;&#xA;如果强转类型，则会截尾，丢失尾部数据&lt;/p&gt;</description>
    </item>
    <item>
      <title>String|StringBuilder|StringBuffer</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/common-class/string-stringbuilder-stringbuffer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/common-class/string-stringbuilder-stringbuffer/</guid>
      <description>&lt;h1 id=&#34;stringstringbuilderstringbuffer&#34;&gt;&#xD;&#xA;  String|StringBuilder|StringBuffer&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#stringstringbuilderstringbuffer&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;string&#34;&gt;&#xD;&#xA;  String&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#string&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;String是不可变字符串对象&lt;/li&gt;&#xA;&lt;li&gt;如果进行修改，会生成一个新的字符串赋给引用&lt;/li&gt;&#xA;&lt;li&gt;由于不可变，所以线程安全&lt;/li&gt;&#xA;&lt;li&gt;String的字面量值会被放入字符串常量池&lt;/li&gt;&#xA;&lt;li&gt;当进行字符串的equals比较，由于String重写了equals方法，调用时是比较每一个char字符来判断是否相等&lt;/li&gt;&#xA;&lt;li&gt;当进行==比较时，比较的是对象的内存地址是否相等&lt;/li&gt;&#xA;&lt;li&gt;如果使用字面量“”== String对象，则实际上比较的是字符串常量池中该字面量的地址和堆中String的地址，结果肯定是不相等&lt;/li&gt;&#xA;&lt;li&gt;当使用==比较两个String，结果也是不相等&lt;/li&gt;&#xA;&lt;li&gt;可以使用String.intern方法取出字符串常量池的地址，从而==判断可以相等&lt;/li&gt;&#xA;&lt;li&gt;当需要比较字符串是否相等时，equals永远是不会出错的方法&lt;/li&gt;&#xA;&lt;li&gt;String a = new String(&amp;ldquo;xx&amp;rdquo;);时，可能出现一个或两个对象，一个在堆里，字面量在常量池&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;stringbuffer&#34;&gt;&#xD;&#xA;  StringBuffer&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#stringbuffer&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;线程安全，append方法加入了synchronized同步锁。效率低&lt;/p&gt;&#xA;&lt;h2 id=&#34;stringbuilder&#34;&gt;&#xD;&#xA;  StringBuilder&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#stringbuilder&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;线程不安全，append方法未加锁，但效率高&lt;/p&gt;</description>
    </item>
    <item>
      <title>比较对象相等</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/common-class/object-equals/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/common-class/object-equals/</guid>
      <description>&lt;h1 id=&#34;比较对象相等&#34;&gt;&#xD;&#xA;  比较对象相等&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%af%94%e8%be%83%e5%af%b9%e8%b1%a1%e7%9b%b8%e7%ad%89&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;对于8种基本数据类型，==比较的是操作数的值之间的关系&lt;br&gt;&#xA;其余一切皆是对象，==比较的是内存地址&lt;br&gt;&#xA;由Object继承来的equals方法比较的是内存地址&lt;/p&gt;&#xA;&lt;p&gt;Object规范约定：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果两个对象通过equals方法比较是相等的，则hashcode方法结果值必须相等&lt;/li&gt;&#xA;&lt;li&gt;如果两个对象通过equals方法比较不相等，则不要求hashcode方法结果相等&#xA;当一个程序执行过程中，equals方法没有修改任何信息，同一个对象上重复调用hashcode方法，必须返回相同值&lt;br&gt;&#xA;两个应用互相调用，则hascode可以不一致。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这意味着，当我们要重写equals方法时，必须重写hashcode方法。&lt;br&gt;&#xA;否则可能违反：同一对象的hashcode值必须相等的约定&lt;br&gt;&#xA;会使得一些使用hashcode的类使用出现问题&lt;br&gt;&#xA;如HashMap，存入时会调用类自身的hashcode方法得到hashcode；&lt;/p&gt;</description>
    </item>
    <item>
      <title>自动拆装箱</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/common-class/auto-bin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/common-class/auto-bin/</guid>
      <description>&lt;h1 id=&#34;自动拆装箱&#34;&gt;&#xD;&#xA;  自动拆装箱&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%87%aa%e5%8a%a8%e6%8b%86%e8%a3%85%e7%ae%b1&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;装箱：基本数据类型转换对象&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;拆箱：对象转换基本数据类型&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;自动装箱：编译器调用valueOf，将基本类型转换成对象&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;自动拆箱：编译器通过调用类似intValue、doubleValue方法，将对象转成基本类型&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;包装类型的享元模式：&lt;br&gt;&#xA;Integer类的静态内部类，在类加载时执行静态方法，静态方法中实例化了-128-127数值的Integer对象放入数组中，作为缓存&lt;/p&gt;&#xA;&lt;p&gt;类似的缓存存在于几乎所有对应包装类型（所以包装类型比较一定要用equals最保险）&lt;/p&gt;</description>
    </item>
    <item>
      <title>int|Integer</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/common-class/int-integer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/common-class/int-integer/</guid>
      <description>&lt;h1 id=&#34;int和integer的区别&#34;&gt;&#xD;&#xA;  int和Integer的区别&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#int%e5%92%8cinteger%e7%9a%84%e5%8c%ba%e5%88%ab&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;数据类型不同，int是基本数据类型，Integer是引用数据类型&lt;/li&gt;&#xA;&lt;li&gt;默认值不同，int默认值为0，Integer默认值为null&lt;/li&gt;&#xA;&lt;li&gt;存储方式不同&lt;/li&gt;&#xA;&lt;li&gt;int在内存中直接存储数值，如果是成员变量则放在堆内的对象中，如果是局部变量则放在线程私有的虚拟机栈中&lt;/li&gt;&#xA;&lt;li&gt;Integer是引用类型，存储的是一个对象地址，new时是生成一个指针指向该对象，实际对象在堆中&lt;/li&gt;&#xA;&lt;li&gt;实例化方式不同，Integer必须实例化才能使用，int不需要&lt;/li&gt;&#xA;&lt;li&gt;变量比较方式不同，int之间可以==比较，Integer之间最好equals比较&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;int和Integer之间的比较：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;int之间可以==比较&lt;/li&gt;&#xA;&lt;li&gt;int和Integer之间比较时，Integer自从拆箱变为int进行比较，可以==比较&lt;/li&gt;&#xA;&lt;li&gt;Integer和Integer之间比较，由于内部缓存了值为-128-127的对象，对这个范围内可以==比较，对其他范围必须eaquls比较，equals比较时是在比较内部的int值&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
  </channel>
</rss>
