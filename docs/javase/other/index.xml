<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>其他 on CodeStack</title>
    <link>https://constructor-md.github.io/codestack/docs/javase/other/</link>
    <description>Recent content in 其他 on CodeStack</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <atom:link href="https://constructor-md.github.io/codestack/docs/javase/other/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>深拷贝/浅拷贝</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/other/clone/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/other/clone/</guid>
      <description>&lt;h1 id=&#34;深拷贝浅拷贝&#34;&gt;&#xD;&#xA;  深拷贝/浅拷贝&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b7%b1%e6%8b%b7%e8%b4%9d%e6%b5%85%e6%8b%b7%e8%b4%9d&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;对象拷贝，就是将一个对象复制一份。复制方法不同则有不同结果&lt;/p&gt;&#xA;&lt;h2 id=&#34;浅拷贝&#34;&gt;&#xD;&#xA;  浅拷贝&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b5%85%e6%8b%b7%e8%b4%9d&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;新建一个对象，将对方的属性全部复制过来&#xA;有自己的堆内存地址，但是对方的属性中的引用类型，对于双方来说是共享的，只复制了内存地址&#xA;只拷贝了第一层&lt;/p&gt;&#xA;&lt;h2 id=&#34;深拷贝&#34;&gt;&#xD;&#xA;  深拷贝&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b7%b1%e6%8b%b7%e8%b4%9d&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;有多少层就拷贝多少层，两个对象完全分开，但是内容相同&lt;/p&gt;&#xA;&lt;h2 id=&#34;相关接口和方法&#34;&gt;&#xD;&#xA;  相关接口和方法&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%9b%b8%e5%85%b3%e6%8e%a5%e5%8f%a3%e5%92%8c%e6%96%b9%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;cloneable接口&#34;&gt;&#xD;&#xA;  Cloneable接口&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#cloneable%e6%8e%a5%e5%8f%a3&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;是一个标记接口，在类中重写Object中的Clone方法，类调用clone方法才能克隆成功&lt;br&gt;&#xA;可以直接调用super.clone()，来使用Object中的clone方法得到浅克隆结果&lt;br&gt;&#xA;如果不实现该接口，则会抛出CloneNotSupported异常&lt;br&gt;&#xA;Cloneable接口下没有任何方法&lt;/p&gt;&#xA;&lt;h3 id=&#34;objectclone方法&#34;&gt;&#xD;&#xA;  Object.clone方法&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#objectclone%e6%96%b9%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;该方法被native修饰，是一个空方法，没有方法体（native修饰都是如此）&lt;br&gt;&#xA;每一个native方法在JVM中都有一个同名实现体&lt;br&gt;&#xA;判断是否实现Cloneable接口，是在JVM方法体中实现的&lt;br&gt;&#xA;默认实现浅拷贝&lt;/p&gt;&#xA;&lt;h2 id=&#34;如何实现深拷贝&#34;&gt;&#xD;&#xA;  如何实现深拷贝？&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e6%b7%b1%e6%8b%b7%e8%b4%9d&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;使用序列化将对象变成字节流，输入再输出&lt;br&gt;&#xA;或者让内部每一层对象都实现clone方法，调用clone方法时，将clone出来的对象的属性值替换成原属性值的clone结果&lt;br&gt;&#xA;或者嵌套遍历访问其中每个元素，新建对象复制值&lt;/p&gt;</description>
    </item>
    <item>
      <title>访问控制修饰符</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/other/access-modifiers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/other/access-modifiers/</guid>
      <description>&lt;h1 id=&#34;访问控制修饰符&#34;&gt;&#xD;&#xA;  访问控制修饰符&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6%e4%bf%ae%e9%a5%b0%e7%ac%a6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;private：访问权仅限本类&lt;/li&gt;&#xA;&lt;li&gt;default：当前包下任何对象可访问&lt;/li&gt;&#xA;&lt;li&gt;protect：当前包和不同包的子类可以访问&lt;/li&gt;&#xA;&lt;li&gt;public：可以被任何访问&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>封装|继承|多态</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/other/encap-inher-poly/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/other/encap-inher-poly/</guid>
      <description>&lt;h1 id=&#34;封装继承多态&#34;&gt;&#xD;&#xA;  封装|继承|多态&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b0%81%e8%a3%85%e7%bb%a7%e6%89%bf%e5%a4%9a%e6%80%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;封装&#34;&gt;&#xD;&#xA;  封装&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b0%81%e8%a3%85&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;说明一个类的属性或行为与其他类的关系&lt;br&gt;&#xA;隐藏了类的内部实现机制，使得可以在不影响使用的情况下，改变类的内部结构，同时也保护了数据&lt;br&gt;&#xA;对于外界而言，内部细节被隐藏，暴露出来的仅是访问方法&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;属性的封装：&lt;br&gt;&#xA;使用者只能通过事先定制好的方法来访问数据，可以方便地加入逻辑控制，限制对属性的不合理操作&lt;/li&gt;&#xA;&lt;li&gt;方法的封装：&lt;br&gt;&#xA;使用者按照既定的方式调用方法，不必关心方法的内部实现，便于使用、便于修改、增加代码的可维护性&lt;br&gt;&#xA;目标是实现低耦合，高内聚&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;继承&#34;&gt;&#xD;&#xA;  继承&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%a7%e6%89%bf&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;从已有的类派生出新的类，新的类吸收已有类的数据属性和行为，并可以扩展新的能力&lt;br&gt;&#xA;本质上是特殊到一般的关系，即is-a关系&lt;br&gt;&#xA;子类继承父类，表明子类是一种特殊的父类，并具备父类不具有的一些属性或方法。&lt;br&gt;&#xA;从多种实现类中抽象出一个基类，使其具备多种实现类的共同特性，当实现类使用extends关键字继承了基类后，实现类就具备了这些相同的属性&lt;br&gt;&#xA;继承的类叫子类（派生类或超类），被继承的类叫做父类（或基类）&lt;br&gt;&#xA;Java通过extends关键字实现继承，父类中private定义的变量和方法不会被继承，不能在子类中直接操作父类通过private定义的变量以及方法。&lt;br&gt;&#xA;继承避免了对一般类和特殊类之间共同特征进行的重复描述，通过继承可以清晰地表达每一项共同特征所适应的概念范围。在一般类中定义的属性和操作&lt;br&gt;&#xA;适用于这个类本身和它以下的每一层特殊类的全部对象。&lt;br&gt;&#xA;运用继承原则使得系统模型清晰简练&lt;/p&gt;&#xA;&lt;h2 id=&#34;多态&#34;&gt;&#xD;&#xA;  多态&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a4%9a%e6%80%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;指的是类与类之间的关系&lt;br&gt;&#xA;两个类之间由继承关系，存在方法的重写。于是可以在调用时由父类引用指向子类对象。&lt;br&gt;&#xA;多态必备三个要素：继承、重写、父类引用指向子类对象&lt;/p&gt;&#xA;&lt;h2 id=&#34;为什么这些特性可以让我们写出更好的代码&#34;&gt;&#xD;&#xA;  为什么这些特性可以让我们写出更好的代码？&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%bf%99%e4%ba%9b%e7%89%b9%e6%80%a7%e5%8f%af%e4%bb%a5%e8%ae%a9%e6%88%91%e4%bb%ac%e5%86%99%e5%87%ba%e6%9b%b4%e5%a5%bd%e7%9a%84%e4%bb%a3%e7%a0%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;封装：增加代码可复用性&lt;/li&gt;&#xA;&lt;li&gt;继承：增加代码可复用性，使得系统模型更加清晰，减少重复描述&lt;/li&gt;&#xA;&lt;li&gt;多态：增加代码灵活性，实现随便变，都可以通过统一的父类引用来调用实际对象方法&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>泛型</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/other/generics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/other/generics/</guid>
      <description>&lt;h1 id=&#34;泛型&#34;&gt;&#xD;&#xA;  泛型&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b3%9b%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;为什么需要泛型&#34;&gt;&#xD;&#xA;  为什么需要泛型&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e6%b3%9b%e5%9e%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;以集合为例，如果写死类型，集合就不通用，只能放某个类或者子类&lt;br&gt;&#xA;但是实际上，一个集合的设计需要给所有类型使用，包括未知的用户自定义类型&lt;/p&gt;&#xA;&lt;p&gt;如果使用 Object 代替，存储时方便，取出时需要显式强制类型转换&lt;br&gt;&#xA;与此同时，集合中还可以存放多种类型数据，导致强转、具体操作等均不安全&lt;br&gt;&#xA;如果判断类型再强转，会增加代码复杂度&lt;br&gt;&#xA;（Object 没有限制范围的能力）&lt;/p&gt;&#xA;&lt;p&gt;如果考虑存放时限制类型，但只能限制自己的编码，如果存在多人编码，调用自己的集合，获取到的数据可能就不是安全的类型。久而久之自己都可能忘记&lt;/p&gt;&#xA;&lt;p&gt;如果将某个类型对某种集合的操作封装起来，使用封装类操作集合，则导致有多少类型就要封装多少个集合操作类，代码超级冗余，且只能处理已有类型，不能处理新类型。导致只要一个新类要用集合，就要写一个封装类，不可取&lt;/p&gt;&#xA;&lt;p&gt;从根本上来说，泛型是为了实现Java面向对象环境下，类之间容纳未知类的安全操作能力，以解决上述问题带来的编码困境&lt;/p&gt;&#xA;&lt;p&gt;比如，在某个对象新建时就指定了泛型参数&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;该对象的方法只能使用指定类型，避免乱传参数&lt;/li&gt;&#xA;&lt;li&gt;编译时就会报错，避免运行时出问题&lt;/li&gt;&#xA;&lt;li&gt;取用元素也不必转换&lt;/li&gt;&#xA;&lt;li&gt;可以编写一套代码，适用所有类型&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;泛型方法&#34;&gt;&#xD;&#xA;  泛型方法&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b3%9b%e5%9e%8b%e6%96%b9%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;泛型方法可以定义在泛型类，也可以定义在普通类&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class A&amp;lt;T&amp;gt; {&#xD;&#xA;  public void method(T t) {&#xD;&#xA;    // do something...&#xD;&#xA;  }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;class A {&#xD;&#xA;  public &amp;lt;T&amp;gt; void method(T t) {&#xD;&#xA;    // do something...&#xD;&#xA;  }&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;定义泛型方法需要在泛型类前面指定泛型参数，从而在方法中使用具体泛型参数，或者在泛型方法前定义&lt;br&gt;&#xA;但使用时不需要手动指定具体类型，会根据调用进行类型推断&lt;br&gt;&#xA;如果是基本类型，会自动装箱为包装类&lt;/p&gt;&#xA;&lt;p&gt;由于静态类型方法不能访问类上定义的泛型参数，因为类上的泛型参数只能在对象实例化时指定，所以静态方法要使用泛型就必须定义成泛型方法&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class A {&#xD;&#xA;  public static &amp;lt;T&amp;gt; void method(T t) {&#xD;&#xA;    // do something...&#xD;&#xA;  }&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;类型擦除&#34;&gt;&#xD;&#xA;  类型擦除&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b1%bb%e5%9e%8b%e6%93%a6%e9%99%a4&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;List&amp;lt;String&amp;gt; strings = new ArrayList&amp;lt;&amp;gt;();&#xD;&#xA;List&amp;lt;Integer&amp;gt; ints = new ArrayList&amp;lt;&amp;gt;();&#xD;&#xA;Println(ints.getClass() == strings.getClass())&#xD;&#xA;# 结果为true。仿佛类型参数不存在&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是因为：&lt;/p&gt;</description>
    </item>
    <item>
      <title>序列化和反序列化</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/other/serailizable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/other/serailizable/</guid>
      <description>&lt;h1 id=&#34;序列化和反序列化&#34;&gt;&#xD;&#xA;  序列化和反序列化&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%ba%8f%e5%88%97%e5%8c%96%e5%92%8c%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;基本介绍&#34;&gt;&#xD;&#xA;  基本介绍&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;● 序列化&#xA;对象转换为字节流的过程&lt;br&gt;&#xA;转换为字节流后可以进行网络传输、持久化存储或者缓存&lt;br&gt;&#xA;Java提供java.io.Serailizable 接口支持序列化，只要实现这个接口，就可以将该类的对象进行序列化。&lt;/p&gt;&#xA;&lt;p&gt;● 反序列化&#xA;将字节流重新转换为对象的过程&lt;/p&gt;&#xA;&lt;p&gt;● 关键类和接口&#xA;ObjectOutputStream 用于序列化&lt;br&gt;&#xA;ObjectInputStream 用于反序列化&lt;br&gt;&#xA;类必须实现 Serializable 接口才能被序列化&lt;/p&gt;&#xA;&lt;p&gt;● transient 关键字&#xA;使用 transient 关键字可以指定让某些字段不被序列化&lt;/p&gt;&#xA;&lt;p&gt;● serialVersionUID&#xA;每个类都应该定义一个 serialVersionUID，用于反序列化时验证版本一致性&lt;br&gt;&#xA;如果不指定，Java会根据类定义自动生成UID，版本不匹配可能导致反序列化失败&lt;br&gt;&#xA;类似指纹&lt;/p&gt;&#xA;&lt;p&gt;● 性能&#xA;Java 默认的序列化机制可能比较慢，尤其对于大规模分布式系统，可能选择更高效的序列化框架，如 protobuf、kryo&lt;/p&gt;&#xA;&lt;p&gt;● 安全性&#xA;反序列化可能导致潜在安全风险，因为通过恶意构造的字节流可能导致加载不安全类或者执行不期望的代码。所以要警惕字节流来源，对不确定的字节流反序列化时进行输入验证，避免漏洞&lt;/p&gt;&#xA;&lt;h2 id=&#34;必须要实现-serializable-吗&#34;&gt;&#xD;&#xA;  必须要实现 Serializable 吗&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bf%85%e9%a1%bb%e8%a6%81%e5%ae%9e%e7%8e%b0-serializable-%e5%90%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;此前所述：类必须实现 Serializable 接口才能被序列化&lt;br&gt;&#xA;主要是指序列化使用Java原生序列化器（ObjectOutputStream， ObjectInputStream），其中存在是否实现该接口的判断&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;./images/java-serializable.png&#34; alt=&#34;java-serializable.png&#34; title=&#34;java-serializable.png&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;这里使得String、数组、枚举之外的类必须实现 Serializable，否则抛出异常&lt;br&gt;&#xA;但许多Spring实现的第三方带有数据存储和传输能力的组件接入类，一般自定义实现序列化和反序列化器，而且不继承 Java 原生序列化和反序列化器&lt;br&gt;&#xA;如 spring-data-redis：&lt;br&gt;&#xA;&lt;img src=&#34;./images/spring-data-redis-serializable.png&#34; alt=&#34;spring-data-redis-serializable.png&#34; title=&#34;spring-data-redis-serializable.png&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;apache kafka：&#xA;&lt;img src=&#34;./images/kafka-serializable.png&#34; alt=&#34;kafka-serializable.png&#34; title=&#34;kafka-serializable.png&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;所以许多情况下，可以看见一些类不需要实现 Serializable 接口一般也能正常使用功能。&lt;br&gt;&#xA;许多类或者规范，需要实现 Serializable 接口的主要原因是，防止系统中存在混杂使用 Java原生序列化器的情况&lt;/p&gt;</description>
    </item>
    <item>
      <title>异常体系</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/other/exception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/other/exception/</guid>
      <description>&lt;h1 id=&#34;异常体系&#34;&gt;&#xD;&#xA;  异常体系&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%82%e5%b8%b8%e4%bd%93%e7%b3%bb&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;throwable&#34;&gt;&#xD;&#xA;  Throwable&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#throwable&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;Throwable 类是所有异常和错误的超类&lt;br&gt;&#xA;两个直接子类为 Error 和 Exception，分别表示错误和异常&lt;/p&gt;&#xA;&lt;h2 id=&#34;error&#34;&gt;&#xD;&#xA;  Error&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#error&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;Error 指的是程序无法处理的错误，由 JVM 产生和抛出&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如 OutOfMemoryError、StackOverFlowError、ThreadDeath 等。Error 发生时，JVM 会选择终止线程&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;exception&#34;&gt;&#xD;&#xA;  Exception&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#exception&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;分为不检查异常（unchecked Exception）和检查异常（checked exception）&lt;br&gt;&#xA;也是运行时异常（RuntimeException）和非运行时异常&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Exception 是程序可以处理的异常，分为两大类，运行时异常和非运行时异常。程序中需要尽量去解决这些异常&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;运行时异常&#34;&gt;&#xD;&#xA;  运行时异常&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%90%e8%a1%8c%e6%97%b6%e5%bc%82%e5%b8%b8&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;指 RuntimeException 类及其子类，如 NullPointerException、IndexOutOfBoundsException 等。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;属于不检查异常，程序可以选择捕获处理，也可以不处理&#xA;例如：&lt;/li&gt;&#xA;&lt;li&gt;NullPointerException - 空指针引用异常&lt;/li&gt;&#xA;&lt;li&gt;ClassCastException - 类型强制转换异常&lt;/li&gt;&#xA;&lt;li&gt;IllegalArgumentException - 传递非法参数异常&lt;/li&gt;&#xA;&lt;li&gt;ArithmeticException - 算术运算异常&lt;/li&gt;&#xA;&lt;li&gt;ArrayStoreException - 向数组中存放与声明类型不兼容对象异常&lt;/li&gt;&#xA;&lt;li&gt;IndexOutOfBoundsException - 下标越界异常&lt;/li&gt;&#xA;&lt;li&gt;NegativeArraySizeException - 创建一个大小为负数的数组错误异常&lt;/li&gt;&#xA;&lt;li&gt;NumberFormatException - 数字格式异常&lt;/li&gt;&#xA;&lt;li&gt;SecurityException - 安全异常&lt;/li&gt;&#xA;&lt;li&gt;UnsupportedOperationException - 不支持的操作异常&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;非运行时异常&#34;&gt;&#xD;&#xA;  非运行时异常&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%9d%9e%e8%bf%90%e8%a1%8c%e6%97%b6%e5%bc%82%e5%b8%b8&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;指 Exception 类及其子类中 RuntimeException 类及其子类以外的类&lt;/p&gt;</description>
    </item>
    <item>
      <title>JDK|JRE|JVM</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/other/java-softwre-package/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/other/java-softwre-package/</guid>
      <description>&lt;h1 id=&#34;jdkjrejvm&#34;&gt;&#xD;&#xA;  JDK|JRE|JVM&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jdkjrejvm&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;jvm&#34;&gt;&#xD;&#xA;  JVM：&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jvm&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;Java 虚拟机，Java 程序能够跨平台运行的核心&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;所有的 Java 程序都会被编译为.class 的类文件，同代码在任何平台上编译字节码都相同&lt;/li&gt;&#xA;&lt;li&gt;.class 文件在虚拟机上运行，由虚拟机将字节码解释给本地系统执行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;jre&#34;&gt;&#xD;&#xA;  JRE：&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jre&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;Java 运行时环境，即 Java 程序必须在 JRE 上运行&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;包含 JVM 和 Java 核心类库&lt;/li&gt;&#xA;&lt;li&gt;JVM 不能直接执行 class，还需要 Java 核心类库来解释 class&lt;/li&gt;&#xA;&lt;li&gt;安装 jre 后有 bin 和 lib 两个文件夹，可简单理解为分别是 JVM 和 Lib&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;jdk&#34;&gt;&#xD;&#xA;  JDK：&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jdk&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;Java 开发工具包，包括 JRE、Java 工具、编译器和调试器组成&lt;br&gt;&#xA;自带工具：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;java：Java 运行工具，运行.class 或 jar 包&lt;/li&gt;&#xA;&lt;li&gt;javac: Java 编译工具，将 Java 源代码编译为字节码&lt;/li&gt;&#xA;&lt;li&gt;javap: Java 反编译工具，将 Java 字节码反汇编为源代码&lt;/li&gt;&#xA;&lt;li&gt;jmap：Java 内存映射工具，打印执行 Java 进程、核心文件或远程调试服务器的配置信息&lt;/li&gt;&#xA;&lt;li&gt;jps: Java 进程状态工具，显示目标系统上的 HotSpot JVM 的 Java 进程信息&lt;/li&gt;&#xA;&lt;li&gt;jinfo: Java 配置信息工具，用于打印指定 Java 进程、核心文件或远程调试服务器的配置信息&lt;/li&gt;&#xA;&lt;li&gt;jstack: Java 堆栈跟踪工具，用于打印 Java 进程、核心为念 u 哦远程调试服务器的 Java 现成的堆栈跟踪信息&lt;/li&gt;&#xA;&lt;li&gt;jvisualvm: Java 可视化 JVM 检测、故障分析工具。图形化界面提供指定虚拟机的 Java 应用程序的详细信息&lt;/li&gt;&#xA;&lt;li&gt;jconsole：图形化界面的检测工具，监测并显示 Java 平台上的应用程序的性能和资源占用等信息&lt;/li&gt;&#xA;&lt;li&gt;javadoc: Java 文档工具，根据源代码中的注释信息生成 HTML 格式的 API 帮助文档&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;三者的关系&#34;&gt;&#xD;&#xA;  三者的关系：&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%89%e8%80%85%e7%9a%84%e5%85%b3%e7%b3%bb&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;JDK 包含 JRE、JRE 包含 JVM&lt;/li&gt;&#xA;&lt;li&gt;JVM 不能单独搞定 class 的执行，解释 class 需要使用 JRE 中的 Java 核心类库 lib&lt;/li&gt;&#xA;&lt;li&gt;我们利用 JDK 开发 Java 源程序，通过 JDK 提供的 javac 编译程序将源程序编译成 Java 字节码，在 JVM 使用 JRE 的 lib 解释这些字节码，映射到 CPU 指令集或 OS 的系统调用&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
  </channel>
</rss>
