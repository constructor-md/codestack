<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>集合 on CodeStack</title>
    <link>https://constructor-md.github.io/codestack/docs/javase/collection/</link>
    <description>Recent content in 集合 on CodeStack</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <atom:link href="https://constructor-md.github.io/codestack/docs/javase/collection/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>HashMap</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/collection/hashmap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/collection/hashmap/</guid>
      <description>&lt;h1 id=&#34;hashmap&#34;&gt;&#xD;&#xA;  HashMap&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hashmap&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;数据结构&#34;&gt;&#xD;&#xA;  数据结构&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;JDK1.7之前，采用数组+链表&lt;/li&gt;&#xA;&lt;li&gt;JDK1.8之后，数组+链表+红黑树&#xA;当链表长度大于阈值或者红黑树的边界值，默认为8，且数组长度大于64时，该索引位置的数据改为红黑树存储&lt;br&gt;&#xA;如果数组长度不够64，则执行扩容。数组长度较小时换为红黑树，反而会降低效率。因为红黑树需要左旋右旋变色等操作来保持平衡&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;哈希表底层的hash算法&#34;&gt;&#xD;&#xA;  哈希表底层的hash算法&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%93%88%e5%b8%8c%e8%a1%a8%e5%ba%95%e5%b1%82%e7%9a%84hash%e7%ae%97%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;采用key的hashcode值，结合数组长度进行无符号右移，按位异或，按位与计算出索引&lt;br&gt;&#xA;还可以采用平方取中，取余数，伪随机数法。但位运算效率较高&lt;/p&gt;&#xA;&lt;h2 id=&#34;哈希表的存储和查询&#34;&gt;&#xD;&#xA;  哈希表的存储和查询&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%93%88%e5%b8%8c%e8%a1%a8%e7%9a%84%e5%ad%98%e5%82%a8%e5%92%8c%e6%9f%a5%e8%af%a2&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;存储时，根据hash算法计算出索引位置，找到指定位置存储&lt;br&gt;&#xA;以String为例，如果位置上已经有元素，则equals判断元素是否相等，相等则替换 &lt;br&gt;&#xA;不相等则在该位置形成链表，数据变为链表上的一个节点。以解决哈希碰撞问题&lt;/p&gt;&#xA;&lt;h2 id=&#34;哈希扩容&#34;&gt;&#xD;&#xA;  哈希扩容&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%93%88%e5%b8%8c%e6%89%a9%e5%ae%b9&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;当元素个数超过数组大小*负载因子（默认0.75）时进行扩容，扩大一倍&lt;br&gt;&#xA;扩容时需要rehash，但是方式比较巧妙，由于每次扩容都是翻倍，所以rehash相当于将原来的位置+旧容量就得到新的位置，没有再计算hash值&lt;br&gt;&#xA;但是新的键值进入仍进行了hash&lt;/p&gt;&#xA;&lt;h2 id=&#34;常见hash算法的原理&#34;&gt;&#xD;&#xA;  常见hash算法的原理：&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b8%b8%e8%a7%81hash%e7%ae%97%e6%b3%95%e7%9a%84%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;平方取中法：取关键字平方后中间几位作为散列地址&lt;/li&gt;&#xA;&lt;li&gt;直接寻址法：取关键字或关键字的某个线性函数值作为散列地址&lt;/li&gt;&#xA;&lt;li&gt;数字分析法：分析数据，如果是日期，发现年月日前几位数字大致相同，出现冲突几率大。你那月日的后几位月份和具体日期差别大，考虑用后面则冲突几率降低。即找规律用低碰撞的数据构造冲突几率低的散列地址&lt;/li&gt;&#xA;&lt;li&gt;折叠法：关键字分割成位数相同的几部分，最后一部分位数可以不同。取这几部分的叠加和（去除进位）作为散列地址&lt;/li&gt;&#xA;&lt;li&gt;随机数法：选择一个随机函数，取关键字的随机值作为散列地址，用于关键字长度不同的场合&lt;/li&gt;&#xA;&lt;li&gt;除留余数法：取关键字某个不大于散列表表长m的数p除后得到余数作为散列地址。p一般取素数或m，如果p选的不好容易产生随机值&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h1 id=&#34;处理冲突的方法&#34;&gt;&#xD;&#xA;  处理冲突的方法&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%a4%84%e7%90%86%e5%86%b2%e7%aa%81%e7%9a%84%e6%96%b9%e6%b3%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;开放寻址法&lt;/li&gt;&#xA;&lt;li&gt;拉链法&lt;/li&gt;&#xA;&lt;li&gt;再散列法&lt;/li&gt;&#xA;&lt;li&gt;公共溢出区&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>ConcurrentHashMap</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/collection/ConcurrentHashMap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/collection/ConcurrentHashMap/</guid>
      <description>&lt;h1 id=&#34;concurrenthashmap&#34;&gt;&#xD;&#xA;  ConcurrentHashMap&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#concurrenthashmap&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;是一个支持高并发更新和查询的哈希表，基于 HashMap 实现&lt;br&gt;&#xA;HashMap 本身没有对多线程情况进行线程安全的处理 &lt;br&gt;&#xA;如果改用 HashTable 或者 Collections.synchronizedMap，则会对整个容器进行加锁，通知时间的其他操作都会被阻塞&lt;br&gt;&#xA;但是 ConcurrentHashMap 不对整个容器加锁，而是对一小部分加锁，不影响其他位置的操作&lt;/p&gt;&#xA;&lt;h2 id=&#34;数据结构&#34;&gt;&#xD;&#xA;  数据结构&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;jdk18-以前segementreentranlock分段锁&#34;&gt;&#xD;&#xA;  JDK1.8 以前：Segement+ReentranLock（分段锁）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jdk18-%e4%bb%a5%e5%89%8dsegementreentranlock%e5%88%86%e6%ae%b5%e9%94%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;由 HashMap 实现的 Segment 组成，实际是多段的 HashMap。可以理解为 ConcurrentHashMap 中有一个 Segement 数组，每个 Segement 就是一个 HashMap。&lt;/li&gt;&#xA;&lt;li&gt;采用分段锁的思想。写操作时，通过只锁涉及到的 Segment 的方式，保证修改的线程安全，同时不影响其它部分的并发操作。&lt;/li&gt;&#xA;&lt;li&gt;Segment 内部进行扩容，和 HashMap 的扩容逻辑相似，先生成新数组，然后转移元素到新数组中。&lt;/li&gt;&#xA;&lt;li&gt;每个 Segment 单独扩容，互不干扰。是否需要扩容也是 Segment 内部单独判断，是否超过阈值&lt;/li&gt;&#xA;&lt;li&gt;默认创建 16 个 Segment，即默认最多允许并发 16 个不同的写&lt;/li&gt;&#xA;&lt;li&gt;并发度是Segment数量，比较固定&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;segment-实现的弊端&#34;&gt;&#xD;&#xA;  Segment 实现的弊端&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#segment-%e5%ae%9e%e7%8e%b0%e7%9a%84%e5%bc%8a%e7%ab%af&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;寻找元素需要两次 Hash&lt;/li&gt;&#xA;&lt;li&gt;提供了并发级别的默认设置，默认 16 个 Segment，无法根据实际场景动态调整，但是不一定适用于大部分场景，最好是让用户自己评估需要多少把锁&lt;/li&gt;&#xA;&lt;li&gt;存储成本比 HashMap 高，每个 Segment 最小容量为 2，默认并发级别 16，假如只需要存储 16 个元素，那么会建立一个 32 容量的 ConcurrentHashMap 来存&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;jdk18-以后nodesynchronizedcas&#34;&gt;&#xD;&#xA;  JDK1.8 以后：Node+Synchronized+CAS&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#jdk18-%e4%bb%a5%e5%90%8enodesynchronizedcas&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;采用 Node 数组+链表/红黑树的数据结构（与HashMap高度相似 Node也只是一个数据节点）&lt;/li&gt;&#xA;&lt;li&gt;当链表长度超过 8 且数组长度 ≥ 64 时，链表转换为红黑树，提升查询效率&lt;/li&gt;&#xA;&lt;li&gt;每次操作某个槽位，都以该槽位的第一个元素作为锁，通过 synchronized 加锁，其他节点内仍可并发。锁粒度降到最低&lt;/li&gt;&#xA;&lt;li&gt;依赖 JVM 对 synchronized 的轻量级锁优化，性能优于显式 ReentrantLock&lt;/li&gt;&#xA;&lt;li&gt;槽位为空时（无锁写入），通过 CAS 原子操作直接写入数据&lt;/li&gt;&#xA;&lt;li&gt;移除 Segment，降低锁粒度、减少内存开销和哈希计算次数&lt;/li&gt;&#xA;&lt;li&gt;无锁读：通过 volatile 修饰的 Node 数组保证可见性，直接读取头节点。若为链表，遍历链表；若为红黑树，通过树结构查找&lt;/li&gt;&#xA;&lt;li&gt;并发度是理论上限为数组长度，随着数据变化动态调整&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;put-操作流程&#34;&gt;&#xD;&#xA;  put 操作流程&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#put-%e6%93%8d%e4%bd%9c%e6%b5%81%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;数组是否初始化，没有则初始化数组&lt;/li&gt;&#xA;&lt;li&gt;插入位置是否为空，是则使用 CAS 写入，size+1 并检查是否需要扩容&lt;/li&gt;&#xA;&lt;li&gt;是否正在扩容，是则协助扩容，扩容完毕后再从头判断起&lt;/li&gt;&#xA;&lt;li&gt;当前节点加锁，插入数据，解锁，szie+1 并检查是否需要扩容&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>CopyOnWriteArrayList</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/collection/CopyOnWriteArrayList/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/collection/CopyOnWriteArrayList/</guid>
      <description>&lt;h1 id=&#34;copyonwritearraylist&#34;&gt;&#xD;&#xA;  CopyOnWriteArrayList&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#copyonwritearraylist&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;数据结构&#34;&gt;&#xD;&#xA;  数据结构&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;相当于一个线程安全的ArrayList，内部存储仍使用数组实现&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public class CopyOnWriteArrayList&amp;lt;E&amp;gt; implements List&amp;lt;E&amp;gt; {&#xD;&#xA;    private transient volatile Object[] array;  // 使用volatile保证可见性&#xD;&#xA;    final transient ReentrantLock lock = new ReentrantLock();  // 写锁&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;线程安全机制&#34;&gt;&#xD;&#xA;  线程安全机制&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e6%9c%ba%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;线程安全通过ReentrantLock实现，允许多线程并发读取，但只允许一个线程写入&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;内部维护final transient 的ReentrantLock对象作为全局锁&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;transient阻止默认序列化&lt;/li&gt;&#xA;&lt;li&gt;volatile保证可见性和有序性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;写操作首先进行加锁，结束后解锁。保证并发写的线程安全。&lt;/li&gt;&#xA;&lt;li&gt;添加新元素时，复制一个新数组，在新数组上添加。而此时并发的读操作则在原数组上进行。通过复制元素读写分离，来保证读写并发的性能。&lt;/li&gt;&#xA;&lt;li&gt;读到的可能不是最新的数据，不适合实时性要求很高的场景。&lt;/li&gt;&#xA;&lt;li&gt;采用写时复制思想（Copy on Write），适合读多写少的并发场景&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;局限性&#34;&gt;&#xD;&#xA;  局限性&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%b1%80%e9%99%90%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;内存占用高：每次写操作都创建新数组，可能导致频繁 GC。&lt;br&gt;&#xA;（需要注意大数组情况性能很差）&lt;/li&gt;&#xA;&lt;li&gt;写操作性能差：涉及数组复制，写操作时间复杂度为 O (n)。&lt;br&gt;&#xA;（若需要强一致性且写操作较多，使用 Collections.synchronizedList）&lt;/li&gt;&#xA;&lt;li&gt;弱一致性：读操作可能看不到最新数据，不适合实时性要求高的场景&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>ArrayList|LinkedList</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/collection/ArrayList-LinkedList/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/collection/ArrayList-LinkedList/</guid>
      <description>&lt;h1 id=&#34;arraylist-和-linkedlist&#34;&gt;&#xD;&#xA;  ArrayList 和 LinkedList&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#arraylist-%e5%92%8c-linkedlist&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;arraylist&#34;&gt;&#xD;&#xA;  ArrayList&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#arraylist&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;ArrayList是一个可扩容的，底层用数组实现的，非线程安全的集合类&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;实现RamdonAsceess接口，无实质内容，声明性质，表明ArrayList支持随机访问&lt;/li&gt;&#xA;&lt;li&gt;实现Cloneable，声明需要复写clone()接口，且可以支持克隆&lt;/li&gt;&#xA;&lt;li&gt;实现Serializable，声明可序列化&lt;/li&gt;&#xA;&lt;li&gt;初始容量10，最大容量Integer.MAX_VALUE - 8。&lt;/li&gt;&#xA;&lt;li&gt;出现可能越界的操作时检查是否需要扩容，每次扩容为原来的1.5倍&lt;/li&gt;&#xA;&lt;li&gt;内部维护元素的数组使用transient修饰，阻止默认的序列化和反序列化。原因是大多情况下数组不是满的，默认的序列化会把空的部分也序列化进去。ArrayList自己实现了合适的序列化和反序列化方法&lt;/li&gt;&#xA;&lt;li&gt;内部维护一个自增变量，记录修改的次数，添加、删除、扩容都会使操作数++，相当于版本号。作用是在迭代器遍历过程中检查数组是否被修改，迭代器遍历过程中是禁止修改的。只要版本号不对，就会抛出异常，这就是fail-fast&lt;/li&gt;&#xA;&lt;li&gt;扩容方法是新建一个更大容量的数组，然后将元素复制过去。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;linkedlist&#34;&gt;&#xD;&#xA;  LinkedList&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#linkedlist&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;LinkedList一个内部用双向链表实现的List，同时实现了Deque接口，可以当作队列或者栈来使用。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;实现Cloneable和Serializable，可以被克隆也可以被序列化&lt;/li&gt;&#xA;&lt;li&gt;克隆时和ArrayList一样是浅拷贝&lt;/li&gt;&#xA;&lt;li&gt;实现了Deque接口，支持两端的元素插入和删除&lt;/li&gt;&#xA;&lt;li&gt;继承AbstractSequential类，声明支持按次序访问&lt;/li&gt;&#xA;&lt;li&gt;内部维护头节点和尾节点，以及元素个数&lt;/li&gt;&#xA;&lt;li&gt;内部静态类Node包含元素、前驱和后继节点&lt;/li&gt;&#xA;&lt;li&gt;支持从头部、尾部、任意位置添加、删除元素&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;对比&#34;&gt;&#xD;&#xA;  对比&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%b9%e6%af%94&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;ArrayList是数组，LinkedList是链表&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基于数组的ArrayList，底层连续存储&lt;br&gt;&#xA;知道第一个元素的位置就可以通过索引快速访问到后续元素，随机查找速度O(1)&lt;br&gt;&#xA;删除数据和插入数据可能需要重排数据中的所有数据或者是更新索引，开销大O(n)&lt;br&gt;&#xA;ArrayList需要扩容，每次扩容会备用一些没被使用的数组空间&lt;/li&gt;&#xA;&lt;li&gt;基于链表的LinkedList，底层可以离散存储&lt;br&gt;&#xA;每个节点存储数据、前一个元素引用、后一个元素引用&#xA;增删时不需要像数组那样重新计算大小或者更新索引，增删速度O(1)&lt;br&gt;&#xA;查询需要逐个元素直到找到，效率低O(n)&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>HashSet</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/collection/hashset/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/collection/hashset/</guid>
      <description>&lt;h1 id=&#34;hashset&#34;&gt;&#xD;&#xA;  HashSet&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#hashset&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;数据结构&#34;&gt;&#xD;&#xA;  数据结构&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;内部维护一个HashMap，new HashSet实际是new HashMap&lt;/li&gt;&#xA;&lt;li&gt;添加元素时，查找HashMap是否有元素，没有存放则直接添加，存放了则调用equals比较&lt;/li&gt;&#xA;&lt;li&gt;如果相同则放弃添加，不同则添加到最后&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;注意点&#34;&gt;&#xD;&#xA;  注意点&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b3%a8%e6%84%8f%e7%82%b9&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;只能存放一个Null值&lt;/li&gt;&#xA;&lt;li&gt;线程不安全&lt;/li&gt;&#xA;&lt;li&gt;不能有重复元素&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>迭代器</title>
      <link>https://constructor-md.github.io/codestack/docs/javase/collection/Iterator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javase/collection/Iterator/</guid>
      <description>&lt;h1 id=&#34;迭代器&#34;&gt;&#xD;&#xA;  迭代器&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%ad%e4%bb%a3%e5%99%a8&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;集合类的顶层接口Collection继承了Iterable接口&lt;br&gt;&#xA;Iterable接口有一个方法&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 返回一个Iterator对象&#xD;&#xA;Iterator&amp;lt;T&amp;gt; iterator();&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Iterator接口，有三个方法：hashNext、next、remove&lt;br&gt;&#xA;各个集合中实现了Iterator内部类，实现了这几个方法&lt;/p&gt;&#xA;&lt;p&gt;使用时，首先获取集合对象中的Iterator对象，然后while循环判断hashNext，然后用Next获取数据&lt;br&gt;&#xA;迭代过程中可以使用迭代器的remove方法删除元素，不能使用集合的remove方法删除元素&lt;br&gt;&#xA;原因是迭代器会更新modCount和expectedModCount，使得判断可以通过，不用抛出异常&lt;br&gt;&#xA;这在单线程下没问题，在多线程下不安全&lt;/p&gt;&#xA;&lt;p&gt;增强for循环：&lt;br&gt;&#xA;底层使用Iterator实现，只能遍历集合或数组&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
