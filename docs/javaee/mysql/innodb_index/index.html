<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
  InnoDB 索引
  #


  表数据结构
  #


  索引组织表
  #


每张表必然有主键
没有显示建立主键，使用第一个非空唯一索引作为主键
没有非空唯一索引，存储引擎自动创建一个6字节大小的指针row_id作为主键


  逻辑存储架构
  #


所有数据存放在表空间中，表空间由段、区、页组成
段有数据段、索引段、回滚段等。概念上数据就是索引，数据段就是B&#43;树的叶子节点，索引段是B&#43;树的非叶子节点
区是连续页组成的空间，每个区大小固定1MB。页大小16KB，每区固定64个连续页
页是存储引擎数据管理最小单位，每次读写磁盘最小一页，即16KB
行：Innodb是面向列的存储引擎，数据按行存放，每页最多存放7992行记录


  B&#43;树
  #


B&#43;树由二叉查找树和二叉平衡树发展而来，但B&#43;树是多叉树，减小树高度
B&#43;树的记录数据都在叶子节点上，非叶子节点存放的数据是索引值
叶子节点之间以指针双向连接，形成链表，方便范围查找
B&#43;树索引分成聚簇索引和二级索引，区别在于叶子节点是否存放所有行信息
B&#43;树是平衡树，所有叶子节点在同一层，查询稳定性高


  优势
  #


树高度低，减少磁盘IO

每个非叶子节点存放多个范围的下一级节点的指针，而不只是普通二叉查找树的两个，靠这一点减少树高度
在索引树上查找时，先从磁盘读取根节点，每找到下一级索引就要从磁盘读取索引页得到数据继续判断，索引树高度低，使得读取一次磁盘筛选数据效率高，大幅减少磁盘IO次数


叶子链表范围查询高效
叶子节点形成索引值的顺序链表，支持顺序遍历，便于范围查询
查询稳定性

B&#43;树使用分裂&#43;合并技术保持结构稳定性。因为插入数据导致一个节点达到容量上限，就会分裂成两个节点；因为删除数据导致两个节点太小，空间利用率低，就会合并成一个节点。这也是它的自平衡策略的一部分，同层横向扩展
B&#43;树高度变化少，一般最高四层就能存储千万以上数据
只有叶子节点才有具体数据，插入和删除对树结构影响小




  对比B树
  #

B树非叶子节点存放数据，使得一次读取磁盘筛选数据效率低，且树高度变高，磁盘IO负担大

  聚簇索引/聚集索引/主键索引
  #


按主键构造B&#43;树
叶子节点存放的行记录信息包含所有列
通过聚集索引查找数据，可以直接在叶子节点得到全部数据


  二级索引
  #


根据索引列值构造B&#43;树
叶子节点有索引值、该索引值对应的主键
通过二级索引查找数据时，会根据索引找到对应的叶子节点，再根据叶子节点上的主键值，回表到主键索引获取更多列数据


  索引失效情况枚举
  #


  隐式类型转换导致索引失效
  #

原因：查询条件和主键类型不一致，转换失败时无法使用索引，导致全表扫描
-- 索引`id`为INT类型
SELECT * FROM t WHERE id = &#39;100&#39;; -- 字符串转INT，索引有效（依赖优化器）
SELECT * FROM t WHERE id = &#39;100ABC&#39;; -- 转换失败，全表扫描

  使用函数或计算索引列
  #

原因：索引树结构逻辑为大小排列，函数计算后无法找到对应的节点">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="https://constructor-md.github.io/codestack/docs/javaee/mysql/innodb_index/">
  <meta property="og:site_name" content="CodeStack">
  <meta property="og:title" content="InnoDB 索引">
  <meta property="og:description" content="InnoDB 索引#表数据结构#索引组织表#每张表必然有主键 没有显示建立主键，使用第一个非空唯一索引作为主键 没有非空唯一索引，存储引擎自动创建一个6字节大小的指针row_id作为主键 逻辑存储架构#所有数据存放在表空间中，表空间由段、区、页组成 段有数据段、索引段、回滚段等。概念上数据就是索引，数据段就是B&#43;树的叶子节点，索引段是B&#43;树的非叶子节点 区是连续页组成的空间，每个区大小固定1MB。页大小16KB，每区固定64个连续页 页是存储引擎数据管理最小单位，每次读写磁盘最小一页，即16KB 行：Innodb是面向列的存储引擎，数据按行存放，每页最多存放7992行记录 B&#43;树#B&#43;树由二叉查找树和二叉平衡树发展而来，但B&#43;树是多叉树，减小树高度 B&#43;树的记录数据都在叶子节点上，非叶子节点存放的数据是索引值 叶子节点之间以指针双向连接，形成链表，方便范围查找 B&#43;树索引分成聚簇索引和二级索引，区别在于叶子节点是否存放所有行信息 B&#43;树是平衡树，所有叶子节点在同一层，查询稳定性高 优势#树高度低，减少磁盘IO 每个非叶子节点存放多个范围的下一级节点的指针，而不只是普通二叉查找树的两个，靠这一点减少树高度 在索引树上查找时，先从磁盘读取根节点，每找到下一级索引就要从磁盘读取索引页得到数据继续判断，索引树高度低，使得读取一次磁盘筛选数据效率高，大幅减少磁盘IO次数 叶子链表范围查询高效 叶子节点形成索引值的顺序链表，支持顺序遍历，便于范围查询 查询稳定性 B&#43;树使用分裂&#43;合并技术保持结构稳定性。因为插入数据导致一个节点达到容量上限，就会分裂成两个节点；因为删除数据导致两个节点太小，空间利用率低，就会合并成一个节点。这也是它的自平衡策略的一部分，同层横向扩展 B&#43;树高度变化少，一般最高四层就能存储千万以上数据 只有叶子节点才有具体数据，插入和删除对树结构影响小 对比B树#B树非叶子节点存放数据，使得一次读取磁盘筛选数据效率低，且树高度变高，磁盘IO负担大
聚簇索引/聚集索引/主键索引#按主键构造B&#43;树 叶子节点存放的行记录信息包含所有列 通过聚集索引查找数据，可以直接在叶子节点得到全部数据 二级索引#根据索引列值构造B&#43;树 叶子节点有索引值、该索引值对应的主键 通过二级索引查找数据时，会根据索引找到对应的叶子节点，再根据叶子节点上的主键值，回表到主键索引获取更多列数据 索引失效情况枚举#隐式类型转换导致索引失效#原因：查询条件和主键类型不一致，转换失败时无法使用索引，导致全表扫描
-- 索引`id`为INT类型SELECT * FROM t WHERE id = &#39;100&#39;; -- 字符串转INT，索引有效（依赖优化器）SELECT * FROM t WHERE id = &#39;100ABC&#39;; -- 转换失败，全表扫描 使用函数或计算索引列#原因：索引树结构逻辑为大小排列，函数计算后无法找到对应的节点">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="docs">
    <meta property="article:modified_time" content="2025-05-03T21:01:31+08:00">
<title>InnoDB 索引 | CodeStack</title>
<link rel="icon" href="/codestack/favicon.png" >
<link rel="manifest" href="/codestack/manifest.json">
<link rel="canonical" href="https://constructor-md.github.io/codestack/docs/javaee/mysql/innodb_index/">
<link rel="stylesheet" href="/codestack/book.min.a7616cf2799b58bddffce9438e31fdbfc6393687cfc0950a4a17cd1cce7e35f6.css" integrity="sha256-p2Fs8nmbWL3f/OlDjjH9v8Y5NofPwJUKShfNHM5&#43;NfY=" crossorigin="anonymous">
  <script defer src="/codestack/fuse.min.js"></script>
  <script defer src="/codestack/en.search.min.0a3e9fa9d1dc24283183df34a17b0ab51a17e13fb6e7384ca0a9837ec234085c.js" integrity="sha256-Cj6fqdHcJCgxg980oXsKtRoX4T&#43;25zhMoKmDfsI0CFw=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/codestack/"><span>CodeStack</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>















  
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/basic/" class="">计算机基础</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/basic/net/" class="">计算机网络</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/basic/net/transport/" class="">传输层</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/basic/net/transport/tcp/" class="">TCP</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/basic/net/application/" class="">应用层</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/basic/net/application/http/" class="">HTTP</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/javaee/" class="">JavaEE</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/javaee/spring/" class="">Spring</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/javaee/spring/ioc/" class="">依赖注入|控制反转|自动装配</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/javaee/spring/aop/" class="">AOP</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/javaee/spring/transaction/" class="">Spring事务</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/javaee/spring/bean-liftcycle-and-extension/" class="">Bean 生命周期与 SpringBoot 扩展点</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/javaee/spring/three-party-jar-import/" class="">SpringBoot 引入第三方 Jar 包</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/javaee/spring/springmvc-http/indxe/" class="">SpringMVC 接收 HTTP</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/javaee/spring/springboot-spring/" class="">SpringBoot 相比 Spring</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/javaee/mysql/" class="">MySQL</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/javaee/mysql/innodb_index/" class="active">InnoDB 索引</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/javaee/mysql/innodb_transaction/" class="">InnoDB 事务</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/javaee/mysql/innodb_lock/" class="">InnoDB 锁机制</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/javaee/mysql/sql-execution/" class="">SQL执行过程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/javaee/mysql/logfile/" class="">日志文件及作用</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/javaee/mysql/explain/" class="">Explain参数解释和查询成本分析</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/javaee/mysql/tree-high/" class="">索引树高度计算</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/javaee/redis/" class="">Redis</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/javase/" class="">JavaSE</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/javase/exception/" class="">异常体系</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/javase/java-softwre-package/" class="">JDK|JRE|JVM</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/project/" class="">项目设计</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/project/server-runtime-excption/" class="">雪崩|限流|熔断|降级</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/project/distributed-lock/" class="">分布式锁实现</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/project/design-theory/" class="">一些设计理论</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/anomaly-investigation/" class="">在线异常排查</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/deploy/" class="">部署</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/deploy/ubuntu/" class="">Ubuntu</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/deploy/mysql/" class="">MySQL</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/deploy/redis/" class="">Redis</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/deploy/elasticsearch/" class="">ElasticSearch</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/codestack/docs/deploy/minio/" class="">MinIO</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>














</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/codestack/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>InnoDB 索引</h3>

  <label for="toc-control">
    
    <img src="/codestack/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#表数据结构">表数据结构</a>
      <ul>
        <li><a href="#索引组织表">索引组织表</a></li>
        <li><a href="#逻辑存储架构">逻辑存储架构</a></li>
        <li><a href="#b树">B+树</a></li>
        <li><a href="#聚簇索引聚集索引主键索引">聚簇索引/聚集索引/主键索引</a></li>
        <li><a href="#二级索引">二级索引</a></li>
      </ul>
    </li>
    <li><a href="#索引失效情况枚举">索引失效情况枚举</a>
      <ul>
        <li><a href="#隐式类型转换导致索引失效">隐式类型转换导致索引失效</a></li>
        <li><a href="#使用函数或计算索引列">使用函数或计算索引列</a></li>
        <li><a href="#not-in-或-not-exists">NOT IN 或 NOT EXISTS</a></li>
        <li><a href="#不等于操作符--">不等于操作符 !=, &lt;&gt;</a></li>
        <li><a href="#查询条件包含is-nullis-not-null可能失效">查询条件包含IS NULL/IS NOT NULL(可能失效)</a></li>
        <li><a href="#or查询索引失效">OR查询索引失效</a></li>
        <li><a href="#前导模糊查询-like-xxx">前导模糊查询 Like &lsquo;%xxx&rsquo;</a></li>
        <li><a href="#索引选择性过低">索引选择性过低</a></li>
        <li><a href="#联合索引未遵循特性导致失效">联合索引未遵循特性导致失效</a></li>
        <li><a href="#字符集不同联表join时索引失效">字符集不同，联表Join时索引失效</a></li>
      </ul>
    </li>
    <li><a href="#索引设计原则">索引设计原则</a>
      <ul>
        <li><a href="#查多写少列建立索引">查多写少列建立索引</a></li>
        <li><a href="#索引列应具备高选择性">索引列应具备高选择性</a></li>
        <li><a href="#组合索引优化">组合索引优化</a></li>
      </ul>
    </li>
    <li><a href="#查询索引优化方法">查询索引优化方法</a>
      <ul>
        <li><a href="#利用覆盖索引">利用覆盖索引</a></li>
        <li><a href="#开启和倾向索引下推">开启和倾向索引下推</a></li>
      </ul>
    </li>
    <li><a href="#查询优化方法">查询优化方法</a>
      <ul>
        <li><a href="#查询具体列而不是-">查询具体列，而不是 *</a></li>
        <li><a href="#利用索引避免失效">利用索引，避免失效</a></li>
        <li><a href="#注意操作符">注意操作符</a></li>
        <li><a href="#关注查询成本筛选效率">关注查询成本、筛选效率</a></li>
        <li><a href="#对于联合索引利用其特性">对于联合索引，利用其特性</a></li>
        <li><a href="#深分页优化">深分页优化</a></li>
        <li><a href="#避免大表联小表和无意义联表">避免大表联小表和无意义联表</a></li>
        <li><a href="#业务代码层优化">业务代码层优化</a></li>
        <li><a href="#优化的认知">优化的认知</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><h1 id="innodb-索引">
  InnoDB 索引
  <a class="anchor" href="#innodb-%e7%b4%a2%e5%bc%95">#</a>
</h1>
<h2 id="表数据结构">
  表数据结构
  <a class="anchor" href="#%e8%a1%a8%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84">#</a>
</h2>
<h3 id="索引组织表">
  索引组织表
  <a class="anchor" href="#%e7%b4%a2%e5%bc%95%e7%bb%84%e7%bb%87%e8%a1%a8">#</a>
</h3>
<ol>
<li>每张表必然有主键</li>
<li>没有显示建立主键，使用第一个非空唯一索引作为主键</li>
<li>没有非空唯一索引，存储引擎自动创建一个6字节大小的指针row_id作为主键</li>
</ol>
<h3 id="逻辑存储架构">
  逻辑存储架构
  <a class="anchor" href="#%e9%80%bb%e8%be%91%e5%ad%98%e5%82%a8%e6%9e%b6%e6%9e%84">#</a>
</h3>
<ol>
<li>所有数据存放在表空间中，表空间由段、区、页组成</li>
<li>段有数据段、索引段、回滚段等。概念上数据就是索引，数据段就是B+树的叶子节点，索引段是B+树的非叶子节点</li>
<li>区是连续页组成的空间，每个区大小固定1MB。页大小16KB，每区固定64个连续页</li>
<li>页是存储引擎数据管理最小单位，每次读写磁盘最小一页，即16KB</li>
<li>行：Innodb是面向列的存储引擎，数据按行存放，每页最多存放7992行记录</li>
</ol>
<h3 id="b树">
  B+树
  <a class="anchor" href="#b%e6%a0%91">#</a>
</h3>
<ol>
<li>B+树由二叉查找树和二叉平衡树发展而来，但B+树是多叉树，减小树高度</li>
<li>B+树的记录数据都在叶子节点上，非叶子节点存放的数据是索引值</li>
<li>叶子节点之间以指针双向连接，形成链表，方便范围查找</li>
<li>B+树索引分成聚簇索引和二级索引，区别在于叶子节点是否存放所有行信息</li>
<li>B+树是平衡树，所有叶子节点在同一层，查询稳定性高</li>
</ol>
<h4 id="优势">
  优势
  <a class="anchor" href="#%e4%bc%98%e5%8a%bf">#</a>
</h4>
<ol>
<li>树高度低，减少磁盘IO
<ol>
<li>每个非叶子节点存放多个范围的下一级节点的指针，而不只是普通二叉查找树的两个，靠这一点减少树高度</li>
<li>在索引树上查找时，先从磁盘读取根节点，每找到下一级索引就要从磁盘读取索引页得到数据继续判断，索引树高度低，使得读取一次磁盘筛选数据效率高，大幅减少磁盘IO次数</li>
</ol>
</li>
<li>叶子链表范围查询高效
叶子节点形成索引值的顺序链表，支持顺序遍历，便于范围查询</li>
<li>查询稳定性
<ol>
<li>B+树使用分裂+合并技术保持结构稳定性。因为插入数据导致一个节点达到容量上限，就会分裂成两个节点；因为删除数据导致两个节点太小，空间利用率低，就会合并成一个节点。这也是它的自平衡策略的一部分，同层横向扩展</li>
<li>B+树高度变化少，一般最高四层就能存储千万以上数据</li>
<li>只有叶子节点才有具体数据，插入和删除对树结构影响小</li>
</ol>
</li>
</ol>
<h4 id="对比b树">
  对比B树
  <a class="anchor" href="#%e5%af%b9%e6%af%94b%e6%a0%91">#</a>
</h4>
<p>B树非叶子节点存放数据，使得一次读取磁盘筛选数据效率低，且树高度变高，磁盘IO负担大</p>
<h3 id="聚簇索引聚集索引主键索引">
  聚簇索引/聚集索引/主键索引
  <a class="anchor" href="#%e8%81%9a%e7%b0%87%e7%b4%a2%e5%bc%95%e8%81%9a%e9%9b%86%e7%b4%a2%e5%bc%95%e4%b8%bb%e9%94%ae%e7%b4%a2%e5%bc%95">#</a>
</h3>
<ol>
<li>按主键构造B+树</li>
<li>叶子节点存放的行记录信息包含所有列</li>
<li>通过聚集索引查找数据，可以直接在叶子节点得到全部数据</li>
</ol>
<h3 id="二级索引">
  二级索引
  <a class="anchor" href="#%e4%ba%8c%e7%ba%a7%e7%b4%a2%e5%bc%95">#</a>
</h3>
<ol>
<li>根据索引列值构造B+树</li>
<li>叶子节点有索引值、该索引值对应的主键</li>
<li>通过二级索引查找数据时，会根据索引找到对应的叶子节点，再根据叶子节点上的主键值，回表到主键索引获取更多列数据</li>
</ol>
<h2 id="索引失效情况枚举">
  索引失效情况枚举
  <a class="anchor" href="#%e7%b4%a2%e5%bc%95%e5%a4%b1%e6%95%88%e6%83%85%e5%86%b5%e6%9e%9a%e4%b8%be">#</a>
</h2>
<h3 id="隐式类型转换导致索引失效">
  隐式类型转换导致索引失效
  <a class="anchor" href="#%e9%9a%90%e5%bc%8f%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2%e5%af%bc%e8%87%b4%e7%b4%a2%e5%bc%95%e5%a4%b1%e6%95%88">#</a>
</h3>
<p>原因：查询条件和主键类型不一致，转换失败时无法使用索引，导致全表扫描</p>
<pre tabindex="0"><code>-- 索引`id`为INT类型
SELECT * FROM t WHERE id = &#39;100&#39;; -- 字符串转INT，索引有效（依赖优化器）
SELECT * FROM t WHERE id = &#39;100ABC&#39;; -- 转换失败，全表扫描
</code></pre><h3 id="使用函数或计算索引列">
  使用函数或计算索引列
  <a class="anchor" href="#%e4%bd%bf%e7%94%a8%e5%87%bd%e6%95%b0%e6%88%96%e8%ae%a1%e7%ae%97%e7%b4%a2%e5%bc%95%e5%88%97">#</a>
</h3>
<p>原因：索引树结构逻辑为大小排列，函数计算后无法找到对应的节点</p>
<pre tabindex="0"><code># 取绝对值
SELECT * FROM t WHERE ABS(id) = 100; -- 失效
</code></pre><h3 id="not-in-或-not-exists">
  NOT IN 或 NOT EXISTS
  <a class="anchor" href="#not-in-%e6%88%96-not-exists">#</a>
</h3>
<p>原因：索引树结构逻辑为大小排列，not in 查询将遍历所有数据来判断是否not，无法通过比较确定位置。否定查询导致全表扫描</p>
<pre tabindex="0"><code>SELECT * FROM t WHERE id NOT IN (1,2,3); -- 失效（全表扫描）
</code></pre><h3 id="不等于操作符--">
  不等于操作符 !=, &lt;&gt;
  <a class="anchor" href="#%e4%b8%8d%e7%ad%89%e4%ba%8e%e6%93%8d%e4%bd%9c%e7%ac%a6--">#</a>
</h3>
<p>原因：同上</p>
<pre tabindex="0"><code>SELECT * FROM t WHERE a != 5; -- 全表扫描
SELECT * FROM t WHERE a &lt;&gt; 5; -- 同上
</code></pre><h3 id="查询条件包含is-nullis-not-null可能失效">
  查询条件包含IS NULL/IS NOT NULL(可能失效)
  <a class="anchor" href="#%e6%9f%a5%e8%af%a2%e6%9d%a1%e4%bb%b6%e5%8c%85%e5%90%abis-nullis-not-null%e5%8f%af%e8%83%bd%e5%a4%b1%e6%95%88">#</a>
</h3>
<p>原因：查询成本导致索引失效，如果IS NULL/IS NOT NULL过滤得到大量的数据，将会导致大量的查询和结果。失效原因并不是Null，因为innodb规定null值是最小的，数据节点会在B+树的最左边</p>
<pre tabindex="0"><code>SELECT * FROM t WHERE id NOT IN (1, 2, 3); -- 可能失效
SELECT * FROM t WHERE NOT EXISTS (SELECT 1 FROM t2 WHERE t.id = t2.id); -- 同上
</code></pre><h3 id="or查询索引失效">
  OR查询索引失效
  <a class="anchor" href="#or%e6%9f%a5%e8%af%a2%e7%b4%a2%e5%bc%95%e5%a4%b1%e6%95%88">#</a>
</h3>
<p>原因：OR 条件对单一索引表示可取可不取，含义模糊导致索引失效，除非优化器选择Index merge<br>
应该考虑使用union all 替换 or 条件</p>
<pre tabindex="0"><code>-- 索引列`a`和`b`各自有独立索引
SELECT * FROM t WHERE a = 1 OR b = 2; -- 可能触发全表扫描（除非优化器选择Index Merge）
</code></pre><h3 id="前导模糊查询-like-xxx">
  前导模糊查询 Like &lsquo;%xxx&rsquo;
  <a class="anchor" href="#%e5%89%8d%e5%af%bc%e6%a8%a1%e7%b3%8a%e6%9f%a5%e8%af%a2-like-xxx">#</a>
</h3>
<p>原因：非末尾的模糊通配，都无法在索引树上判断接下来应该走左子叶还是右子叶</p>
<pre tabindex="0"><code>SELECT * FROM t WHERE name LIKE &#39;%John&#39;; -- 失效
SELECT * FROM t WHERE name LIKE &#39;John%&#39;; -- 有效
</code></pre><h3 id="索引选择性过低">
  索引选择性过低
  <a class="anchor" href="#%e7%b4%a2%e5%bc%95%e9%80%89%e6%8b%a9%e6%80%a7%e8%bf%87%e4%bd%8e">#</a>
</h3>
<p>原因：索引条件筛选数据能力低下，同样会遍历到很多数据，优化器可能会放弃索引</p>
<pre tabindex="0"><code>-- 索引列`gender`只有&#39;M&#39;/&#39;F&#39;两种值
SELECT * FROM t WHERE gender = &#39;M&#39;; -- 可能全表扫描
</code></pre><h3 id="联合索引未遵循特性导致失效">
  联合索引未遵循特性导致失效
  <a class="anchor" href="#%e8%81%94%e5%90%88%e7%b4%a2%e5%bc%95%e6%9c%aa%e9%81%b5%e5%be%aa%e7%89%b9%e6%80%a7%e5%af%bc%e8%87%b4%e5%a4%b1%e6%95%88">#</a>
</h3>
<p>原因：联合索引树先按左边列值进行排列，左列值相同再按右列值排列，以此类推。如果不遵循最左前缀，即无法确定左边列的定值，就会遍历左边列值，找到每一个左边定值再找右边列值，导致右边索引列加速作用实质上无效</p>
<pre tabindex="0"><code>-- 组合索引`(a, b, c)`
# 没有遵循最左前缀匹配原则
SELECT * FROM t WHERE b = 2 AND c = 3; -- 失效（缺少最左列`a`）

# 左列范围查询导致右列索引失效
# 联合索引要全部生效，范围查询就要放最右边
SELECT * FROM t WHERE a &gt; 1 AND b = 2; -- 仅`a`使用索引，`b`失效
SELECT * FROM t WHERE a = 1 AND b &gt; 2 AND c = 3; -- `a`和`b`有效，

# 跳过中间列，同样是不遵循最左前缀，也相当于中间列全表范围查询
SELECT * FROM t WHERE a = 1 AND c = 3; -- 仅`a`有效，`c`失效

# 排序字段和索引顺序不一致
-- 组合索引`(a, b)`
SELECT * FROM t WHERE a = 1 ORDER BY b DESC; -- 有效（利用索引排序）
SELECT * FROM t WHERE a = 1 ORDER BY b, c; -- 失效（`c`不在索引中）

-- 组合索引`(a, b)`
SELECT * FROM t ORDER BY b, a; -- 无法利用索引排序
</code></pre><h3 id="字符集不同联表join时索引失效">
  字符集不同，联表Join时索引失效
  <a class="anchor" href="#%e5%ad%97%e7%ac%a6%e9%9b%86%e4%b8%8d%e5%90%8c%e8%81%94%e8%a1%a8join%e6%97%b6%e7%b4%a2%e5%bc%95%e5%a4%b1%e6%95%88">#</a>
</h3>
<p>原因：字符集不同无法在索引树上匹配</p>
<pre tabindex="0"><code>-- 表A的`code`字段为utf8，表B的`code`为utf8mb4
SELECT * FROM A JOIN B ON A.code = B.code; -- 索引失效
</code></pre><h2 id="索引设计原则">
  索引设计原则
  <a class="anchor" href="#%e7%b4%a2%e5%bc%95%e8%ae%be%e8%ae%a1%e5%8e%9f%e5%88%99">#</a>
</h2>
<h3 id="查多写少列建立索引">
  查多写少列建立索引
  <a class="anchor" href="#%e6%9f%a5%e5%a4%9a%e5%86%99%e5%b0%91%e5%88%97%e5%bb%ba%e7%ab%8b%e7%b4%a2%e5%bc%95">#</a>
</h3>
<p>经常作为查询条件、联表字段(也是一种查)、排序字段和分组字段的条件，需要建立索引以提升这些查询的性能<br>
数据量大的索引字段，增删改的性能确实会低一些，但是如果大批量的增删改不会经常发生，倒也不太有所谓</p>
<h3 id="索引列应具备高选择性">
  索引列应具备高选择性
  <a class="anchor" href="#%e7%b4%a2%e5%bc%95%e5%88%97%e5%ba%94%e5%85%b7%e5%a4%87%e9%ab%98%e9%80%89%e6%8b%a9%e6%80%a7">#</a>
</h3>
<p>如果索引列基数，也就是索引列值的枚举少，那么使用该索引进行筛选时，筛选数据的效率低，甚至可能导致全表扫描</p>
<h3 id="组合索引优化">
  组合索引优化
  <a class="anchor" href="#%e7%bb%84%e5%90%88%e7%b4%a2%e5%bc%95%e4%bc%98%e5%8c%96">#</a>
</h3>
<ol>
<li>经常组合筛选和查询的列，可以考虑建立组合索引，以利用覆盖索引</li>
<li>索引列顺序应该根据查询的方式设计，避免索引失效。</li>
</ol>
<ul>
<li>经常等值查询的放在前面</li>
<li>经常模糊、范围、不确定查询的放在后面，留待索引下推处理</li>
</ul>
<h2 id="查询索引优化方法">
  查询索引优化方法
  <a class="anchor" href="#%e6%9f%a5%e8%af%a2%e7%b4%a2%e5%bc%95%e4%bc%98%e5%8c%96%e6%96%b9%e6%b3%95">#</a>
</h2>
<p>首先尽量使用索引，以及避免索引失效的操作<br>
其次还需要一些索引使用的技巧</p>
<h3 id="利用覆盖索引">
  利用覆盖索引
  <a class="anchor" href="#%e5%88%a9%e7%94%a8%e8%a6%86%e7%9b%96%e7%b4%a2%e5%bc%95">#</a>
</h3>
<p>原理：直接从索引树取得查询所需数据，避免回表操作
主要用于联合索引</p>
<pre tabindex="0"><code>-- 索引 (a, b)
SELECT a, b FROM table WHERE a = 1;   -- 有效（覆盖索引）
SELECT a, b, c FROM table WHERE a = 1; -- 失效（需回表查询c）
</code></pre><h3 id="开启和倾向索引下推">
  开启和倾向索引下推
  <a class="anchor" href="#%e5%bc%80%e5%90%af%e5%92%8c%e5%80%be%e5%90%91%e7%b4%a2%e5%bc%95%e4%b8%8b%e6%8e%a8">#</a>
</h3>
<p>索引下推 （index condition pushdown ）简称ICP
原理：MySQL服务层判断where条件可以交给存储引擎层筛选，于是下推交给存储引擎层筛选，筛选结果变少，于是减少回表次数<br>
只用于联合索引，作用是优化一部分联合索引查询的性能</p>
<pre tabindex="0"><code># 如 联合索引 (a, b)
select * from table where a &gt; 10 and b = 20

explain 显示 using index condition 表示使用了索引下推
</code></pre><ol>
<li>联合索引左侧范围查询后，右侧索引效果应该失效</li>
<li>未开启索引下推时，确实如此。。存储引擎层只根据a &gt; 10筛选索引树，回表出大量数据交给Server层，server层再筛选b = 20，显然回表次数很多</li>
<li>开启索引下推后，b = 20会被判断可以交给存储引擎层筛选，于是存储引擎层根据a &gt; 10筛选，满足的进一步根据b = 20筛选，筛选效率高，回表次数减少，返回给Server层的数据也更准确</li>
</ol>
<p>开启方法：</p>
<ol>
<li>MySQL5.6版本引入，且默认开启</li>
<li>命令开启：set optimizer_switch=&lsquo;index_condition_pushdown=on&rsquo;;</li>
</ol>
<p>注意点：</p>
<ol>
<li>仅用于二级索引，主要是联合索引</li>
</ol>
<h2 id="查询优化方法">
  查询优化方法
  <a class="anchor" href="#%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96%e6%96%b9%e6%b3%95">#</a>
</h2>
<p>综合前面的知识，可以得出以下查询优化的注意点<br>
这些注意点不是必须遵守的，需要根据业务需求、数据量、数据分布来分析查询成本，综合系统的可接受度来选择</p>
<h3 id="查询具体列而不是-">
  查询具体列，而不是 *
  <a class="anchor" href="#%e6%9f%a5%e8%af%a2%e5%85%b7%e4%bd%93%e5%88%97%e8%80%8c%e4%b8%8d%e6%98%af-">#</a>
</h3>
<p>查询时 select 列表仅包含所需数据，不需要的数据不要查，不要使用 * 查询<br>
好处</p>
<ol>
<li>减少查询结果数据量，传输快</li>
<li>无效数据查过来也是无效占用内存，增大垃圾回收负担</li>
<li>更有可能触发覆盖索引</li>
</ol>
<h3 id="利用索引避免失效">
  利用索引，避免失效
  <a class="anchor" href="#%e5%88%a9%e7%94%a8%e7%b4%a2%e5%bc%95%e9%81%bf%e5%85%8d%e5%a4%b1%e6%95%88">#</a>
</h3>
<p>筛选、排序、分组、联表等操作使用索引字段</p>
<ul>
<li>注意不要对索引字段进行函数计算</li>
<li>注意联表字段使用相同字符集</li>
<li>注意不要对索引使用隐式数据转换，传入数据应该是对应类型</li>
</ul>
<h3 id="注意操作符">
  注意操作符
  <a class="anchor" href="#%e6%b3%a8%e6%84%8f%e6%93%8d%e4%bd%9c%e7%ac%a6">#</a>
</h3>
<ul>
<li>对于需要 OR 条件的场景，使用Union查询替代</li>
<li>不要在索引上使用不等于!= &lt;&gt;查询，考虑在业务上避免</li>
<li>Like 模糊查询匹配应该放最后</li>
</ul>
<h3 id="关注查询成本筛选效率">
  关注查询成本、筛选效率
  <a class="anchor" href="#%e5%85%b3%e6%b3%a8%e6%9f%a5%e8%af%a2%e6%88%90%e6%9c%ac%e7%ad%9b%e9%80%89%e6%95%88%e7%8e%87">#</a>
</h3>
<ul>
<li>索引数据量太少，选择性低，每次查询筛选剩余行数太多，效率很低</li>
<li>IS NULL / IS NOT NULL，也有可能筛选效率低，最好同时匹配其他筛选条件</li>
</ul>
<h3 id="对于联合索引利用其特性">
  对于联合索引，利用其特性
  <a class="anchor" href="#%e5%af%b9%e4%ba%8e%e8%81%94%e5%90%88%e7%b4%a2%e5%bc%95%e5%88%a9%e7%94%a8%e5%85%b6%e7%89%b9%e6%80%a7">#</a>
</h3>
<ul>
<li>索引左列范围、模糊、不指定条件等不精确查询，都可能导致右列索引能力失效<br>
即需要左侧指定，右侧才有效。（涵盖了所谓的最左前缀匹配原则）</li>
<li>排序字段顺序遵循索引顺序，否则无法利用索引排序</li>
</ul>
<h3 id="深分页优化">
  深分页优化
  <a class="anchor" href="#%e6%b7%b1%e5%88%86%e9%a1%b5%e4%bc%98%e5%8c%96">#</a>
</h3>
<h4 id="分页性能瓶颈">
  分页性能瓶颈
  <a class="anchor" href="#%e5%88%86%e9%a1%b5%e6%80%a7%e8%83%bd%e7%93%b6%e9%a2%88">#</a>
</h4>
<p>MySQL分页采用Limit和Offset进行分页查询，Limit限制本次返回记录数，Offset表示需要跳过的记录数<br>
当Offset很大，即深分页时，需要跳过大量的记录找到取数据的起始点，会导致性能瓶颈</p>
<ol>
<li>大量数据行扫描，时间成本高、磁盘IO压力大</li>
<li>扫描过的数据多，影响数据多，也会被很多数据的状态影响，更可能导致锁竞争问题</li>
</ol>
<h4 id="优化方法">
  优化方法
  <a class="anchor" href="#%e4%bc%98%e5%8c%96%e6%96%b9%e6%b3%95">#</a>
</h4>
<p>深分页性能瓶颈根因是Offset扫描数据量大，优化思路也围绕Offset，要么不使用Offset，要么Offset扫描数据不能多</p>
<ol>
<li>业务上避免深分页<br>
不用深分页了，普通深度的分页Offset不大，扫描数据的性能可以接受，自然不会有问题。页面或者应用层限制分页数量最大值即可</li>
<li>游标分页<br>
游标是上一次分页的终点，代表了本次查询的数据起点，每次查询记录在客户端，翻页时自然不用扫描数据</li>
</ol>
<pre tabindex="0"><code># 传统分页
SELECT * FROM users ORDER BY id LIMIT 10 OFFSET 1000;
# 游标分页
SELECT * FROM users WHERE id &gt; ? ORDER BY id LIMIT 10;
</code></pre><p>缺陷</p>
<ul>
<li>无法跳页，但往往业务上就是需要跳页</li>
<li>实现复杂，客户端存储游标倒是小事。主要是多列排序时的分页游标怎么确定比较困难，业务往往需要支持多字段的正逆序组合方式</li>
</ul>
<ol start="3">
<li>
<p>索引优化<br>
主要是对排序列使用索引，减少排序所需的时间</p>
</li>
<li>
<p>使用分区表<br>
分区表存放在不同的物理存储区域，数据扫描时仅扫描相关的物理区域，天然筛掉一部分数据，减少扫描数据量</p>
</li>
</ol>
<ul>
<li>但分区的设计是固定的，无法同时支持多种排序分页条件的性能提升</li>
</ul>
<ol start="5">
<li>预分页与缓存<br>
采用缓存存储分页查询的结果，减少数据库负担，对于短时间频繁的反复分页查询有很好的提速效果</li>
</ol>
<h3 id="避免大表联小表和无意义联表">
  避免大表联小表和无意义联表
  <a class="anchor" href="#%e9%81%bf%e5%85%8d%e5%a4%a7%e8%a1%a8%e8%81%94%e5%b0%8f%e8%a1%a8%e5%92%8c%e6%97%a0%e6%84%8f%e4%b9%89%e8%81%94%e8%a1%a8">#</a>
</h3>
<p>以 from 驱动表 join 被驱动表 on condition where xxx 为例<br>
联表过程是：<br>
驱动表逐行根据condition查询被驱动表，将对应数据行互相连接形成中间表<br>
where对中间表进行筛选<br>
所以如果使用大表联小表，联表过程就可能产生大量的查询过程，反之则不然</p>
<p>另外在代码层如果存在联表查询多表字段的SQL，但每次一些字段不需要查出的，也没必要联相关表，减少联表消耗</p>
<h3 id="业务代码层优化">
  业务代码层优化
  <a class="anchor" href="#%e4%b8%9a%e5%8a%a1%e4%bb%a3%e7%a0%81%e5%b1%82%e4%bc%98%e5%8c%96">#</a>
</h3>
<ol>
<li>避免循环中查询数据库<br>
反复的创建数据库链接和会话也是不小的开销，如果非必要，就不要这样做。否则会导致整体查询时间的延长，以及数据库负担的不必要提高</li>
</ol>
<ul>
<li>对于数据量不大的查询，最好一次性查出相关列，而不是在循环中等值查询</li>
<li>对于每次查询都是相同条件的，更不要在循环中执行，循环开始前查出，在内存中备用即可</li>
</ul>
<ol start="2">
<li>
<p>避免一次查询大量结果<br>
大量结果的返回会造成较大的网络负担，应该进行分页，或者条件分组的查询</p>
</li>
<li>
<p>缓存查询结果
使用缓存，减少数据库压力</p>
</li>
</ol>
<h3 id="优化的认知">
  优化的认知
  <a class="anchor" href="#%e4%bc%98%e5%8c%96%e7%9a%84%e8%ae%a4%e7%9f%a5">#</a>
</h3>
<ul>
<li>从前面的一些方法可以看到，优化的操作往往不能达到尽善尽美，总是具有各种限制，来自业务场景，或者方法本身效果没那么好</li>
<li>可以看出，优化这件事，本质是综合考虑了业务需求、数据量、数据分布，继而分析查询成本，考量系统的可接受度的基础上进行优化的，而且往往不能优化到理论上尽善尽美，而是在实际场景上，能好一些是一些</li>
<li>特别是考量整体的优化幅度，对于权重更高的场景优化更多，对整个系统的性能提升，远远大于对有限低发生量的场景的优化</li>
<li>更不应该因为技术情节，优化低权重场景，降低高权重场景性能，本末倒置</li>
</ul>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">


  <div><a class="flex align-center" href="https://github.com/constructor-md/codestack/commit/4153ac4c0815faa621e991b6f04f4a06da89012e" title='Last modified by constructor-md | 2025-05-03' target="_blank" rel="noopener">
      <img src="/codestack/svg/calendar.svg" class="book-icon" alt="" />
      <span>2025-05-03</span>
    </a>
  </div>




</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#表数据结构">表数据结构</a>
      <ul>
        <li><a href="#索引组织表">索引组织表</a></li>
        <li><a href="#逻辑存储架构">逻辑存储架构</a></li>
        <li><a href="#b树">B+树</a></li>
        <li><a href="#聚簇索引聚集索引主键索引">聚簇索引/聚集索引/主键索引</a></li>
        <li><a href="#二级索引">二级索引</a></li>
      </ul>
    </li>
    <li><a href="#索引失效情况枚举">索引失效情况枚举</a>
      <ul>
        <li><a href="#隐式类型转换导致索引失效">隐式类型转换导致索引失效</a></li>
        <li><a href="#使用函数或计算索引列">使用函数或计算索引列</a></li>
        <li><a href="#not-in-或-not-exists">NOT IN 或 NOT EXISTS</a></li>
        <li><a href="#不等于操作符--">不等于操作符 !=, &lt;&gt;</a></li>
        <li><a href="#查询条件包含is-nullis-not-null可能失效">查询条件包含IS NULL/IS NOT NULL(可能失效)</a></li>
        <li><a href="#or查询索引失效">OR查询索引失效</a></li>
        <li><a href="#前导模糊查询-like-xxx">前导模糊查询 Like &lsquo;%xxx&rsquo;</a></li>
        <li><a href="#索引选择性过低">索引选择性过低</a></li>
        <li><a href="#联合索引未遵循特性导致失效">联合索引未遵循特性导致失效</a></li>
        <li><a href="#字符集不同联表join时索引失效">字符集不同，联表Join时索引失效</a></li>
      </ul>
    </li>
    <li><a href="#索引设计原则">索引设计原则</a>
      <ul>
        <li><a href="#查多写少列建立索引">查多写少列建立索引</a></li>
        <li><a href="#索引列应具备高选择性">索引列应具备高选择性</a></li>
        <li><a href="#组合索引优化">组合索引优化</a></li>
      </ul>
    </li>
    <li><a href="#查询索引优化方法">查询索引优化方法</a>
      <ul>
        <li><a href="#利用覆盖索引">利用覆盖索引</a></li>
        <li><a href="#开启和倾向索引下推">开启和倾向索引下推</a></li>
      </ul>
    </li>
    <li><a href="#查询优化方法">查询优化方法</a>
      <ul>
        <li><a href="#查询具体列而不是-">查询具体列，而不是 *</a></li>
        <li><a href="#利用索引避免失效">利用索引，避免失效</a></li>
        <li><a href="#注意操作符">注意操作符</a></li>
        <li><a href="#关注查询成本筛选效率">关注查询成本、筛选效率</a></li>
        <li><a href="#对于联合索引利用其特性">对于联合索引，利用其特性</a></li>
        <li><a href="#深分页优化">深分页优化</a></li>
        <li><a href="#避免大表联小表和无意义联表">避免大表联小表和无意义联表</a></li>
        <li><a href="#业务代码层优化">业务代码层优化</a></li>
        <li><a href="#优化的认知">优化的认知</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












