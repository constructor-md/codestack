<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MySQL on CodeStack</title>
    <link>https://constructor-md.github.io/codestack/docs/javaee/mysql/</link>
    <description>Recent content in MySQL on CodeStack</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <atom:link href="https://constructor-md.github.io/codestack/docs/javaee/mysql/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>InnoDB 索引</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/mysql/innodb_index/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/mysql/innodb_index/</guid>
      <description>&lt;h1 id=&#34;innodb-索引&#34;&gt;&#xD;&#xA;  InnoDB 索引&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#innodb-%e7%b4%a2%e5%bc%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;表数据结构&#34;&gt;&#xD;&#xA;  表数据结构&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a1%a8%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;索引组织表&#34;&gt;&#xD;&#xA;  索引组织表&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b4%a2%e5%bc%95%e7%bb%84%e7%bb%87%e8%a1%a8&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;每张表必然有主键&lt;/li&gt;&#xA;&lt;li&gt;没有显示建立主键，使用第一个非空唯一索引作为主键&lt;/li&gt;&#xA;&lt;li&gt;没有非空唯一索引，存储引擎自动创建一个6字节大小的指针row_id作为主键&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;逻辑存储架构&#34;&gt;&#xD;&#xA;  逻辑存储架构&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%80%bb%e8%be%91%e5%ad%98%e5%82%a8%e6%9e%b6%e6%9e%84&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;所有数据存放在表空间中，表空间由段、区、页组成&lt;/li&gt;&#xA;&lt;li&gt;段有数据段、索引段、回滚段等。概念上数据就是索引，数据段就是B+树的叶子节点，索引段是B+树的非叶子节点&lt;/li&gt;&#xA;&lt;li&gt;区是连续页组成的空间，每个区大小固定1MB。页大小16KB，每区固定64个连续页&lt;/li&gt;&#xA;&lt;li&gt;页是存储引擎数据管理最小单位，每次读写磁盘最小一页，即16KB&lt;/li&gt;&#xA;&lt;li&gt;行：Innodb是面向列的存储引擎，数据按行存放，每页最多存放7992行记录&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;b树&#34;&gt;&#xD;&#xA;  B+树&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#b%e6%a0%91&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;B+树由二叉查找树和二叉平衡树发展而来，但B+树是多叉树，减小树高度&lt;/li&gt;&#xA;&lt;li&gt;B+树的记录数据都在叶子节点上，非叶子节点存放的数据是索引值&lt;/li&gt;&#xA;&lt;li&gt;叶子节点之间以指针双向连接，形成链表，方便范围查找&lt;/li&gt;&#xA;&lt;li&gt;B+树索引分成聚簇索引和二级索引，区别在于叶子节点是否存放所有行信息&lt;/li&gt;&#xA;&lt;li&gt;B+树是平衡树，所有叶子节点在同一层，查询稳定性高&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;优势&#34;&gt;&#xD;&#xA;  优势&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bc%98%e5%8a%bf&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;树高度低，减少磁盘IO&#xA;&lt;ol&gt;&#xA;&lt;li&gt;每个非叶子节点存放多个范围的下一级节点的指针，而不只是普通二叉查找树的两个，靠这一点减少树高度&lt;/li&gt;&#xA;&lt;li&gt;在索引树上查找时，先从磁盘读取根节点，每找到下一级索引就要从磁盘读取索引页得到数据继续判断，索引树高度低，使得读取一次磁盘筛选数据效率高，大幅减少磁盘IO次数&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;叶子链表范围查询高效&#xA;叶子节点形成索引值的顺序链表，支持顺序遍历，便于范围查询&lt;/li&gt;&#xA;&lt;li&gt;查询稳定性&#xA;&lt;ol&gt;&#xA;&lt;li&gt;B+树使用分裂+合并技术保持结构稳定性。因为插入数据导致一个节点达到容量上限，就会分裂成两个节点；因为删除数据导致两个节点太小，空间利用率低，就会合并成一个节点。这也是它的自平衡策略的一部分，同层横向扩展&lt;/li&gt;&#xA;&lt;li&gt;B+树高度变化少，一般最高四层就能存储千万以上数据&lt;/li&gt;&#xA;&lt;li&gt;只有叶子节点才有具体数据，插入和删除对树结构影响小&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;对比b树&#34;&gt;&#xD;&#xA;  对比B树&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%b9%e6%af%94b%e6%a0%91&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;B树非叶子节点存放数据，使得一次读取磁盘筛选数据效率低，且树高度变高，磁盘IO负担大&lt;/p&gt;&#xA;&lt;h3 id=&#34;聚簇索引聚集索引主键索引&#34;&gt;&#xD;&#xA;  聚簇索引/聚集索引/主键索引&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%81%9a%e7%b0%87%e7%b4%a2%e5%bc%95%e8%81%9a%e9%9b%86%e7%b4%a2%e5%bc%95%e4%b8%bb%e9%94%ae%e7%b4%a2%e5%bc%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;按主键构造B+树&lt;/li&gt;&#xA;&lt;li&gt;叶子节点存放的行记录信息包含所有列&lt;/li&gt;&#xA;&lt;li&gt;通过聚集索引查找数据，可以直接在叶子节点得到全部数据&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;二级索引&#34;&gt;&#xD;&#xA;  二级索引&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8c%e7%ba%a7%e7%b4%a2%e5%bc%95&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;根据索引列值构造B+树&lt;/li&gt;&#xA;&lt;li&gt;叶子节点有索引值、该索引值对应的主键&lt;/li&gt;&#xA;&lt;li&gt;通过二级索引查找数据时，会根据索引找到对应的叶子节点，再根据叶子节点上的主键值，回表到主键索引获取更多列数据&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;索引失效情况枚举&#34;&gt;&#xD;&#xA;  索引失效情况枚举&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b4%a2%e5%bc%95%e5%a4%b1%e6%95%88%e6%83%85%e5%86%b5%e6%9e%9a%e4%b8%be&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;隐式类型转换导致索引失效&#34;&gt;&#xD;&#xA;  隐式类型转换导致索引失效&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%9a%90%e5%bc%8f%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2%e5%af%bc%e8%87%b4%e7%b4%a2%e5%bc%95%e5%a4%b1%e6%95%88&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;原因：查询条件和主键类型不一致，转换失败时无法使用索引，导致全表扫描&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;-- 索引`id`为INT类型&#xD;&#xA;SELECT * FROM t WHERE id = &amp;#39;100&amp;#39;; -- 字符串转INT，索引有效（依赖优化器）&#xD;&#xA;SELECT * FROM t WHERE id = &amp;#39;100ABC&amp;#39;; -- 转换失败，全表扫描&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;使用函数或计算索引列&#34;&gt;&#xD;&#xA;  使用函数或计算索引列&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8%e5%87%bd%e6%95%b0%e6%88%96%e8%ae%a1%e7%ae%97%e7%b4%a2%e5%bc%95%e5%88%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;原因：索引树结构逻辑为大小排列，函数计算后无法找到对应的节点&lt;/p&gt;</description>
    </item>
    <item>
      <title>InnoDB 事务</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/mysql/innodb_transaction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/mysql/innodb_transaction/</guid>
      <description>&lt;h1 id=&#34;innodb-事务&#34;&gt;&#xD;&#xA;  InnoDB 事务&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#innodb-%e4%ba%8b%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;MySQL中，事务功能主要是由 InnoDB 存储引擎来实现的&lt;/p&gt;&#xA;&lt;h2 id=&#34;innodb-事务特性acid及实现&#34;&gt;&#xD;&#xA;  InnoDB 事务特性（ACID）及实现&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#innodb-%e4%ba%8b%e5%8a%a1%e7%89%b9%e6%80%a7acid%e5%8f%8a%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;原子性atomicity&#34;&gt;&#xD;&#xA;  原子性（Atomicity）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8e%9f%e5%ad%90%e6%80%a7atomicity&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;事务内的操作要么全部成功，要么全部失败&lt;/p&gt;&#xA;&lt;p&gt;通过Undo Log实现原子性&lt;br&gt;&#xA;Undo Log 记录事务操作的反操作，或者说记录了每个操作前的数据，当事务需要回滚时，可以根据Undo Log恢复数据。&lt;br&gt;&#xA;从而实现事务内的操作要么全部执行，要么都不执行&lt;/p&gt;&#xA;&lt;h3 id=&#34;一致性consistency&#34;&gt;&#xD;&#xA;  一致性（Consistency）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%80%e8%87%b4%e6%80%a7consistency&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;事务必须使数据库从一个一致性状态变换到另一个一致性状态&lt;br&gt;&#xA;依赖于原子性和隔离性的实现，还依赖于数据库自身的完整性约束(如外键、CHECK 约束等)和应用程序的正确逻辑&lt;/p&gt;&#xA;&lt;h3 id=&#34;持久性durability&#34;&gt;&#xD;&#xA;  持久性（Durability）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8c%81%e4%b9%85%e6%80%a7durability&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作&lt;br&gt;&#xA;通过数据写入磁盘，以及Redo Log记录写入内存未写入磁盘的操作，在系统崩溃恢复时写入磁盘。保证持久性&lt;br&gt;&#xA;Redo Log本身在磁盘顺序写入，速度很快&lt;/p&gt;&#xA;&lt;h3 id=&#34;隔离性isolation&#34;&gt;&#xD;&#xA;  隔离性（Isolation）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%9a%94%e7%a6%bb%e6%80%a7isolation&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;多个并发事务之间要相互隔离。对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始&lt;/p&gt;&#xA;&lt;p&gt;通过MVCC和锁机制实现隔离性&lt;/p&gt;&#xA;&lt;p&gt;先说明MVCC隔离性实现原理，锁机制放在锁的篇章中&lt;/p&gt;&#xA;&lt;h3 id=&#34;mvcc&#34;&gt;&#xD;&#xA;  MVCC&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mvcc&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;innodb通过ReadView快照和版本链实现MVCC&lt;/p&gt;&#xA;&lt;h4 id=&#34;readview-快照&#34;&gt;&#xD;&#xA;  ReadView 快照&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#readview-%e5%bf%ab%e7%85%a7&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;Readview是代码中的对象，主要有如下属性：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;m_ids: 生成ReadView时当前系统中活跃的读写事务的事务id列表（未提交的事务）&lt;/li&gt;&#xA;&lt;li&gt;min_trx_id: 生成ReadView时当前系统中活跃的读写事务的最小事务id m_ids的最小值（最早的未提交事务）&lt;/li&gt;&#xA;&lt;li&gt;max_trx_id: 生成ReadView时系统应该分配给下一个事务的id值（下一个事务）&lt;/li&gt;&#xA;&lt;li&gt;creator_trx_id: 生成该ReadView的事务的id（所属事务）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;版本链&#34;&gt;&#xD;&#xA;  版本链&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%89%88%e6%9c%ac%e9%93%be&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;在Innodb中，以最新记录和 undo log 中的历史记录形成了版本链&lt;br&gt;&#xA;Innodb的每行数据，都有两个隐藏字段：事务ID和回滚指针&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;事务ID代表这行数据由哪个事务最后更新，回滚指针指向Undo Log中这行数据的上一个版本&lt;/li&gt;&#xA;&lt;li&gt;Undo Log中记录了数据的每个版本，同样也携带着修改成该版本的事务ID和指向上一个版本的回滚指针&lt;/li&gt;&#xA;&lt;li&gt;每行最新的数据，以及Undo Log中的历史版本中的数据，的回滚指针们形成了一条链表，即版本链&lt;/li&gt;&#xA;&lt;li&gt;事务的每个修改，不论是否已经提交，都会被记录在版本链上&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;MySQL 中有专门的 Purge 线程，会定期检查 Undo Log，删除那些已经不再需要的记录&lt;br&gt;&#xA;Purge 操作会遍历 Undo Log 链表，找到那些没有被任何活动事务引用的节点，并将其从磁盘上删除，释放空间&lt;/p&gt;</description>
    </item>
    <item>
      <title>InnoDB 锁机制</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/mysql/innodb_lock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/mysql/innodb_lock/</guid>
      <description>&lt;h1 id=&#34;innodb-锁机制&#34;&gt;&#xD;&#xA;  InnoDB 锁机制&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#innodb-%e9%94%81%e6%9c%ba%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;锁分类和特性&#34;&gt;&#xD;&#xA;  锁分类和特性&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%94%81%e5%88%86%e7%b1%bb%e5%92%8c%e7%89%b9%e6%80%a7&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;S锁与X锁互斥，与S锁兼容&lt;/li&gt;&#xA;&lt;li&gt;X锁与S/X锁互斥&lt;/li&gt;&#xA;&lt;li&gt;加锁是实际是锁索引或者锁表&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果用了主键就锁聚簇索引&lt;/li&gt;&#xA;&lt;li&gt;如果用了二级索引就锁定二级索引再锁定聚簇索引&lt;/li&gt;&#xA;&lt;li&gt;如果没用到索引，就锁表&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;锁的释放时机是事务提交或回滚&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;行级锁&#34;&gt;&#xD;&#xA;  行级锁&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a1%8c%e7%ba%a7%e9%94%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基本的加锁是临键锁，因为一些条件转换为间隙锁、行锁、表锁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;记录锁sx锁&#34;&gt;&#xD;&#xA;  记录锁（S/X锁）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%ae%b0%e5%bd%95%e9%94%81sx%e9%94%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;单索引值锁&lt;/p&gt;&#xA;&lt;h4 id=&#34;间隙锁s锁&#34;&gt;&#xD;&#xA;  间隙锁（S锁）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%97%b4%e9%9a%99%e9%94%81s%e9%94%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在两行/两索引之间的左开右开区间锁&lt;/li&gt;&#xA;&lt;li&gt;间隙锁S与插入意向锁X互斥，作用是防止其他事务插入数据，避免幻读&lt;/li&gt;&#xA;&lt;li&gt;间隙锁S之间是兼容的&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;临键锁sx记录锁s间隙锁&#34;&gt;&#xD;&#xA;  临键锁（S/X记录锁+s间隙锁）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%b4%e9%94%ae%e9%94%81sx%e8%ae%b0%e5%bd%95%e9%94%81s%e9%97%b4%e9%9a%99%e9%94%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对记录行，以及以记录行本身主键/索引值为右边界，往前一个主键值/索引值为左边界的，左开右闭区间锁&lt;/li&gt;&#xA;&lt;li&gt;临键锁的记录部分与其他临键锁的记录部分根据记录锁的S/X区分冲突&#xA;&lt;ul&gt;&#xA;&lt;li&gt;临键锁的记录部分与其他临键锁的间隙锁不会冲突，不如说不存在加了间隙锁还有记录在中间的情况，也不存在有记录锁居然能加间隙锁的情况&lt;/li&gt;&#xA;&lt;li&gt;临键锁的间隙锁和其他临键锁的间隙锁不冲突&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;插入意向锁x模式间隙锁&#34;&gt;&#xD;&#xA;  插入意向锁（X模式间隙锁）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8f%92%e5%85%a5%e6%84%8f%e5%90%91%e9%94%81x%e6%a8%a1%e5%bc%8f%e9%97%b4%e9%9a%99%e9%94%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;与普通S间隙锁互斥，插入意向锁之间不互斥（特殊）&lt;/li&gt;&#xA;&lt;li&gt;insert插入数据时，需要对所在间隙加插入意向锁，多个事务可以对同一间隙加插入意向锁&lt;/li&gt;&#xA;&lt;li&gt;如果该间隙存在普通间隙锁，则插入意向锁会被阻塞&lt;/li&gt;&#xA;&lt;li&gt;多个事务插入数据，只要对应主键和索引无约束冲突，就可以并发执行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;表级锁&#34;&gt;&#xD;&#xA;  表级锁&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a1%a8%e7%ba%a7%e9%94%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;h4 id=&#34;表锁sx锁&#34;&gt;&#xD;&#xA;  表锁（S/X锁）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%a1%a8%e9%94%81sx%e9%94%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当进行需要加锁操作，但是未能明确指定主键/索引时，Innodb会扫描全表，对主键聚簇索引加临键锁（覆盖所有行，等效表锁）&lt;/li&gt;&#xA;&lt;li&gt;或显示使用 Lock Tables xxx write/read (Innodb不推荐，应优先行锁)&lt;/li&gt;&#xA;&lt;li&gt;是极端状态下的行锁集合（全表行锁+间隙锁），性能极差&lt;/li&gt;&#xA;&lt;li&gt;S表锁阻塞各种行X锁，不阻塞S锁。X表锁阻塞各种行X锁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;意向锁isix锁表级信号锁&#34;&gt;&#xD;&#xA;  意向锁（IS/IX锁，表级信号锁）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%84%8f%e5%90%91%e9%94%81isix%e9%94%81%e8%a1%a8%e7%ba%a7%e4%bf%a1%e5%8f%b7%e9%94%81&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当事务对某行加行级S锁，自动对表加意向共享锁（IS锁）&lt;/li&gt;&#xA;&lt;li&gt;当事务对某行加行级X锁，自动对表加意向排他锁（IX锁）&lt;/li&gt;&#xA;&lt;li&gt;永远与行级S/X锁共存（行锁必然带有对应意向锁）&lt;/li&gt;&#xA;&lt;li&gt;作用仅是标记“表中存在行锁”，以与全表锁互斥，不阻塞其他行锁和表意向锁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;语句加锁情况枚举可重复读级别&#34;&gt;&#xD;&#xA;  语句加锁情况枚举（可重复读级别）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%af%ad%e5%8f%a5%e5%8a%a0%e9%94%81%e6%83%85%e5%86%b5%e6%9e%9a%e4%b8%be%e5%8f%af%e9%87%8d%e5%a4%8d%e8%af%bb%e7%ba%a7%e5%88%ab&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;可以根据语句加锁情况和对应区域锁的S/X模式，来理论判断锁冲突情况&lt;/p&gt;&#xA;&lt;h3 id=&#34;普通查询&#34;&gt;&#xD;&#xA;  普通查询&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%99%ae%e9%80%9a%e6%9f%a5%e8%af%a2&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;不加锁，快照读，不会导致并发阻塞。且因为是快照读，不会幻读&lt;/li&gt;&#xA;&lt;li&gt;基于MVCC进行快照读，查询开始时生成快照，可读取已提交事务和本快照事务修改的数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;select--for-update&#34;&gt;&#xD;&#xA;  SELECT &amp;hellip; FOR UPDATE&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#select--for-update&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;唯一索引等值查询且匹配到数据，对匹配行加行锁（X锁）&lt;/li&gt;&#xA;&lt;li&gt;唯一索引范围查询且匹配到数据，对所有匹配行加临键锁（X记录锁+S间隙锁）&lt;/li&gt;&#xA;&lt;li&gt;唯一索引查询未匹配到数据，目标值所在间隙加间隙锁（S锁）&lt;/li&gt;&#xA;&lt;li&gt;普通索引范围查询匹配到数据，范围内索引项加临键锁（X记录锁+S间隙锁），对应主键行锁（X锁）&lt;/li&gt;&#xA;&lt;li&gt;普通索引查询未匹配到数据，目标值所在间隙加间隙锁（S锁）&lt;/li&gt;&#xA;&lt;li&gt;不使用索引/索引失效，退化为全表锁（各行X锁，间隙S锁）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;select--lock-in-share-mode&#34;&gt;&#xD;&#xA;  SELECT &amp;hellip; LOCK IN SHARE MODE&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#select--lock-in-share-mode&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;唯一索引等值查询且匹配到数据，对匹配行加行锁（S锁）&lt;/li&gt;&#xA;&lt;li&gt;唯一索引范围查询且匹配到数据，对所有匹配行加临键锁（S记录锁+S间隙锁）&lt;/li&gt;&#xA;&lt;li&gt;唯一索引查询未匹配到数据，目标值所在间隙加间隙锁（S锁）&lt;/li&gt;&#xA;&lt;li&gt;普通索引范围查询匹配到数据，范围内索引项加临键锁（S记录锁+S间隙锁），对应主键行锁（S锁）&lt;/li&gt;&#xA;&lt;li&gt;普通索引查询未匹配到数据，目标值所在间隙加间隙锁（S锁）&lt;/li&gt;&#xA;&lt;li&gt;不使用索引/索引失效，退化为全表锁（各行S锁，间隙S锁）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;insert&#34;&gt;&#xD;&#xA;  insert&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#insert&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;单行插入&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;尝试对插入间隙加插入意向锁X锁，如果存在间隙锁S锁，就阻塞等待&lt;/li&gt;&#xA;&lt;li&gt;加锁成功后执行插入，对插入位置加X锁，仅自己能插入，并执行插入&lt;/li&gt;&#xA;&lt;li&gt;如果位置上有别的数据插入的数据，则阻塞等待其他事务提交释放锁&lt;/li&gt;&#xA;&lt;li&gt;多个事务可以并发插入同个间隙的不同位置，不互相阻塞&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;批量插入&#xA;逐行执行多个单行插入，重复上述过程&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;update&#34;&gt;&#xD;&#xA;  update&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#update&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对where条件匹配的行加X锁&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果用了唯一索引（索引扫描），对匹配索引值加记录X锁&lt;/li&gt;&#xA;&lt;li&gt;如果用了普通索引（索引扫描），对匹配索引值加临键X锁&lt;/li&gt;&#xA;&lt;li&gt;如果没有使用索引或者索引失效（全表扫描），对全表加X表锁(所有记录X临键锁)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;如果会更新索引字段，旧索引项加X锁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;delete&#34;&gt;&#xD;&#xA;  delete&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#delete&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对where条件匹配的行加X锁&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果用了唯一索引（索引扫描），对匹配索引值加记录X锁&lt;/li&gt;&#xA;&lt;li&gt;如果用了普通索引（索引扫描），对匹配索引值加临键X锁&lt;/li&gt;&#xA;&lt;li&gt;如果没有使用索引或者索引失效（全表扫描），对全表加X表锁(所有记录X临键锁)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;可以优化的操作方向&#34;&gt;&#xD;&#xA;  可以优化的操作方向&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%af%e4%bb%a5%e4%bc%98%e5%8c%96%e7%9a%84%e6%93%8d%e4%bd%9c%e6%96%b9%e5%90%91&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;测试机检查&#34;&gt;&#xD;&#xA;  测试机检查&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%b5%8b%e8%af%95%e6%9c%ba%e6%a3%80%e6%9f%a5&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;测试SQL执行究竟是加表锁还是行锁等，修改以避免表锁&lt;/p&gt;</description>
    </item>
    <item>
      <title>SQL执行过程</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/mysql/sql-execution/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/mysql/sql-execution/</guid>
      <description>&lt;h1 id=&#34;sql执行过程&#34;&gt;&#xD;&#xA;  SQL执行过程&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#sql%e6%89%a7%e8%a1%8c%e8%bf%87%e7%a8%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;查询sql执行顺序&#34;&gt;&#xD;&#xA;  查询SQL执行顺序&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9f%a5%e8%af%a2sql%e6%89%a7%e8%a1%8c%e9%a1%ba%e5%ba%8f&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;以如下SQL为例：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;select distinct table1.id as card_id &#xD;&#xA;from table1&#xD;&#xA;join table2 on table1.id = table2.id&#xD;&#xA;where table1.id &amp;lt; 2&#xD;&#xA;group by card_id&#xD;&#xA;having max(card_id) &amp;gt; 10&#xD;&#xA;order by card_id desc&#xD;&#xA;limit 1, 1;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行顺序如下&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;FROM，查询语句的开始，每个步骤为下一个步骤生成一个虚拟表，作为下一个步骤的输入&#xA;&lt;ol&gt;&#xA;&lt;li&gt;如果是表，直接操作表&lt;/li&gt;&#xA;&lt;li&gt;如果是子查询，先执行子查询&lt;/li&gt;&#xA;&lt;li&gt;如果要关联表，执行下述JOIN、ON&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;JOIN 关联表，生成笛卡尔乘积虚拟表&lt;/li&gt;&#xA;&lt;li&gt;ON，对JOIN出来的虚拟表进行按条件筛选，并生成一个新虚拟表&lt;/li&gt;&#xA;&lt;li&gt;WHERE，对虚拟表进行按条件筛选，生成一张新虚拟表&lt;/li&gt;&#xA;&lt;li&gt;GROUP BY，将按指定列的值分组，得到新的虚拟表。后续的所有步骤都只能操作被分组的列。&lt;/li&gt;&#xA;&lt;li&gt;AVG,SUM,MAX…，聚合函数 对分组的结果进行计算，不生成虚拟表&lt;/li&gt;&#xA;&lt;li&gt;HAVING，按条件筛选，主要和GROUP BY配合使用。且是唯一一个应用到已分组数据的筛选器。生成新虚拟表&lt;/li&gt;&#xA;&lt;li&gt;SELECT，选择指定列，生成新虚拟表&lt;/li&gt;&#xA;&lt;li&gt;DISTINCT，去重，对上出结果进行去重，移除相同的行。产生新虚拟表。使用GROUP BY后，DISTINCT多余。&lt;/li&gt;&#xA;&lt;li&gt;ORDER BY，按照对指定列升序或降序。返回游标，而不是虚拟表。&lt;/li&gt;&#xA;&lt;li&gt;LIMIT，取出指定行的记录，产生虚拟表并返回结果。Limit m,n表示从第m到第n数据。&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>日志文件及作用</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/mysql/logfile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/mysql/logfile/</guid>
      <description>&lt;h1 id=&#34;日志文件及作用&#34;&gt;&#xD;&#xA;  日志文件及作用&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%97%a5%e5%bf%97%e6%96%87%e4%bb%b6%e5%8f%8a%e4%bd%9c%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;errorlog-错误日志&#34;&gt;&#xD;&#xA;  error.log 错误日志：&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#errorlog-%e9%94%99%e8%af%af%e6%97%a5%e5%bf%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt;对MySQL的启动、运行、关闭过程进行了记录&#xD;&#xA;用于问题的排查，如例如权限问题、配置错误、磁盘空间不足&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;slowlog-慢查询日志&#34;&gt;&#xD;&#xA;  slow.log 慢查询日志：&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#slowlog-%e6%85%a2%e6%9f%a5%e8%af%a2%e6%97%a5%e5%bf%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt;可通过slow_query_log_file参数在配置文件中指定文件名，若未指定，默认在数据目录下，文件名为hostname-slow.log&#xD;&#xA;默认情况下不启动慢查询日志，需要手动设置&#xD;&#xA;用于定位执行时间超过设置值的SQL，以及没有使用索引的SQL&#xD;&#xA;可以通过mysqldupmslow查找和筛选慢查询日志的内容&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;查询日志&#34;&gt;&#xD;&#xA;  查询日志：&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9f%a5%e8%af%a2%e6%97%a5%e5%bf%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt;其文件名可通过general_log_file参数在配置文件中指定，若未指定，默认在数据目录下，文件名为hostname.log&#xD;&#xA;记录了所有对MySQL数据库请求的信息，不论是否得到了正确执行&#xD;&#xA;但由于会记录所有语句，开启该日志会对性能产生较大影响，所以通常只在调试或测试环境中开启&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;二进制日志binlog&#34;&gt;&#xD;&#xA;  二进制日志bin.log&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%97%a5%e5%bf%97binlog&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt;二进制日志由一系列文件组成，文件名格式为binlog.xxxxxx ，其中xxxxxx是一个 6 位的数字序号，从 000001 开始递增。其文件名前缀可通过log_bin参数在配置文件中指定&#xD;&#xA;记录了所有对MySQL数据库进行的更改&#xD;&#xA;作用：&#xD;&#xA;    数据恢复，数据库全备文件恢复&#xD;&#xA;    主从复制，通过复制和执行二进制日志，使从库和主库实时同步&#xD;&#xA;    审计判断是否有对数据库攻击&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;中继日志relay-log&#34;&gt;&#xD;&#xA;  中继日志（Relay Log）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ad%e7%bb%a7%e6%97%a5%e5%bf%97relay-log&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt;文件名格式为relay-log.xxxxxx ，其中xxxxxx是一个 6 位的数字序号，从 000001 开始递增。文件名前缀可通过relay_log参数在配置文件中指定。&#xD;&#xA;作用：&#xD;&#xA;    在主从复制架构中，从服务器从主服务器接收二进制日志内容后，会将其存储在中继日志中&#xD;&#xA;    从服务器的 SQL 线程会读取中继日志中的内容，并在本地执行相应的 SQL 语句，从而实现数据的同步&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;事务日志innodb&#34;&gt;&#xD;&#xA;  事务日志（Innodb）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8b%e5%8a%a1%e6%97%a5%e5%bf%97innodb&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;redo-log-重做日志&#34;&gt;&#xD;&#xA;  Redo log 重做日志:&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#redo-log-%e9%87%8d%e5%81%9a%e6%97%a5%e5%bf%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt;默认文件名为ib_logfile0、ib_logfile1等，可通过innodb_log_files_in_group参数指定日志文件的数量，通过innodb_log_file_size参数指定每个日志文件的大小。&#xD;&#xA;用于保证事务的持久性&#xD;&#xA;MySQL中有大量缓存，数据修改时首先更新缓存，但是缓存并非马上同步到磁盘，即为脏页&#xD;&#xA;但是数据库如果宕机，则内存数据丢失，重启无法恢复&#xD;&#xA;所以每次修改内存就要写redo log，redo log顺序写入，磁盘的顺序读写速度远快于随机读写，写操作对性能影响较小&#xD;&#xA;Redo log是物理日志，记录数据页的物理修改，用于恢复提交后的物理数据页&#xD;&#xA;如果数据库意外重启，会根据redo log进行数据恢复&#xD;&#xA;如果redo log有事务提交，则提交事务修改数据。也仅能恢复到数据最后提交的状态&#xD;&#xA;可以利用 Redo Log 将未写入磁盘的数据页恢复到崩溃前的状态&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;undo-log-回滚日志&#34;&gt;&#xD;&#xA;  Undo log 回滚日志:&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#undo-log-%e5%9b%9e%e6%bb%9a%e6%97%a5%e5%bf%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt;InnoDB Undo Log 没有单独的文件名，它是存储在系统表空间（ibdata1）或独立的 undo 表空间中的。可通过innodb_undo_tablespaces参数指定独立 undo 表空间的数量&#xD;&#xA;undo log是逻辑日志，每次修改数据，undolog中出现一条反操作的记录&#xD;&#xA;可以用于事务回滚，也可以根据undolog回溯到某个特定版本的数据&#xD;&#xA;用于实现事务的原子性和多版本并发控制（MVCC）&#xD;&#xA;在事务执行过程中，Undo Log 会记录数据修改前的状态，当事务需要回滚时，可以根据 Undo Log 将数据恢复到事务开始前的状态&#xD;&#xA;同时，MVCC 通过 Undo Log 提供数据的多个版本，使得不同事务可以同时访问同一数据的不同版本，提高并发性能&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Explain参数解释和查询成本分析</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/mysql/explain/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/mysql/explain/</guid>
      <description>&lt;h1 id=&#34;explain参数解释和查询成本分析&#34;&gt;&#xD;&#xA;  Explain参数解释和查询成本分析&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#explain%e5%8f%82%e6%95%b0%e8%a7%a3%e9%87%8a%e5%92%8c%e6%9f%a5%e8%af%a2%e6%88%90%e6%9c%ac%e5%88%86%e6%9e%90&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;explain&#34;&gt;&#xD;&#xA;  Explain&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#explain&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;通过执行 explain [sql] 得到执行计划&lt;/p&gt;&#xA;&lt;p&gt;如果from中包含子查询，会查并生成临时表&lt;/p&gt;&#xA;&lt;p&gt;explain执行完之后执行show warnings，有时候可以直接拷贝出来直接使用，大多时候可以用于参考执行&lt;/p&gt;&#xA;&lt;h3 id=&#34;结果列分析&#34;&gt;&#xD;&#xA;  结果列分析&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%93%e6%9e%9c%e5%88%97%e5%88%86%e6%9e%90&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;h4 id=&#34;id&#34;&gt;&#xD;&#xA;  id&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#id&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;有几个select就有几个id，id按select出现的顺序增长，id大的先执行，null最后执行，相同则从上往下执行&lt;/p&gt;&#xA;&lt;h4 id=&#34;select_type&#34;&gt;&#xD;&#xA;  select_type&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#select_type&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;simple 简单查询，没有子查询和union&lt;/li&gt;&#xA;&lt;li&gt;primary 复杂查询中最外层迭代select&lt;/li&gt;&#xA;&lt;li&gt;subquery 包含在select中的子查询，不在from中&lt;/li&gt;&#xA;&lt;li&gt;dependent subquery select语句出现的子查询，依赖外部查询&lt;/li&gt;&#xA;&lt;li&gt;derived 包含在from子句的子查询，会把结果放在临时表（派生表）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;table&#34;&gt;&#xD;&#xA;  table&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#table&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;这一行的查询在访问哪个表&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;from子句有子查询时，table列是&lt;!-- raw HTML omitted --&gt;格式，表示当前查询依赖id=N的查询，会先执行id=N的查询&lt;/li&gt;&#xA;&lt;li&gt;有union时，union result的table列的值为union 1,2，1和2表示参与union的select的id&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;type&#34;&gt;&#xD;&#xA;  type&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#type&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;表示关联类型或访问类型，表示mysql决定如何查找表中的行，查找数据行记录的大概范围, 从最优到最差依次为：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;system &amp;gt; const &amp;gt; eq_ref &amp;gt; ref &amp;gt; range &amp;gt; index &amp;gt; ALL&#xA;一般来说应该最少把查询保持在range级别，最好达到ref&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;system MyIsm出现，表为空或者记录唯一时&lt;/li&gt;&#xA;&lt;li&gt;const 主键索引或唯一索引的等值查询&lt;/li&gt;&#xA;&lt;li&gt;eq_ref join的时候有驱动表和被驱动表，被驱动表走唯一或者主键索引时&lt;/li&gt;&#xA;&lt;li&gt;ref 非主键或非唯一索引的等值查询，关联查询时被驱动表的驱动键走非唯一索引&lt;/li&gt;&#xA;&lt;li&gt;range 一般索引的范围查询&lt;/li&gt;&#xA;&lt;li&gt;index 全表扫描，非聚簇索引的叶子节点&lt;/li&gt;&#xA;&lt;li&gt;All 聚簇索引的全表扫描&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;possible-keys列&#34;&gt;&#xD;&#xA;  possible keys列&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#possible-keys%e5%88%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;显示查询可能使用哪些索引来查找&lt;/p&gt;</description>
    </item>
    <item>
      <title>索引树高度计算</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/mysql/tree-high/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/mysql/tree-high/</guid>
      <description>&lt;h1 id=&#34;索引树高度计算&#34;&gt;&#xD;&#xA;  索引树高度计算&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b4%a2%e5%bc%95%e6%a0%91%e9%ab%98%e5%ba%a6%e8%ae%a1%e7%ae%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;基本原理&#34;&gt;&#xD;&#xA;  基本原理&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;Innodb是索引组织表，每个页都包含一个PAGE_LEVEL，表示当前页在索引上的高度&lt;/p&gt;&#xA;&lt;p&gt;默认叶子节点高度为0，ROOT节点PAGE_LEVEL+1就是这棵索引高度&lt;/p&gt;&#xA;&lt;p&gt;PAGE_LEVEL在每个页的64位偏移位置，占用2字节&lt;/p&gt;&#xA;&lt;p&gt;找到ROOT页位置，知道单页大小，使用hexdump在指定表空间找到第PAGE_NO页的64位偏移量的后两个字节即可&lt;/p&gt;&#xA;&lt;h2 id=&#34;找到root页信息&#34;&gt;&#xD;&#xA;  找到ROOT页信息&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%89%be%e5%88%b0root%e9%a1%b5%e4%bf%a1%e6%81%af&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;SELECT b.name, a.name, index_id, type, a.space, a.PAGE_NO&#xD;&#xA;FROM information_schema.INNODB_SYS_INDEXES a,&#xD;&#xA;information_schema.INNODB_SYS_TABLES b&#xD;&#xA;WHERE a.table_id = b.table_id AND a.space &amp;lt;&amp;gt; 0;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结果：&#xA;&lt;img src=&#34;./images/root-info.png&#34; alt=&#34;&amp;ldquo;root页信息&amp;rdquo;&#34; title=&#34;root页信息&#34;/&gt;&#xA;其中（space、PAGE_NO）指向ROOT页&lt;/p&gt;&#xA;&lt;p&gt;space是表空间，可以是系统表空间（如ibdata1文件）或独立表空间（如每个InnoDB表的.ibd文件）。表空间由多个区（extent）组成，每个区包含连续的页（page）&lt;/p&gt;&#xA;&lt;p&gt;也就是ROOT页是space的page_no页&lt;/p&gt;&#xA;&lt;h2 id=&#34;查看innodb_page_size&#34;&gt;&#xD;&#xA;  查看innodb_page_size&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9f%a5%e7%9c%8binnodb_page_size&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;show variables like &amp;#39;innodb_page_size&amp;#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结果：&#xA;&lt;img src=&#34;./images/innodb_page_size.png&#34; alt=&#34;&amp;ldquo;innodb_page_size&amp;rdquo;&#34; title=&#34;innodb_page_size&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;也就是Innodb默认的页大小16KB&lt;/p&gt;&#xA;&lt;h2 id=&#34;找到root的page_level得到索引高度&#34;&gt;&#xD;&#xA;  找到ROOT的PAGE_LEVEL，得到索引高度&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%89%be%e5%88%b0root%e7%9a%84page_level%e5%be%97%e5%88%b0%e7%b4%a2%e5%bc%95%e9%ab%98%e5%ba%a6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;首先要找到表对应的ibd文件，也就是表空间文件&lt;/p&gt;&#xA;&lt;p&gt;所在位置是MySQL的数据目录下的数据库名文件夹下&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#查找MySQL数据目录&#xD;&#xA;show variables like &amp;#39;datadir&amp;#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;./images/dir.png&#34; alt=&#34;&amp;ldquo;dir&amp;rdquo;&#34; title=&#34;dir&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;我的MySQL是用Docker起的，docker中没有安装hexdump命令，不过这个目录被挂载出来了，考虑在宿主机上分析其中的ibd文件&lt;/p&gt;&#xA;&lt;p&gt;但所在文件夹和文件权限限制了宿主机外用户访问文件夹和文件&#xA;&lt;img src=&#34;./images/docker-dir.png&#34; alt=&#34;&amp;ldquo;docker-dir&amp;rdquo;&#34; title=&#34;docker-dir&#34;/&gt;&#xA;修改权限需要到docker容器中修改该文件和对应文件夹权限&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;chmod 755 path&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;原本权限为750，禁止其他用户读写文件夹&lt;/p&gt;&#xA;&lt;p&gt;修改后在宿主机进入文件夹中，找到所需文件，在文件夹执行命令&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;hexdump -C -s 49216 -n 10 goods_info_100M.ibd&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;./images/page-info.png&#34; alt=&#34;&amp;ldquo;page-info&amp;rdquo;&#34; title=&#34;page-info&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;前两个字节是PAGE_LEVEL，所以这个索引树高度为3+1 = 4&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
