<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MySQL on CodeStack</title>
    <link>https://constructor-md.github.io/codestack/docs/javaee/mysql/</link>
    <description>Recent content in MySQL on CodeStack</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <atom:link href="https://constructor-md.github.io/codestack/docs/javaee/mysql/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>MVCC 多版本并发控制</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/mysql/mvcc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/mysql/mvcc/</guid>
      <description>&lt;h1 id=&#34;mvcc-多版本并发控制&#34;&gt;&#xD;&#xA;  MVCC 多版本并发控制&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#mvcc-%e5%a4%9a%e7%89%88%e6%9c%ac%e5%b9%b6%e5%8f%91%e6%8e%a7%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;版本链&#34;&gt;&#xD;&#xA;  版本链&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%89%88%e6%9c%ac%e9%93%be&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;数据库中，以最新记录和undolog中的历史记录形成了版本链&lt;/p&gt;&#xA;&lt;p&gt;版本链中每个版本，除了具体行数据之外，还有该版本的事务ID、和回滚指针，每一行记录都有这两个隐藏列&lt;/p&gt;&#xA;&lt;p&gt;每个版本的回滚指针指向上一个版本&lt;/p&gt;&#xA;&lt;h2 id=&#34;readview-快照数据&#34;&gt;&#xD;&#xA;  ReadView 快照数据&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#readview-%e5%bf%ab%e7%85%a7%e6%95%b0%e6%8d%ae&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;作用：让数据库知道在具体查询的时候，应该去查询哪个版本的数据&lt;/p&gt;&#xA;&lt;p&gt;数据结构：代码里的一个对象&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;M_ids: 生成ReadView时当前系统中活跃的读写事务的事务id列表（未提交）&lt;/li&gt;&#xA;&lt;li&gt;Min_trax_id: 生成ReadView时当前系统中活跃的读写事务的最小事务id m_ids的最小值（最老的一个未提交）&lt;/li&gt;&#xA;&lt;li&gt;Max_trx_id: 生成ReadView时系统应该分配给下一个事务的id值（未生成即将生成）&lt;/li&gt;&#xA;&lt;li&gt;Creator_trx_id: 生成该ReadView的事务的id（创建者）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;ReadView如何判断版本链中哪个版本可用？&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Trx_id == creator_trx_id 可以访问这个版本（创建者可以访问）&lt;/li&gt;&#xA;&lt;li&gt;Trx_id &amp;lt; min_trx_id 可以访问这个版本（可以访问已提交的数据）&lt;/li&gt;&#xA;&lt;li&gt;Trx_id &amp;gt; max_trx_id 不可以访问这个版本（当前事务不能访问超过当前版本链的数据）&lt;/li&gt;&#xA;&lt;li&gt;Min_trx_id &amp;lt;= trx_id &amp;lt;= max_trx_id 如果trx_id在m_ids中，就可以不访问这个版本，因为里面的数据都没有commit&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;readview如何实现读已提交和可重复读&#34;&gt;&#xD;&#xA;  ReadView如何实现读已提交和可重复读？&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#readview%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e8%af%bb%e5%b7%b2%e6%8f%90%e4%ba%a4%e5%92%8c%e5%8f%af%e9%87%8d%e5%a4%8d%e8%af%bb&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;版本链是全局的，没有事务时版本链的头部是最新数据，后面是每个版本的历史数据&lt;/p&gt;&#xA;&lt;p&gt;如果有多个事务同时更新某一行数据，每个事务的更新，都会在版本链上生成一个版本&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;执行一个select前&#xA;先生成一个当前事务的ReadView，ReadView包含上述数据&lt;/li&gt;&#xA;&lt;li&gt;让ReadView在版本链从头到尾比较：(版本数据对查询的可见性)&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果该版本是当前事务提交的，那自然可以访问该数据，且该版本未提交也可以访问&lt;/li&gt;&#xA;&lt;li&gt;如果该版本不是当前事务提交，但是是已提交的数据，当然可以访问&lt;/li&gt;&#xA;&lt;li&gt;如果该版本数据是当前事务之后生成的事务生成的版本，那么肯定没有提交，不能访问&lt;/li&gt;&#xA;&lt;li&gt;如果该版本数据是当前事务生成ReadView时的未提交事务之一，那么不能访问这些未提交的数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;事务隔离级别与mvcc&#34;&gt;&#xD;&#xA;  事务隔离级别与MVCC&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8b%e5%8a%a1%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab%e4%b8%8emvcc&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;如果是读已提交：&#xA;则每次select都会生成ReadView，使得除了creator_trx_id以外的数据有所变化&lt;/p&gt;&#xA;&lt;p&gt;于是每次select都可以访问到最新的提交数据，或者是自己的修改数据&lt;/p&gt;&#xA;&lt;p&gt;访问到的最新提交数据可能变化&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;如果是可重复读：&#xA;仅在第一次select生成ReadView&lt;/p&gt;&#xA;&lt;p&gt;从而每次要么访问到自己的最新修改，要么一直是生成当时的最新提交数据，不会变化&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;如果是读未提交：&#xA;则每次直接访问最新的版本链数据，不关心是否提交，不需要MVCC&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;如果是串行化：&#xA;则通过加锁互斥访问，不需要MVCC&lt;/p&gt;</description>
    </item>
    <item>
      <title>日志文件及作用</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/mysql/logfile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/mysql/logfile/</guid>
      <description>&lt;h1 id=&#34;日志文件及作用&#34;&gt;&#xD;&#xA;  日志文件及作用&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%97%a5%e5%bf%97%e6%96%87%e4%bb%b6%e5%8f%8a%e4%bd%9c%e7%94%a8&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;errorlog-错误日志&#34;&gt;&#xD;&#xA;  error.log 错误日志：&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#errorlog-%e9%94%99%e8%af%af%e6%97%a5%e5%bf%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt;对MySQL的启动、运行、关闭过程进行了记录&#xD;&#xA;用于问题的排查，如例如权限问题、配置错误、磁盘空间不足&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;slowlog-慢查询日志&#34;&gt;&#xD;&#xA;  slow.log 慢查询日志：&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#slowlog-%e6%85%a2%e6%9f%a5%e8%af%a2%e6%97%a5%e5%bf%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt;可通过slow_query_log_file参数在配置文件中指定文件名，若未指定，默认在数据目录下，文件名为hostname-slow.log&#xD;&#xA;默认情况下不启动慢查询日志，需要手动设置&#xD;&#xA;用于定位执行时间超过设置值的SQL，以及没有使用索引的SQL&#xD;&#xA;可以通过mysqldupmslow查找和筛选慢查询日志的内容&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;查询日志&#34;&gt;&#xD;&#xA;  查询日志：&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9f%a5%e8%af%a2%e6%97%a5%e5%bf%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt;其文件名可通过general_log_file参数在配置文件中指定，若未指定，默认在数据目录下，文件名为hostname.log&#xD;&#xA;记录了所有对MySQL数据库请求的信息，不论是否得到了正确执行&#xD;&#xA;但由于会记录所有语句，开启该日志会对性能产生较大影响，所以通常只在调试或测试环境中开启&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;二进制日志binlog&#34;&gt;&#xD;&#xA;  二进制日志bin.log&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%97%a5%e5%bf%97binlog&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt;二进制日志由一系列文件组成，文件名格式为binlog.xxxxxx ，其中xxxxxx是一个 6 位的数字序号，从 000001 开始递增。其文件名前缀可通过log_bin参数在配置文件中指定&#xD;&#xA;记录了所有对MySQL数据库进行的更改&#xD;&#xA;作用：&#xD;&#xA;    数据恢复，数据库全备文件恢复&#xD;&#xA;    主从复制，通过复制和执行二进制日志，使从库和主库实时同步&#xD;&#xA;    审计判断是否有对数据库攻击&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;中继日志relay-log&#34;&gt;&#xD;&#xA;  中继日志（Relay Log）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ad%e7%bb%a7%e6%97%a5%e5%bf%97relay-log&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt;文件名格式为relay-log.xxxxxx ，其中xxxxxx是一个 6 位的数字序号，从 000001 开始递增。文件名前缀可通过relay_log参数在配置文件中指定。&#xD;&#xA;作用：&#xD;&#xA;    在主从复制架构中，从服务器从主服务器接收二进制日志内容后，会将其存储在中继日志中&#xD;&#xA;    从服务器的 SQL 线程会读取中继日志中的内容，并在本地执行相应的 SQL 语句，从而实现数据的同步&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;事务日志innodb&#34;&gt;&#xD;&#xA;  事务日志（Innodb）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8b%e5%8a%a1%e6%97%a5%e5%bf%97innodb&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;h3 id=&#34;redo-log&#34;&gt;&#xD;&#xA;  Redo log:&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#redo-log&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt;默认文件名为ib_logfile0、ib_logfile1等，可通过innodb_log_files_in_group参数指定日志文件的数量，通过innodb_log_file_size参数指定每个日志文件的大小。&#xD;&#xA;用于保证事务的持久性&#xD;&#xA;MySQL中有大量缓存，数据修改时首先更新缓存，但是缓存并非马上同步到磁盘，即为脏页&#xD;&#xA;但是数据库如果宕机，则内存数据丢失，重启无法恢复&#xD;&#xA;所以每次修改内存就要写redo log，redo log顺序写入，磁盘的顺序读写速度远快于随机读写，写操作对性能影响较小&#xD;&#xA;Redo log是物理日志，记录数据页的物理修改，用于恢复提交后的物理数据页&#xD;&#xA;如果数据库意外重启，会根据redo log进行数据恢复&#xD;&#xA;如果redo log有事务提交，则提交事务修改数据。也仅能恢复到数据最后提交的状态&#xD;&#xA;可以利用 Redo Log 将未写入磁盘的数据页恢复到崩溃前的状态&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;undo-log&#34;&gt;&#xD;&#xA;  Undo log:&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#undo-log&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre&gt;&lt;code&gt;InnoDB Undo Log 没有单独的文件名，它是存储在系统表空间（ibdata1）或独立的 undo 表空间中的。可通过innodb_undo_tablespaces参数指定独立 undo 表空间的数量&#xD;&#xA;undo log是逻辑日志，每次修改数据，undolog中出现一条反操作的记录&#xD;&#xA;可以用于事务回滚，也可以根据undolog回溯到某个特定版本的数据&#xD;&#xA;用于实现事务的原子性和多版本并发控制（MVCC）&#xD;&#xA;在事务执行过程中，Undo Log 会记录数据修改前的状态，当事务需要回滚时，可以根据 Undo Log 将数据恢复到事务开始前的状态&#xD;&#xA;同时，MVCC 通过 Undo Log 提供数据的多个版本，使得不同事务可以同时访问同一数据的不同版本，提高并发性能&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Explain参数解释和查询成本分析</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/mysql/explain/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/mysql/explain/</guid>
      <description>&lt;h1 id=&#34;explain参数解释和查询成本分析&#34;&gt;&#xD;&#xA;  Explain参数解释和查询成本分析&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#explain%e5%8f%82%e6%95%b0%e8%a7%a3%e9%87%8a%e5%92%8c%e6%9f%a5%e8%af%a2%e6%88%90%e6%9c%ac%e5%88%86%e6%9e%90&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;explain&#34;&gt;&#xD;&#xA;  Explain&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#explain&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;通过执行 explain [sql] 得到执行计划&lt;/p&gt;&#xA;&lt;p&gt;如果from中包含自查虚拟，会查并生成临时表&lt;/p&gt;&#xA;&lt;p&gt;explain执行完之后执行show warnings，有时候可以直接拷贝出来直接使用，大多时候可以用于参考执行&lt;/p&gt;&#xA;&lt;h3 id=&#34;结果列分析&#34;&gt;&#xD;&#xA;  结果列分析&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%bb%93%e6%9e%9c%e5%88%97%e5%88%86%e6%9e%90&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;h4 id=&#34;id&#34;&gt;&#xD;&#xA;  id&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#id&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;有几个select就有几个id，id按select出现的顺序增长，id大的先执行，null最后执行，相同则从上往下执行&lt;/p&gt;&#xA;&lt;h4 id=&#34;select_type&#34;&gt;&#xD;&#xA;  select_type&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#select_type&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;simple 简单查询，没有子查询和union&lt;/li&gt;&#xA;&lt;li&gt;primary 复杂查询中最外层迭代select&lt;/li&gt;&#xA;&lt;li&gt;subquery 包含在select中的子查询，不在from中&lt;/li&gt;&#xA;&lt;li&gt;dependent subquery select语句出现的子查询，依赖外部查询&lt;/li&gt;&#xA;&lt;li&gt;derived 包含在from子句的子查询，会把结果放在临时表（派生表）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;table&#34;&gt;&#xD;&#xA;  table&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#table&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;这一行的查询在访问哪个表&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;from子句有子查询时，table列是&lt;!-- raw HTML omitted --&gt;格式，表示当前查询依赖id=N的查询，会先执行id=N的查询&lt;/li&gt;&#xA;&lt;li&gt;有union时，union result的table列的值为union 1,2，1和2表示参与union的select的id&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;type&#34;&gt;&#xD;&#xA;  type&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#type&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;表示关联类型或访问类型，表示mysql决定如何查找表中的行，查找数据行记录的大概范围, 从最优到最差依次为：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;system &amp;gt; const &amp;gt; eq_ref &amp;gt; ref &amp;gt; range &amp;gt; index &amp;gt; ALL&#xA;一般来说应该最少把查询保持在range级别，最好达到ref&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;system MyIsm出现，表为空或者记录唯一时&lt;/li&gt;&#xA;&lt;li&gt;const 主键索引或唯一索引的等值查询&lt;/li&gt;&#xA;&lt;li&gt;eq_ref join的时候有驱动表和被驱动表，被驱动表走唯一或者主键索引时&lt;/li&gt;&#xA;&lt;li&gt;ref 非主键或非唯一索引的等值查询，关联查询时被驱动表的驱动键走非唯一索引&lt;/li&gt;&#xA;&lt;li&gt;range 一般索引的范围查询&lt;/li&gt;&#xA;&lt;li&gt;index 全表扫描，非聚簇索引的叶子节点&lt;/li&gt;&#xA;&lt;li&gt;All 聚簇索引的全表扫描&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;possible-keys列&#34;&gt;&#xD;&#xA;  possible keys列&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#possible-keys%e5%88%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h4&gt;&#xD;&#xA;&lt;p&gt;显示查询可能使用哪些索引来查找&lt;/p&gt;</description>
    </item>
    <item>
      <title>索引树高度计算</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/mysql/tree-high/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/mysql/tree-high/</guid>
      <description>&lt;h1 id=&#34;索引树高度计算&#34;&gt;&#xD;&#xA;  索引树高度计算&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e7%b4%a2%e5%bc%95%e6%a0%91%e9%ab%98%e5%ba%a6%e8%ae%a1%e7%ae%97&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;基本原理&#34;&gt;&#xD;&#xA;  基本原理&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;Innodb是索引组织表，每个页都包含一个PAGE_LEVEL，表示当前页在索引上的高度&lt;/p&gt;&#xA;&lt;p&gt;默认叶子节点高度为0，ROOT节点PAGE_LEVEL+1就是这棵索引高度&lt;/p&gt;&#xA;&lt;p&gt;PAGE_LEVEL在每个页的64位偏移位置，占用2字节&lt;/p&gt;&#xA;&lt;p&gt;找到ROOT页位置，知道单页大小，使用hexdump在指定表空间找到第PAGE_NO页的64位偏移量的后两个字节即可&lt;/p&gt;&#xA;&lt;h2 id=&#34;找到root页信息&#34;&gt;&#xD;&#xA;  找到ROOT页信息&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%89%be%e5%88%b0root%e9%a1%b5%e4%bf%a1%e6%81%af&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;SELECT b.name, a.name, index_id, type, a.space, a.PAGE_NO&#xA;FROM information_schema.INNODB_SYS_INDEXES a,&#xA;information_schema.INNODB_SYS_TABLES b&#xA;WHERE a.table_id = b.table_id AND a.space &amp;lt;&amp;gt; 0;&lt;/p&gt;&#xA;&lt;p&gt;结果：&#xA;&lt;img src=&#34;./images/root-info.png&#34; alt=&#34;&amp;ldquo;root页信息&amp;rdquo;&#34; title=&#34;root页信息&#34;/&gt;&#xA;其中（space、PAGE_NO）指向ROOT页&lt;/p&gt;&#xA;&lt;p&gt;space是表空间，可以是系统表空间（如ibdata1文件）或独立表空间（如每个InnoDB表的.ibd文件）。表空间由多个区（extent）组成，每个区包含连续的页（page）&lt;/p&gt;&#xA;&lt;p&gt;也就是ROOT页是space的page_no页&lt;/p&gt;&#xA;&lt;h2 id=&#34;查看innodb_page_size&#34;&gt;&#xD;&#xA;  查看innodb_page_size&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%9f%a5%e7%9c%8binnodb_page_size&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;show variables like &amp;#39;innodb_page_size&amp;#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结果：&#xA;&lt;img src=&#34;./images/innodb_page_size.png&#34; alt=&#34;&amp;ldquo;innodb_page_size&amp;rdquo;&#34; title=&#34;innodb_page_size&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;也就是Innodb默认的页大小16KB&lt;/p&gt;&#xA;&lt;h2 id=&#34;找到root的page_level得到索引高度&#34;&gt;&#xD;&#xA;  找到ROOT的PAGE_LEVEL，得到索引高度&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%89%be%e5%88%b0root%e7%9a%84page_level%e5%be%97%e5%88%b0%e7%b4%a2%e5%bc%95%e9%ab%98%e5%ba%a6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;首先要找到表对应的ibd文件，也就是表空间文件&lt;/p&gt;&#xA;&lt;p&gt;所在位置是MySQL的数据目录下的数据库名文件夹下&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#查找MySQL数据目录&#xD;&#xA;show variables like &amp;#39;datadir&amp;#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;./images/dir.png&#34; alt=&#34;&amp;ldquo;dir&amp;rdquo;&#34; title=&#34;dir&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;我的MySQL是用Docker起的，docker中没有安装hexdump命令，不过这个目录被挂载出来了，考虑在宿主机上分析其中的ibd文件&lt;/p&gt;&#xA;&lt;p&gt;但所在文件夹和文件权限限制了宿主机外用户访问文件夹和文件&#xA;&lt;img src=&#34;./images/docker-dir.png&#34; alt=&#34;&amp;ldquo;docker-dir&amp;rdquo;&#34; title=&#34;docker-dir&#34;/&gt;&#xA;修改权限需要到docker容器中修改该文件和对应文件夹权限&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;chmod 755 path&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;原本权限为750，禁止其他用户读写文件夹&lt;/p&gt;&#xA;&lt;p&gt;修改后在宿主机进入文件夹中，找到所需文件，在文件夹执行命令&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;hexdump -C -s 49216 -n 10 goods_info_100M.ibd&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;./images/page-info.png&#34; alt=&#34;&amp;ldquo;page-info&amp;rdquo;&#34; title=&#34;page-info&#34;/&gt;&lt;/p&gt;&#xA;&lt;p&gt;前两个字节是PAGE_LEVEL，所以这个索引树高度为3+1 = 4&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
