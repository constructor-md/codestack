<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Spring on CodeStack</title>
    <link>https://constructor-md.github.io/codestack/docs/javaee/spring/</link>
    <description>Recent content in Spring on CodeStack</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <atom:link href="https://constructor-md.github.io/codestack/docs/javaee/spring/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>依赖注入|控制反转|自动装配</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/spring/ioc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/spring/ioc/</guid>
      <description>&lt;h1 id=&#34;依赖注入控制反转自动装配&#34;&gt;&#xD;&#xA;  依赖注入|控制反转|自动装配&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5%e6%8e%a7%e5%88%b6%e5%8f%8d%e8%bd%ac%e8%87%aa%e5%8a%a8%e8%a3%85%e9%85%8d&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;控制反转ioc与依赖注入di&#34;&gt;&#xD;&#xA;  控制反转(IOC)与依赖注入(DI)&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8e%a7%e5%88%b6%e5%8f%8d%e8%bd%acioc%e4%b8%8e%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5di&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;控制反转基本概念：  &lt;br&gt;&#xA;将对象的创建和管理的控制权，从某个实体类，转交给 Spring 容器&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;在传统模式中，对象需要哪些资源就要在类代码中写明自己去 new 出来&lt;br&gt;&#xA;现在则统一由 Spring 提供，从主动变成了被动。称为控制反转&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;依赖注入基本概念：&lt;br&gt;&#xA;对象间的依赖关系，被 Spring 容器自动注入到需要他们的对象中去&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;也就是由 Spring 容器来管理对象间的依赖关系&#xA;依赖注入是控制反转的一种实现形式&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;指的是组件自身提供普通的 Java 方法声明依赖关系。容器全权负责组件依赖关系的装配，将根据这些声明主动将符合依赖关系的对象设置给需要的对象，实现原理是反射&lt;/li&gt;&#xA;&lt;li&gt;为了实现控制反转的概念，Spring 实现了依赖注入的机制&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;依赖注入机制的使用方式：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;属性注入形式&#xA;xml方式：使类有 Set 方法，并设置 bean 和 property 。Spring 读取 xml 文件时，认为需要向 bean a 注入 bean b。这实质上是通过，使类有 set 方法，从而可实现用xml文件声明属性依赖关系，从而声明依赖关系，寻求注入的方式。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;img src=&#34;./images/DI-param.png&#34; alt=&#34;属性注入&#34; title=&#34;属性注入&#34;/&gt;&lt;/p&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;构造器注入形式&#xA;xml方式：使类具备有参构造函数，并设置 bean 和 property。实质上与上述是相似的，只是多支持了一种声明的方式。&#xA;&lt;img src=&#34;./images/DI-struct.png&#34; alt=&#34;构造器注入&#34; title=&#34;构造器注入&#34;/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Java显式配置&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过注解，描述某个类应该作为 Bean 被容器管理，且内部包含一些如何在上下文中创建 Bean 的细节。如 @Configuration。&lt;/li&gt;&#xA;&lt;li&gt;通过注解，描述某个方法的返回结果应该作为 Bean 被容器管理，如 @Bean。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;自动装配&#34;&gt;&#xD;&#xA;  自动装配&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%87%aa%e5%8a%a8%e8%a3%85%e9%85%8d&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;上述的依赖注入的使用方式，实际上都是在告诉 Spring 容器如何装配对象间的依赖关系&#xA;Spring 对于描述 Bean 如何进行装配时，提供了三种主要的装配机制：&lt;/p&gt;</description>
    </item>
    <item>
      <title>AOP</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/spring/aop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/spring/aop/</guid>
      <description>&lt;h1 id=&#34;aop&#34;&gt;&#xD;&#xA;  AOP&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aop&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;基本概念：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;编程时将所需逻辑写在切面中&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这么做的好处是，让一些公共的逻辑，重复的代码，能够出现在统一的位置，即切面中，方便维护，减少重复代码的开发量。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;思路上，是通过为某些切面，为某些方法提供行为增强。这种增强可能出现在方法执行前，方法执行后，方法返回前，方法异常时等。&lt;/li&gt;&#xA;&lt;li&gt;实现方法上，出于对某个方法进行前置或后置逻辑的编写的角度，想要通过代理模式来实现功能。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Spring的切面实现，支持了两种代理模式：JDK动态代理（默认）、CGLIB动态代理&lt;/p&gt;&#xA;&lt;h2 id=&#34;spring的动态代理实现&#34;&gt;&#xD;&#xA;  Spring的动态代理实现&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring%e7%9a%84%e5%8a%a8%e6%80%81%e4%bb%a3%e7%90%86%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;众所周知，代理模式的实现方法就是为当前类或者方法创建代理类&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;实际调用时调用代理类&lt;/li&gt;&#xA;&lt;li&gt;代理类再调用原本方法逻辑，代理类本身可以在调用原本方法前后&amp;quot;编织&amp;quot;入一些定义好的代码，在调用原本方法前后执行&amp;quot;编织&amp;quot;入的方法，实现&amp;quot;方法增强&amp;quot;&lt;/li&gt;&#xA;&lt;li&gt;探讨Spring如何实现动态代理，其实是探讨Spring如何动态创建代理类&#xA;&lt;ul&gt;&#xA;&lt;li&gt;静态代理是直接硬编码编写代理类，并替换调用方方法调用代理类&lt;/li&gt;&#xA;&lt;li&gt;但是动态代理就需要有一套代码，能根据不同内容的原本类，动态构建一个代理类，并在调用原本方法前后调用切面类内编写的增强方法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;静态代理示例&#34;&gt;&#xD;&#xA;  静态代理示例&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%9d%99%e6%80%81%e4%bb%a3%e7%90%86%e7%a4%ba%e4%be%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class ProxySubject implements Subject {&#xD;&#xA;    private RealSubject realSubject;&#xD;&#xA;&#xD;&#xA;    public ProxySubject(RealSubject realSubject) {&#xD;&#xA;        this.realSubject = realSubject;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    @Override&#xD;&#xA;    public void request() {&#xD;&#xA;        // 方法调用前的增强代码&#xD;&#xA;        System.out.println(&amp;#34;ProxySubject: Before calling the real subject.&amp;#34;);&#xD;&#xA;&#xD;&#xA;        // 调用被代理对象的方法&#xD;&#xA;        realSubject.request();&#xD;&#xA;&#xD;&#xA;        // 方法调用后的增强代码&#xD;&#xA;        System.out.println(&amp;#34;ProxySubject: After calling the real subject.&amp;#34;);&#xD;&#xA;    }&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;spring-aop-动态代理源码解析&#34;&gt;&#xD;&#xA;  Spring AOP 动态代理源码解析&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-aop-%e5%8a%a8%e6%80%81%e4%bb%a3%e7%90%86%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;接下来从源码层面逐一剖析Spring是如何实现AOP&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用项目：&lt;a href=&#34;https://github.com/constructor-md/kuibu-service&#34;&gt;跬步后端项目仓库&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;Branch: main&lt;/li&gt;&#xA;&lt;li&gt;commit: f2763b5c8308f59a399ad32ae2cdffef8aee1ee0&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;我的项目采用 SpringBoot:2.7.6 版本，直接引入 spring-boot-starter-aop 包&#xA;&lt;img src=&#34;./images/pom-springboot.png&#34; alt=&#34;pom-springboot&#34; title=&#34;pom-springboot&#34;/&gt;&#xA;&lt;img src=&#34;./images/pom-aop.png&#34; alt=&#34;pom-aop&#34; title=&#34;pom-aop&#34;/&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Spring事务</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/spring/transaction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/spring/transaction/</guid>
      <description>&lt;h1 id=&#34;spring事务&#34;&gt;&#xD;&#xA;  Spring事务&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring%e4%ba%8b%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;事务实现&#34;&gt;&#xD;&#xA;  事务实现&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8b%e5%8a%a1%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;基于数据库事务和AOP&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;对于使用了@Transactional注解的Bean，创建代理对象&lt;/li&gt;&#xA;&lt;li&gt;当调用代理对象的方法时，如果方法上有@Transactional注解，利用事务管理器创建一个数据库连接&lt;/li&gt;&#xA;&lt;li&gt;修改数据库连接的autocommit属性为false，禁止此连接自动提交&lt;/li&gt;&#xA;&lt;li&gt;执行当前方法，方法中会包含sql，没有异常就直接提交事务&lt;/li&gt;&#xA;&lt;li&gt;出现异常且需要回滚则回滚事务，不需要回滚就仍然提交事务&lt;/li&gt;&#xA;&lt;li&gt;Spring的事务隔离级别就是数据库的隔离级别&lt;/li&gt;&#xA;&lt;li&gt;Spring事务的传播机制时Spring事务自己实现的，有很多种。用于设置不同场景下，对嵌套方法是否该用同一个事务执行的情况进行支持&lt;/li&gt;&#xA;&lt;li&gt;传播机制是通过数据库连接来实现的，每个数据库连接一个事务，当传播机制配置为应该需要新开一个事务，实际上就是为方法新建一个数据库连接，在新连接上执行SQL。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;默认事务传播机制是：REQUIRED，如果存在事务则加入，不存在则创建&lt;/p&gt;&#xA;&lt;h2 id=&#34;事务传播机制&#34;&gt;&#xD;&#xA;  事务传播机制&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8b%e5%8a%a1%e4%bc%a0%e6%92%ad%e6%9c%ba%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;事务传播机制指的是当事务方法被调用时，事务如何传播&lt;/p&gt;&#xA;&lt;p&gt;传播机制的指定：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    @Transactional(propagation = Propagation.REQUIRED)&#xD;&#xA;    public void calledMethod() {&#xD;&#xA;&#xD;&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;propagation_required默认&#34;&gt;&#xD;&#xA;  PROPAGATION_REQUIRED（默认）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#propagation_required%e9%bb%98%e8%ae%a4&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果调用方法不存在事务，则创建一个事务&lt;br&gt;&#xA;从数据源获取一个新的数据库连接并开启新事务&lt;/li&gt;&#xA;&lt;li&gt;如果调用方法有事务，则加入该事务&lt;br&gt;&#xA;也就是不做处理，复用当前的数据库连接和事务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;效果：存在且仅存在一个事务，回滚到最开始事务创建时&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;调用方有事务，和调用方一起作为原子操作&lt;/li&gt;&#xA;&lt;li&gt;调用方没有事务，自己是原子操作&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;propagation_supports&#34;&gt;&#xD;&#xA;  PROPAGATION_SUPPORTS&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#propagation_supports&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果调用方法不存在事务，以非事务方式运行&lt;br&gt;&#xA;获取数据源连接执行SQL，但不开启事务&lt;/li&gt;&#xA;&lt;li&gt;如果调用方法有事务，则加入该事务&lt;br&gt;&#xA;复用当前的数据库连接和事务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;效果：遵从被调用方的决定，有就用，没有也不开&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;调用方有事务，和调用方一起作为原子操作&lt;/li&gt;&#xA;&lt;li&gt;调用方没有事务，都不是原子操作&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;propagation_mandatory&#34;&gt;&#xD;&#xA;  PROPAGATION_MANDATORY&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#propagation_mandatory&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果调用方法不存在事务，抛出异常&lt;br&gt;&#xA;发现当前没有事务，抛出 IllegalTransactionStateException 异常 即要求必须在事务环境下执行&lt;/li&gt;&#xA;&lt;li&gt;如果调用方法有事务，则加入该事务&lt;br&gt;&#xA;复用当前的数据库连接和事务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;效果：必须有事务才能调用该方法&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;调用方有事务，和调用方一起作为原子操作&lt;/li&gt;&#xA;&lt;li&gt;调用方没有事务，报错&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;propagation_requires_new&#34;&gt;&#xD;&#xA;  PROPAGATION_REQUIRES_NEW&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#propagation_requires_new&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果调用方法不存在事务，则创建一个新事务 &lt;br&gt;&#xA;从数据源获取一个新的数据库连接并开启新事务&lt;/li&gt;&#xA;&lt;li&gt;如果调用方法有事务，挂起当前事务，并创建新事务执行&lt;br&gt;&#xA;挂起调用者事务，获取新的链接并开启新事务，执行完毕后，回复调用者的事务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;效果：不管调用方有无事务，自己都是单独事务执行&#xA;调用方和自己是两个原子，报错不影响调用方，也不被调用方影响&lt;/p&gt;</description>
    </item>
    <item>
      <title>Bean 生命周期与 SpringBoot 扩展点</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/spring/bean-liftcycle-and-extension/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/spring/bean-liftcycle-and-extension/</guid>
      <description>&lt;h1 id=&#34;bean-生命周期与-springboot-扩展点&#34;&gt;&#xD;&#xA;  Bean 生命周期与 SpringBoot 扩展点&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#bean-%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e4%b8%8e-springboot-%e6%89%a9%e5%b1%95%e7%82%b9&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;生命周期：&lt;br&gt;&#xA;从对象的创建到销毁的过程&lt;/p&gt;&#xA;&lt;p&gt;从 SpringBootApplication.run 方法出发，执行到 AbstractApplication.refresh 方法&lt;br&gt;&#xA;从此处开始进行 BeanFactory 等资源的准备、XML/注解的扫描&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Spring 创建 BeanFactory ，工厂扫描 XML、Java 注解等，生成 BeanDefinition 对象&lt;/li&gt;&#xA;&lt;li&gt;调用工厂方法根据 BeanDefinition 对象通过反射生成 Bean 实例，完成实例化&lt;/li&gt;&#xA;&lt;li&gt;Spring 将值和 Bean 引用注入到 Bean 对应属性&lt;/li&gt;&#xA;&lt;li&gt;如果 Bean 实现了 BeanNameAware 接口，Spring 将 Bean 的 ID 传递给 setBeanName 方法&lt;/li&gt;&#xA;&lt;li&gt;如果 Bean 实现了 BeanFactoryAware 接口，Spring 调用 setBeanFactory 将 BeanFactory 实例传入&lt;/li&gt;&#xA;&lt;li&gt;如果 Bean 实现了 ApplicationContextAware 接口，Spring 调用 setApplicationAware 将应用上下文传入&lt;/li&gt;&#xA;&lt;li&gt;如果 Bean 实现了 BeanPostProcessor 接口，Spring 调用 postProcessBeforeInitialization 方法&lt;/li&gt;&#xA;&lt;li&gt;如果 Bean 中有 @PostConstruct 方法，执行该方法&lt;/li&gt;&#xA;&lt;li&gt;如果 Bean 实现了 InitilizingBean 接口，Spring 调用 afterPropertiesSet 方法；如果 @Bean 声明了 initMethod，Spring 再调用该方法&lt;/li&gt;&#xA;&lt;li&gt;如果 Bean 实现了 BeanPostProcessor 接口，Spring 调用 postProcessorAfterInitialization 方法&lt;/li&gt;&#xA;&lt;li&gt;此时 Bean 的属性已经设置和前后置操作完毕，完成了初始化。Bean 将一直存在于应用上下文中，直到应用上下文被销毁&lt;/li&gt;&#xA;&lt;li&gt;如果 Bean 中有 @PreDestory 方法，执行该方法&lt;/li&gt;&#xA;&lt;li&gt;如果 Bean 实现了 DisposableBean 接口，Spring 将调用 destory 方法。如果 @Bean 声明了 destoryMethod，Spring 再调用该方法。&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>SpringBoot 引入第三方 Jar 包</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/spring/three-party-jar-import/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/spring/three-party-jar-import/</guid>
      <description>&lt;h1 id=&#34;springboot-引入第三方-jar-包&#34;&gt;&#xD;&#xA;  SpringBoot 引入第三方 Jar 包&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#springboot-%e5%bc%95%e5%85%a5%e7%ac%ac%e4%b8%89%e6%96%b9-jar-%e5%8c%85&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;SpringBoot 通过 SPI 机制引入第三方 Jar 包&lt;/p&gt;&#xA;&lt;h2 id=&#34;spi-机制&#34;&gt;&#xD;&#xA;  SPI 机制&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spi-%e6%9c%ba%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;JAVA SPI：Server Provider Interface 服务提供者接口，服务发现机制&lt;br&gt;&#xA;以 JDBC 为例 &lt;br&gt;&#xA;JDBC：通常执行流程&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;加载数据库驱动&lt;/li&gt;&#xA;&lt;li&gt;通过DriverManager对象，获取Connection连接对象&lt;/li&gt;&#xA;&lt;li&gt;创建Statement对象执行SQL语句&lt;/li&gt;&#xA;&lt;li&gt;处理ResultSet结果集&lt;/li&gt;&#xA;&lt;li&gt;关闭连接&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;但是其中驱动加载时，Java 仅提供了一个接口，具体的驱动实现类是由各个数据库厂商提供的&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;接口不能被实例化，要想实例化，就必须知道具体驱动类的全限定名&lt;/li&gt;&#xA;&lt;li&gt;即需要知道驱动类的全限定名&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Java 开发者想出在项目下的 ClassPath 目录中，创建 META-INF/services 文件夹&lt;br&gt;&#xA;在文件夹内创建&lt;strong&gt;以实现接口全限定名为名&lt;/strong&gt;的文件，&lt;strong&gt;内容为实现类的全限定名&lt;/strong&gt;&lt;br&gt;&#xA;通过IO获取所有的全限定名，将指定的Class文件实例化存储到容器中，完成第三方的实现类的实例化&lt;br&gt;&#xA;通过java.util.ServiceLoader.load方法实现SPI&lt;/p&gt;&#xA;&lt;h2 id=&#34;springboot-自动装配&#34;&gt;&#xD;&#xA;  SpringBoot 自动装配&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#springboot-%e8%87%aa%e5%8a%a8%e8%a3%85%e9%85%8d&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;SpringBoot的自动装配：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SpringBoot 开发中必不可少需要将第三方框架的 Jar 包内容加载到 IOC 容器中&lt;/li&gt;&#xA;&lt;li&gt;但是SpringBoot默认加载启动类所在包或子包的内容，或者指定包扫描路径，指令包扫描路径在很多第三方引入的时候显然太繁琐&lt;/li&gt;&#xA;&lt;li&gt;由于包名未知，不能通过扫描注入&#xA;SpringBoot 实现思路：&lt;/li&gt;&#xA;&lt;li&gt;SpringBoot规定了要接入SpringBoot的第三方框架，需要在Classpath目录下的META-INF文件中定义spring.factories文件&lt;/li&gt;&#xA;&lt;li&gt;在其中定义需要被加载到IOC容器的类&lt;/li&gt;&#xA;&lt;li&gt;SpringBoot启动时会自动扫描ClassPath目录下的所有META-INF的spring.factories文件，读取其中的要注册的类，通过反射进行实例化&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;SPI机制让接口和具体实现类解耦，使得可以根据具体的业务情况启用或替换具体组件&lt;/p&gt;</description>
    </item>
    <item>
      <title>SpringMVC 接收 HTTP</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/spring/springmvc-http/indxe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/spring/springmvc-http/indxe/</guid>
      <description>&lt;h1 id=&#34;springmvc-接收-http&#34;&gt;&#xD;&#xA;  SpringMVC 接收 HTTP&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#springmvc-%e6%8e%a5%e6%94%b6-http&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SpringMVC 是一个基于 Spring 的 Web 框架，运行于 Tomcat 等 Servlet 容器上&lt;/li&gt;&#xA;&lt;li&gt;SpringBoot 内置 Tomcat 容器&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;当使用原生 Java Servlet 实现 Web 服务器，运行于 Tomcat 上时&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;用户发起一个 HTTP 请求，Tomcat 收到请求，解析 HTTP 报文&lt;/li&gt;&#xA;&lt;li&gt;Tomcat 根据 URL 找到对应的 Servlet，构建 HttpServletRequest 和 HttpServletResponce 对象，调用 servlet 的 service 方法，将对象引用传入该方法&lt;/li&gt;&#xA;&lt;li&gt;Service 方法获取 Http 请求相关的信息，区分请求类型调用不同的方法，将处理结果放入 Responce 对象。&lt;/li&gt;&#xA;&lt;li&gt;Tomcat 将 Responce 对象封装成 Http 响应报文，返回给客户端。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;当使用 SpringMVC 实现 Web 容器，运行于 Tomcat 上时：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;用户发起一个 HTTP 请求，Tomcat 收到请求，生成一个线程解析 HTTP 报文&lt;/li&gt;&#xA;&lt;li&gt;Tomcat 生成 HttpRequest 和 HttpResponce 对象，调用 HttpServlet.service 方法，最终将对象转发给 DispatcherServlet.doService 方法（即全流程只有一个 servlet 存在，与 URL 无关）&lt;/li&gt;&#xA;&lt;li&gt;DispatcherServlet 是统一访问点，将请求委托给其他业务处理器。doService 方法调用 doDispatch 方法执行分发&lt;/li&gt;&#xA;&lt;li&gt;在 Tomcat 初始化时，通知 Spring 初始化容器，SpringMVC 会遍历容器中的 Bean，找到每一个 Controller 的所有方法访问的 url，和 Controller 保存到一个 Map 中。（HandlerMapping 组件获得了 URL 和 Controller 的关系）&lt;/li&gt;&#xA;&lt;li&gt;分发时 doDispatch 方法根据 URL 找到 Controller，找到 Controller 中对应的方法。将 request 的参数等和方法上的参数根据注解等进行绑定，最后通过反射调用方法。&lt;/li&gt;&#xA;&lt;li&gt;具体业务逻辑执行完后，回到 DispatcherServlet，进行后续处理，封装视图等&lt;/li&gt;&#xA;&lt;li&gt;Tomcat 将响应对象封装成 HTTP 响应报文，返回给客户端&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;拦截器是在 Spring 中起作用，具体在分发前执行前置拦截器逻辑，分发后执行后置拦截器逻辑&lt;/li&gt;&#xA;&lt;li&gt;过滤器是在 Tomcat 中起作用，具体在进入 servlet 前后进行预处理&lt;/li&gt;&#xA;&lt;li&gt;切面是在具体方法前起作用，具体在调用方法逻辑前后，会处理注解、切点等的逻辑&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>SpringBoot 相比 Spring</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/spring/springboot-spring/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/spring/springboot-spring/</guid>
      <description>&lt;h1 id=&#34;springboot-相比-spring&#34;&gt;&#xD;&#xA;  SpringBoot 相比 Spring&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#springboot-%e7%9b%b8%e6%af%94-spring&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;SpringBoot 的核心能力：快速启动、最小化配置&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;内嵌 Servlet 容器 Tomcat，可以让 Web 项目打成 jar 包，通过 java -jar 运行&lt;/li&gt;&#xA;&lt;li&gt;提供 starter pom 系列，简化 maven 的依赖加载，减少依赖冲突的产生&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;支持自动化配置&lt;/li&gt;&#xA;&lt;li&gt;不需要像 Spring 一样配置 Bean，使用 properties 或 yaml 配置文件以及配置类简单配置即可。&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
  </channel>
</rss>
