<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Spring on CodeStack</title>
    <link>https://constructor-md.github.io/codestack/docs/javaee/spring/</link>
    <description>Recent content in Spring on CodeStack</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <atom:link href="https://constructor-md.github.io/codestack/docs/javaee/spring/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>依赖注入|控制反转|自动装配</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/spring/ioc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/spring/ioc/</guid>
      <description>&lt;h1 id=&#34;依赖注入控制反转自动装配&#34;&gt;&#xD;&#xA;  依赖注入|控制反转|自动装配&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5%e6%8e%a7%e5%88%b6%e5%8f%8d%e8%bd%ac%e8%87%aa%e5%8a%a8%e8%a3%85%e9%85%8d&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;控制反转ioc与依赖注入di&#34;&gt;&#xD;&#xA;  控制反转(IOC)与依赖注入(DI)&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e6%8e%a7%e5%88%b6%e5%8f%8d%e8%bd%acioc%e4%b8%8e%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5di&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;控制反转基本概念：  &lt;br&gt;&#xA;将对象的创建和管理的控制权，从某个实体类，转交给 Spring 容器&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;在传统模式中，对象需要哪些资源就要在类代码中写明自己去 new 出来&lt;br&gt;&#xA;现在则统一由 Spring 提供，从主动变成了被动。称为控制反转&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;依赖注入基本概念：&lt;br&gt;&#xA;对象间的依赖关系，被 Spring 容器自动注入到需要他们的对象中去&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;也就是由 Spring 容器来管理对象间的依赖关系&#xA;依赖注入是控制反转的一种实现形式&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;指的是组件自身提供普通的 Java 方法声明依赖关系。容器全权负责组件依赖关系的装配，将根据这些声明主动将符合依赖关系的对象设置给需要的对象，实现原理是反射&lt;/li&gt;&#xA;&lt;li&gt;为了实现控制反转的概念，Spring 实现了依赖注入的机制&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;依赖注入机制的使用方式：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;属性注入形式&#xA;xml方式：使类有 Set 方法，并设置 bean 和 property 。Spring 读取 xml 文件时，认为需要向 bean a 注入 bean b。这实质上是通过，使类有 set 方法，从而可实现用xml文件声明属性依赖关系，从而声明依赖关系，寻求注入的方式。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;img src=&#34;./images/DI-param.png&#34; alt=&#34;属性注入&#34; title=&#34;属性注入&#34;/&gt;&lt;/p&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;构造器注入形式&#xA;xml方式：使类具备有参构造函数，并设置 bean 和 property。实质上与上述是相似的，只是多支持了一种声明的方式。&#xA;&lt;img src=&#34;./images/DI-struct.png&#34; alt=&#34;构造器注入&#34; title=&#34;构造器注入&#34;/&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Java显式配置&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过注解，描述某个类应该作为 Bean 被容器管理，且内部包含一些如何在上下文中创建 Bean 的细节。如 @Configuration。&lt;/li&gt;&#xA;&lt;li&gt;通过注解，描述某个方法的返回结果应该作为 Bean 被容器管理，如 @Bean。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;自动装配&#34;&gt;&#xD;&#xA;  自动装配&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%87%aa%e5%8a%a8%e8%a3%85%e9%85%8d&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;上述的依赖注入的使用方式，实际上都是在告诉 Spring 容器如何装配对象间的依赖关系&#xA;Spring 对于描述 Bean 如何进行装配时，提供了三种主要的装配机制：&lt;/p&gt;</description>
    </item>
    <item>
      <title>AOP</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/spring/aop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/spring/aop/</guid>
      <description>&lt;h1 id=&#34;aop&#34;&gt;&#xD;&#xA;  AOP&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#aop&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;p&gt;基本概念：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;编程时将所需逻辑写在切面中&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这么做的好处是，让一些公共的逻辑，重复的代码，能够出现在统一的位置，即切面中，方便维护，减少重复代码的开发量。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;思路上，是通过为某些切面，为某些方法提供行为增强。这种增强可能出现在方法执行前，方法执行后，方法返回前，方法异常时等。&lt;/li&gt;&#xA;&lt;li&gt;实现方法上，出于对某个方法进行前置或后置逻辑的编写的角度，想要通过代理模式来实现功能。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Spring的切面实现，支持了两种代理模式：JDK动态代理（默认）、CGLIB动态代理&lt;/p&gt;&#xA;&lt;h2 id=&#34;spring的动态代理实现&#34;&gt;&#xD;&#xA;  Spring的动态代理实现&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring%e7%9a%84%e5%8a%a8%e6%80%81%e4%bb%a3%e7%90%86%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;众所周知，代理模式的实现方法就是为当前类或者方法创建代理类&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;实际调用时调用代理类&lt;/li&gt;&#xA;&lt;li&gt;代理类再调用原本方法逻辑，代理类本身可以在调用原本方法前后&amp;quot;编织&amp;quot;入一些定义好的代码，在调用原本方法前后执行&amp;quot;编织&amp;quot;入的方法，实现&amp;quot;方法增强&amp;quot;&lt;/li&gt;&#xA;&lt;li&gt;探讨Spring如何实现动态代理，其实是探讨Spring如何动态创建代理类&#xA;&lt;ul&gt;&#xA;&lt;li&gt;静态代理是直接硬编码编写代理类，并替换调用方方法调用代理类&lt;/li&gt;&#xA;&lt;li&gt;但是动态代理就需要有一套代码，能根据不同内容的原本类，动态构建一个代理类，并在调用原本方法前后调用切面类内编写的增强方法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;静态代理示例&#34;&gt;&#xD;&#xA;  静态代理示例&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e9%9d%99%e6%80%81%e4%bb%a3%e7%90%86%e7%a4%ba%e4%be%8b&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class ProxySubject implements Subject {&#xD;&#xA;    private RealSubject realSubject;&#xD;&#xA;&#xD;&#xA;    public ProxySubject(RealSubject realSubject) {&#xD;&#xA;        this.realSubject = realSubject;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    @Override&#xD;&#xA;    public void request() {&#xD;&#xA;        // 方法调用前的增强代码&#xD;&#xA;        System.out.println(&amp;#34;ProxySubject: Before calling the real subject.&amp;#34;);&#xD;&#xA;&#xD;&#xA;        // 调用被代理对象的方法&#xD;&#xA;        realSubject.request();&#xD;&#xA;&#xD;&#xA;        // 方法调用后的增强代码&#xD;&#xA;        System.out.println(&amp;#34;ProxySubject: After calling the real subject.&amp;#34;);&#xD;&#xA;    }&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;spring-aop-动态代理源码解析&#34;&gt;&#xD;&#xA;  Spring AOP 动态代理源码解析&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring-aop-%e5%8a%a8%e6%80%81%e4%bb%a3%e7%90%86%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;p&gt;接下来从源码层面逐一剖析Spring是如何实现AOP&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用项目：&lt;a href=&#34;https://github.com/constructor-md/kuibu-service&#34;&gt;跬步后端项目仓库&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;Branch: main&lt;/li&gt;&#xA;&lt;li&gt;commit: f2763b5c8308f59a399ad32ae2cdffef8aee1ee0&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;我的项目采用 SpringBoot:2.7.6 版本，直接引入 spring-boot-starter-aop 包&#xA;&lt;img src=&#34;./images/pom-springboot.png&#34; alt=&#34;pom-springboot&#34; title=&#34;pom-springboot&#34;/&gt;&#xA;&lt;img src=&#34;./images/pom-aop.png&#34; alt=&#34;pom-aop&#34; title=&#34;pom-aop&#34;/&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Spring事务</title>
      <link>https://constructor-md.github.io/codestack/docs/javaee/spring/transaction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://constructor-md.github.io/codestack/docs/javaee/spring/transaction/</guid>
      <description>&lt;h1 id=&#34;spring事务&#34;&gt;&#xD;&#xA;  Spring事务&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#spring%e4%ba%8b%e5%8a%a1&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h1&gt;&#xD;&#xA;&lt;h2 id=&#34;事务实现&#34;&gt;&#xD;&#xA;  事务实现&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8b%e5%8a%a1%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;基于数据库事务和AOP&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;对于使用了@Transactional注解的Bean，创建代理对象&lt;/li&gt;&#xA;&lt;li&gt;当调用代理对象的方法时，如果方法上有@Transactional注解，利用事务管理器创建一个数据库连接&lt;/li&gt;&#xA;&lt;li&gt;修改数据库连接的autocommit属性为false，禁止此连接自动提交&lt;/li&gt;&#xA;&lt;li&gt;执行当前方法，方法中会包含sql，没有异常就直接提交事务&lt;/li&gt;&#xA;&lt;li&gt;出现异常且需要回滚则回滚事务，不需要回滚就仍然提交事务&lt;/li&gt;&#xA;&lt;li&gt;Spring的事务隔离级别就是数据库的隔离级别&lt;/li&gt;&#xA;&lt;li&gt;Spring事务的传播机制时Spring事务自己实现的，有很多种。用于设置不同场景下，对嵌套方法是否该用同一个事务执行的情况进行支持&lt;/li&gt;&#xA;&lt;li&gt;传播机制是通过数据库连接来实现的，每个数据库连接一个事务，当传播机制配置为应该需要新开一个事务，实际上就是为方法新建一个数据库连接，在新连接上执行SQL。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;默认事务传播机制是：REQUIRED，如果存在事务则加入，不存在则创建&lt;/p&gt;&#xA;&lt;h2 id=&#34;事务传播机制&#34;&gt;&#xD;&#xA;  事务传播机制&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8b%e5%8a%a1%e4%bc%a0%e6%92%ad%e6%9c%ba%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h2&gt;&#xD;&#xA;&lt;p&gt;事务传播机制指的是当事务方法被调用时，事务如何传播&lt;/p&gt;&#xA;&lt;p&gt;传播机制的指定：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    @Transactional(propagation = Propagation.REQUIRED)&#xD;&#xA;    public void calledMethod() {&#xD;&#xA;&#xD;&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;propagation_required默认&#34;&gt;&#xD;&#xA;  PROPAGATION_REQUIRED（默认）&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#propagation_required%e9%bb%98%e8%ae%a4&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果调用方法不存在事务，则创建一个事务&lt;br&gt;&#xA;从数据源获取一个新的数据库连接并开启新事务&lt;/li&gt;&#xA;&lt;li&gt;如果调用方法有事务，则加入该事务&lt;br&gt;&#xA;也就是不做处理，复用当前的数据库连接和事务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;效果：存在且仅存在一个事务，回滚到最开始事务创建时&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;调用方有事务，和调用方一起作为原子操作&lt;/li&gt;&#xA;&lt;li&gt;调用方没有事务，自己是原子操作&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;propagation_supports&#34;&gt;&#xD;&#xA;  PROPAGATION_SUPPORTS&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#propagation_supports&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果调用方法不存在事务，以非事务方式运行&lt;br&gt;&#xA;获取数据源连接执行SQL，但不开启事务&lt;/li&gt;&#xA;&lt;li&gt;如果调用方法有事务，则加入该事务&lt;br&gt;&#xA;复用当前的数据库连接和事务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;效果：遵从被调用方的决定，有就用，没有也不开&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;调用方有事务，和调用方一起作为原子操作&lt;/li&gt;&#xA;&lt;li&gt;调用方没有事务，都不是原子操作&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;propagation_mandatory&#34;&gt;&#xD;&#xA;  PROPAGATION_MANDATORY&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#propagation_mandatory&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果调用方法不存在事务，抛出异常&lt;br&gt;&#xA;发现当前没有事务，抛出 IllegalTransactionStateException 异常 即要求必须在事务环境下执行&lt;/li&gt;&#xA;&lt;li&gt;如果调用方法有事务，则加入该事务&lt;br&gt;&#xA;复用当前的数据库连接和事务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;效果：必须有事务才能调用该方法&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;调用方有事务，和调用方一起作为原子操作&lt;/li&gt;&#xA;&lt;li&gt;调用方没有事务，报错&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;propagation_requires_new&#34;&gt;&#xD;&#xA;  PROPAGATION_REQUIRES_NEW&#xD;&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#propagation_requires_new&#34;&gt;#&lt;/a&gt;&#xD;&#xA;&lt;/h3&gt;&#xD;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果调用方法不存在事务，则创建一个新事务 &lt;br&gt;&#xA;从数据源获取一个新的数据库连接并开启新事务&lt;/li&gt;&#xA;&lt;li&gt;如果调用方法有事务，挂起当前事务，并创建新事务执行&lt;br&gt;&#xA;挂起调用者事务，获取新的链接并开启新事务，执行完毕后，回复调用者的事务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;效果：不管调用方有无事务，自己都是单独事务执行&#xA;调用方和自己是两个原子，报错不影响调用方，也不被调用方影响&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
